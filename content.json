{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"[LeetCode] 1002. 查找常用字符","text":"题目描述给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1：12输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 示例 2：12输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;] 提示： 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 思路本题可以理解为求每个字符串之间字符数量的交集,我们可以用hashmap来表示字符-数量之间的关系，但是考虑到效率的问题，我们可以使用数组来对代码进行优化。用数组result的下标i表示是哪个字符，用result[i]表示该字符出现的次数。 实现123456789101112131415161718192021222324252627282930class Solution { public List&lt;String&gt; commonChars(String[] A) { List&lt;HashMap&lt;Character, Integer&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (String str : A) { HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char ch : str.toCharArray()) { int count = map.getOrDefault(ch, 0); map.put(ch, count + 1); } list.add(map); } Set&lt;Character&gt; cmp = list.get(0).keySet(); for (HashMap&lt;Character, Integer&gt; map : list) { cmp.retainAll(map.keySet()); } for (Character c : cmp) { int min = Integer.MAX_VALUE; for (HashMap&lt;Character, Integer&gt; map : list) { min = Math.min(min, map.get(c)); } for (int i = 0; i &lt; min; i++) { result.add(String.valueOf(c)); } } return result; }} 123456789101112131415161718192021222324252627class Solution { public List&lt;String&gt; commonChars(String[] A) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); int[] counter = new int[26]; for (char ch : A[0].toCharArray()) { counter[ch - 'a'] = counter[ch - 'a'] + 1; } for (int i = 1; i &lt; A.length; i++) { int[] temp = new int[26]; for (char ch : A[i].toCharArray()) { temp[ch - 'a'] = temp[ch - 'a'] + 1; } for (int j = 0; j &lt; 26; j++) { counter[j] = Math.min(counter[j], temp[j]); } } for (int i = 0; i &lt; 26; i++) { if (counter[i] == 0) { continue; } for (int j = 0; j &lt; counter[i]; j++) { result.add(((char) ('a' + i) + \"\")); } } return result; }}","link":"/2019/05/01/1002-find-common-characters/"},{"title":"[LeetCode] 103. 二叉树的锯齿形层次遍历","text":"题目描述给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \\9 20 / \\ 15 7 返回锯齿形层次遍历如下：12345[ [3], [20,9], [15,7]] 思路本质上考察的是二叉树的层次遍历，只是在添加节点值的时候选择倒序还是正序添加。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) { return result; } boolean flag = false; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int size = queue.size(); while(size &gt; 0) { TreeNode node = queue.remove(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } if (flag) { list.add(0, node.val); } else { list.add(node.val); } size -= 1; } flag = !flag; result.add(list); } return result; }}","link":"/2019/03/12/103-binary-tree-zigzag-level-order-traversal/"},{"title":"[LeetCode] 105. 从前序与中序遍历序列构造二叉树","text":"题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：12345 3 / \\9 20 / \\ 15 7 思路看一下前序和中序有什么特点，前序1,2,4,7,3,5,6,8 ，中序4,7,2,1,5,3,8,6 有如下特征： 前序中左起第一位1肯定是根结点，我们可以据此找到中序中根结点的位置rootin 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left = rootin - leftin 前序中结点分布应该是：[根结点，左子树结点，右子树结点] 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围 如果我们要前序遍历生成二叉树的话，下一层递归应该是 左子树：root-&gt;left = pre_order(前序左子树范围，中序左子树范围，前序序列，中序序列) 右子树：root-&gt;right = pre_order(前序右子树范围，中序右子树范围，前序序列，中序序列) 每一层递归都要返回当前根结点root 实现123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } private TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart &gt; preEnd) { return null; } // 根节点的值 int rootVal = preorder[preStart]; TreeNode root = new TreeNode(rootVal); int rootIndex = inStart; while(rootIndex &lt; inEnd &amp;&amp; inorder[rootIndex] != rootVal) { rootIndex += 1; } root.left = buildTree(preorder, preStart + 1, preStart + rootIndex - inStart, inorder, inStart, rootIndex - 1); root.right = buildTree(preorder, preStart + rootIndex - inStart + 1, preEnd, inorder, rootIndex + 1, inEnd); return root; }}","link":"/2019/04/11/105-construct-binary-tree-from-preorder-and-inorder-traversal/"},{"title":"[LeetCode] 113. 路径综合II","text":"题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22，12345678 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 返回:1234[ [5,4,11,2], [5,8,4,5]] 思路递归方式判断当前节点是否满足sum要求且需要满足叶子结点的条件，如满足则将路径添加到结果里。再判断左子树和右子树不为空时，分别对其进行递归调用 实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } *//** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); dfs(root, sum, list); return result; } private void dfs(TreeNode node, int sum, List&lt;Integer&gt; list) { if (node == null) return; list.add(node.val); if (sum == node.val &amp;&amp; node.left == null &amp;&amp; node.right == null) { result.add(new ArrayList&lt;&gt;(list)); } if (node.left != null) { dfs(node.left, sum - node.val, list); } if (node.right != null) { dfs(node.right, sum - node.val, list); } list.remove(list.size() - 1); }}","link":"/2019/04/12/113-path-sum-ii/"},{"title":"[LeetCode] 11. 盛最多水的容器","text":"题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 思路根据题意，构成容器的大小由长度和高度来确定。设定起始和结束的X轴索引为i和j, 长度则为 j - i, 而高度则由对应的两个高度中的较小的那个来确定。在遍历的时候，要从高度较小的那个向前或者向后进行计算，这样可以找到容易更大的值。 实现123456789101112131415161718class Solution { public int maxArea(int[] height) { int max = 0; int i = 0; int j = height.length - 1; while(j &gt; i) { int result = Math.min(height[i], height[j]) * (j - i); max = Math.max(max, result); if (height[i] &lt; height[j]) { i++; } else { j--; } } return max; }}","link":"/2019/03/01/11-container-with-most-water/"},{"title":"[LeetCode] 129. 求根到叶子节点数字之和","text":"题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:123456789输入: [1,2,3] 1 / \\ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2:123456789101112输入: [4,9,0,5,1] 4 / \\ 9 0 / \\5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 思路递归的解法比较容易想出来，记住当前层的和，依次递归调用下一层，递归时要判断下一层的节点个数， 只有左节点 递归左节点 只有右节点 递归右节点 包含左右节点 递归左右节点 左右都为空 则将记录的和加到全局sum中 实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int sum = 0; public int sumNumbers(TreeNode root) { if (root == null) { return sum; } sum(root, 0); return sum; } private void sum(TreeNode node, int count) { count = count * 10 + node.val; if (node.left != null &amp;&amp; node.right == null) { sum(node.left, count); } else if (node.right != null &amp;&amp; node.left == null) { sum(node.right, count); } else if (node.left != null &amp;&amp; node.right != null) { sum(node.left, count); sum(node.right, count); } else if (node.left == null &amp;&amp; node.right == null) { //count = count * 10 + node.val; sum += count; } }}","link":"/2019/04/15/129-sum-root-to-leaf-numbers/"},{"title":"[LeetCode] 114. 二叉树展开为链表","text":"题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树12345 1 / \\ 2 5 / \\ \\3 4 6 将其展开为：12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 思路前序遍历整个二叉树，按照遍历的顺序依次设置为前子树的右子树，而且左子树要置为空。这里还要使用一个 dummy 节点来记录下。 实现1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public void flatten(TreeNode root) { if (root == null) { return; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode dummy = new TreeNode(-1); stack.push(root); TreeNode curr = dummy; while(!stack.isEmpty()) { TreeNode node = stack.pop(); curr.right = node; curr.left = null; curr = node; if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } }}","link":"/2019/04/12/114-flatten-binary-tree-to-linked-list/"},{"title":"[LeetCode] 13. 罗马数字转整数","text":"题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:12输入: &quot;III&quot;输出: 3 示例 2:12输入: &quot;IV&quot;输出: 4 示例 3:12输入: &quot;IX&quot;输出: 9 示例 4:123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 思路 将字符和对应的值以键值对形式存入HashMap中 将罗马数字转换为字符数组，从后向前遍历。 如果后面的值较大，则应该减去当前遍历的字符对应的值 实现12345678910111213141516171819202122232425class Solution { public int romanToInt(String s) { HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); char[] chars = s.toCharArray(); int length = chars.length; int result = 0; int pre = 0; int flag = 1; for (int i = length - 1; i &gt;= 0; i--) { int value = map.get(chars[i]); pre = i &lt; length - 1 ? map.get(chars[i + 1]) : 0; flag = value &gt;= pre ? 1 : -1; result += (value * flag); } return result; }}","link":"/2019/04/01/13-roman-to-integer/"},{"title":"[LeetCode] 144. 二叉树的前序遍历","text":"题目描述给定一个二叉树，返回它的 前序 遍历。 示例:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路递归解法和非递归解法 非递归可以使用向先进后出的数据结构，如栈和双向队列。 实现递归解法12345678910public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null){ return list; } list.add(root.val); list.addAll(preorderTraversal(root.left)); list.addAll(preorderTraversal(root.right)); return list;} 非递归，使用栈12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode curr = root; if (curr != null) { stack.push(curr); } while(!stack.isEmpty()) { TreeNode node = stack.pop(); list.add(node.val); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return list; }}","link":"/2019/04/13/144-binary-tree-preorder-traversal/"},{"title":"[LeetCode] 145. 二叉树的后序遍历","text":"题目描述给定一个二叉树，返回它的 后序 遍历。 示例: 123456789输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路二叉树的后序遍历是 left -&gt; right -&gt; root 递归简单而且容易想出来 迭代算法可以使用栈来辅助，先将左节点入栈，后右节点。 实现递归解法：123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if (root == null) { return list; } postorderTraversal(root.left); postorderTraversal(root.right); list.add(root.val); return list; }} 迭代解法12345678910111213141516171819class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) { return list; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) { TreeNode node = stack.pop(); if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); list.add(0, node.val); // 逆序添加节点值 } return list; }}","link":"/2019/03/30/145-binary-tree-preorder-traversal/"},{"title":"[LeetCode] 19. 删除链表的倒数第N个节点","text":"题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路双指针的思路，前面快的指针比慢指针先走n步，然后两个指针一起向后移动，直到快指针到达最后一个，这时慢指针指向的就是倒数第n个节点。 实现12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; for(int i = 1; i &lt;= n + 1; i++) { first = first.next; } while(first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; }}","link":"/2019/04/02/19-remove-nth-node-from-end-of-list/"},{"title":"[LeetCode] 199. 二叉树的右视图","text":"题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 思路考察二叉树的层次遍历，只记录每层最后一个元素即可。 实现123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { if (root == null) { return new ArrayList&lt;&gt;(); } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) { int size = queue.size(); while(size &gt; 0) { TreeNode node = queue.remove(); if (size == 1) { list.add(node.val); } if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } size -= 1; } } return list; }}","link":"/2019/04/22/199-binary-tree-right-side-view/"},{"title":"[LeetCode] 20. 有效的括号","text":"题目描述给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: &quot;()&quot;输出: true 示例 2:12输入: &quot;()[]{}&quot;输出: true 示例 3:12输入: &quot;(]&quot;输出: false 示例 4:12输入: &quot;([)]&quot;输出: false 示例 5:12输入: &quot;{[]}&quot;输出: true 思路通过栈作为中间数据结构来实现。通过比较栈顶的元素与遍历的元素是否是相同类型的括号来选择是入栈还是出栈。如果遍历结束，栈里也正好没有元素的时候，此字符串有效。 实现解法1. 1234567891011121314151617181920212223242526class Solution { public boolean isValid(String s) { if (s == null) { return false; } if (s.length() == 0) { return true; } Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char[] chars = s.toCharArray(); for(char ch : chars) { if (stack.size() == 0) { stack.push(ch); } else if (isSym(stack.peek(), ch)) { stack.pop(); } else { stack.push(ch); } } return stack.size() == 0; } private boolean isSym(char c1, char c2) { return (c1 == '(' &amp;&amp; c2 == ')') || (c1 == '[' &amp;&amp; c2 == ']') || (c1 == '{' &amp;&amp; c2 == '}'); }} 解法2来自官方解题 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { // Hash table that takes care of the mappings. private HashMap&lt;Character, Character&gt; mappings; // Initialize hash map with mappings. This simply makes the code easier to read. public Solution() { this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); this.mappings.put('}', '{'); this.mappings.put(']', '['); } public boolean isValid(String s) { // Initialize a stack to be used in the algorithm. Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // If the current character is a closing bracket. if (this.mappings.containsKey(c)) { // Get the top element of the stack. If the stack is empty, set a dummy value of '#' char topElement = stack.empty() ? '#' : stack.pop(); // If the mapping for this bracket doesn't match the stack's top element, return false. if (topElement != this.mappings.get(c)) { return false; } } else { // If it was an opening bracket, push to the stack. stack.push(c); } } // If the stack still contains elements, then it is an invalid expression. return stack.isEmpty(); }}","link":"/2019/04/02/20-valid-parentheses/"},{"title":"[LeetCode] 209. 长度最小的子数组","text":"题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例: 123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 思路这题的解法来源于评论区，像用滑窗来控制。 l 和 r 表示闭区间左右的索引, 初始值都为0 增加 sum 和 r 的值，直到 sum 接近 s (sum &gt;= s) 尝试增加 l, 缩小区间，确定是否仍满足 sum &gt;= s 记录过程中的最小区间值 实现1234567891011121314151617181920class Solution { public int minSubArrayLen(int s, int[] nums) { int l = 0, r = 0; //[i,j] int sum = 0; int min = nums.length + 1; for (r = 0; r &lt; nums.length; r++) { sum += nums[r]; while (sum - nums[l] &gt;= s &amp;&amp; l &lt;= r) { sum -= nums[l]; l += 1; } if (sum &gt;= s) { min = Math.min(min, r - l + 1); } } if (min == nums.length + 1) return 0; return min; }}","link":"/2019/03/31/209-minimum-size-subarray-sum/"},{"title":"[LeetCode] 21. 合并两个有序链表","text":"题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路新建一个头结点，判断好 l1 或者 l2 为空的情况即可。 实现1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode cur = temp; while(l1 != null &amp;&amp; l2 != null) { if (l1.val &lt;= l2.val) { cur.next = l1; cur = cur.next; l1 = l1.next; } else { cur.next = l2; cur = cur.next; l2 = l2.next; } } if (l1 != null) { cur.next = l1; } if (l2 != null) { cur.next = l2; } return temp.next; }}","link":"/2019/03/02/21-merge-two-sorted-lists/"},{"title":"[LeetCode] 215. 数组中的第K个最大元素","text":"题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1:12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2:12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 思路使用堆排序或者优先队列 使用堆排序时，构建堆结构，输出第K个数字。使用优先队列时： 维护一个默认的PriorityQueue，元素从小到大排列，要是弹出的话，先栈顶（小的） 这个queue的大小为k，最后栈顶（peek（））的就是结果 当queue的size比k小（基数据），或是当前的值比栈顶的元素大，进队列 当queueu的size比k大的时候，弹出元素，栈顶的元素（最小的） 实现优先队列： 1234567891011121314151617class Solution { public int findKthLargest(int[] nums, int k) { if (nums == null || nums.length == 0) { return -1; } PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { if (i &lt; k || nums[i] &gt; queue.peek()) { queue.offer(nums[i]); } if (queue.size() &gt; k) { queue.poll(); } } return queue.peek(); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public int findKthLargest(int[] nums, int k) { buildHeap(nums); sort(nums); int n = nums.length; return nums[n - k]; } private void buildHeap(int[] nums) { int lastNode = nums.length - 1; int parent = (lastNode - 1) / 2; for (int i = parent; i &gt;= 0; i--) { heapify(nums, nums.length, i); } } private void sort(int[] nums) { for(int i = nums.length - 1; i &gt;= 0; i--) { swap(nums, i, 0); heapify(nums, i, 0); } } private void heapify(int[] nums, int n, int i) { if (i &gt;= n) { return; } int c1 = 2 * i + 1; int c2 = 2 * i + 2; int max = i; if (c1 &lt; n &amp;&amp; nums[c1] &gt; nums[max]) { max = c1; } if (c2 &lt; n &amp;&amp; nums[c2] &gt; nums[max]) { max = c2; } if (max != i) { swap(nums, max, i); heapify(nums, n, max); } } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; }}","link":"/2019/04/21/215-kth-largest-element-in-an-array/"},{"title":"[LeetCode] 22. 括号生成","text":"题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为：1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路实现1234567891011121314151617181920class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); dfs(0, 0, \"\", list, n); return list; } private void dfs(int count1, int count2, String str, List&lt;String&gt; list, int n) { if (count1 &gt; n || count2 &gt;n) return; if (count1 == n &amp;&amp; count2 == n) { list.add(str); } else { if (count1 &gt;= count2) { String ans1 = new String(str); dfs(count1 + 1, count2, ans1+\"(\", list, n); dfs(count1, count2 + 1, ans1+\")\", list, n); } } }}","link":"/2019/03/02/22-generate-parentheses/"},{"title":"[LeetCode] 226. 翻转二叉树","text":"题目描述翻转一棵二叉树。 示例：1234567891011121314输入： 4 / \\ 2 7 / \\ / \\1 3 6 9输出： 4 / \\ 7 2 / \\ / \\9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 思路 递归的方式去翻转，交换左右子树 非递归的方式，使用队列或者栈 实现递归解法： 12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return root; } TreeNode node = root.left; root.left = root.right; root.right = node; invertTree(root.left); invertTree(root.right); return root; }} 非递归方式 12345678910111213141516171819202122class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return root; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!stack.isEmpty()) { TreeNode node = stack.remove(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } TreeNode temp = node.left; node.left = node.right; node.right = temp; } return root; }}","link":"/2019/04/10/226-invert-binary-tree/"},{"title":"[LeetCode] 23. 合并K个排序链表","text":"题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例:1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路遍历排序链表的数组，将节点依次放到优先队列中，记得在放入之前将next指针置空。 实现12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(new Comparator&lt;ListNode&gt;() { @Override public int compare(ListNode first, ListNode second) { return first.val - second.val; } }); for (ListNode node : lists) { ListNode curr = node; ListNode next; while(curr != null) { // curr.next需要置空，这里需要记录next节点，之后将其赋值给curr next = curr.next; curr.next = null; queue.offer(curr); curr = next; } } ListNode dummy = new ListNode(-1); ListNode temp = dummy; while(!queue.isEmpty()) { ListNode node = queue.poll(); temp.next = node; temp = node; } return dummy.next; }}","link":"/2019/03/28/23-merge-k-sorted-lists/"},{"title":"[LeetCode] 230. 二叉搜索树中第K小的元素","text":"题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1输出: 3 进阶： 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 思路中序遍历满足从小到大的顺序，因此，中序遍历到的第K个节点的值就是我们想要的结果。 实现12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int count = 0; int result = 0; public int kthSmallest(TreeNode root, int k) { travel(root, k); return result; } private void travel(TreeNode node, int k) { if (node == null) { return; } travel(node.left, k); count += 1; if (count == k) { result = node.val; return; } travel(node.right, k); }}","link":"/2019/05/02/230-kth-smallest-element-in-a-bst/"},{"title":"[LeetCode] 232. 用栈实现队列","text":"题目描述使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。示例:1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 思路使用两个栈来实现stack1 用来 push 元素，而 stack2 用来 pop()和peek()时使用。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MyQueue { Stack&lt;Integer&gt; stack1 = null; Stack&lt;Integer&gt; stack2 = null; /** Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { int value = 0; while(!stack1.isEmpty()) { stack2.push(stack1.peek()); stack1.pop(); } value = stack2.pop(); while(!stack2.isEmpty()) { stack1.push(stack2.peek()); stack2.pop(); } return value; } /** Get the front element. */ public int peek() { int value = 0; while (!stack1.empty()) { stack2.push(stack1.peek()); stack1.pop(); } value = (int)stack2.peek(); while (!stack2.empty()) { stack1.push(stack2.peek()); stack2.pop(); } return value; } /** Returns whether the queue is empty. */ public boolean empty() { return stack1.isEmpty(); }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/2019/04/19/232-implement-queue-using-stacks/"},{"title":"[LeetCode] 239. 滑动窗口最大值","text":"题目描述给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。 返回滑动窗口最大值。 示例:123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 注意： 你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。 进阶： 你能在线性时间复杂度内解决此题吗？ 思路双向队列保存当前窗口中最大的值的数组下标 双向队列中的数从大到小排序，新进来的数如果大于等于队列中的数，则将这些数弹出再添加。 实现12345678910111213141516171819202122232425class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums == null || nums.length == 0) { return new int[] {}; } LinkedList&lt;Integer&gt; list = new LinkedList(); int[] result = new int[nums.length - k + 1]; for (int i = 0; i &lt; nums.length; i++) { // 保证链表中对应的数是从大到小排列，如果前面的数字要小，则弹出 while(!list.isEmpty() &amp;&amp; nums[list.peekLast()] &lt;= nums[i]) { list.pollLast(); } list.addLast(i); // 检查链表头部的元素是否还有效（小于i - k），如果过期则删掉 if (list.peek() &lt;= i - k) { list.poll(); } // 保存窗口中的最大值 if (i - k + 1 &gt;= 0) { result[i - k + 1] = nums[list.peek()]; } } return result; }}","link":"/2019/04/29/239-sliding-window-maximum/"},{"title":"[LeetCode] 257. 二叉树的所有路径","text":"题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例:1234567891011输入: 1 / \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 思路递归方式去遍历所有可能的二叉树路径，遇到叶子结点时将路径字符串加入List中。 实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) { String path = new String(\"\"); dfs(root, path); return result; } private void dfs(TreeNode node, String path) { if (node == null) { return; } path += node.val; if (node.left == null &amp;&amp; node.right == null) { result.add(path); } path += \"-&gt;\"; if (node.left != null) { dfs(node.left, path); } if (node.right != null) { dfs(node.right, path); } }}","link":"/2019/04/12/257-binary-tree-paths/"},{"title":"[LeetCode] 260. 只出现一次的数字III","text":"题目描述给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 示例 :12输入: [1,2,1,3,2,5]输出: [3,5] 注意： 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？ 思路先全部异或一次, 得到的结果, 考察其的某个非0位(比如最高非0位), 那么只出现一次的两个数中, 在这个位上一个为0, 一个为1, 由此可以将数组中的元素分成两部分,重新遍历, 求两个异或值 实现12345678910111213141516171819class Solution { public int[] singleNumber(int[] nums) { int xor = 0; for (int num : nums) { xor ^= num; } int[] res = new int[2]; // 获取整数二进制表示中最右侧的1 int bigFlag = xor &amp; (-xor); for (int num : nums) { if ((bigFlag &amp; num) == 0) { res[0] ^= num; } else { res[1] ^= num; } } return res; }}","link":"/2019/04/18/260-single-number-iii/"},{"title":"[LeetCode] 28. 实现strStr()","text":"题目描述实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1:12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2:12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 思路KMP算法 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int strStr(String haystack, String needle) { if (needle.length() == 0) { return 0; } int length = haystack.length(); int plength = needle.length(); int[] next = getNext(needle); int i = 0, j = 0; while(i &lt; length &amp;&amp; j &lt; plength) { if (haystack.charAt(i) == needle.charAt(j)) { i += 1; j += 1; } else { if (j == 0) { i += 1; } else { j = next[j - 1]; } } } if (j == plength) { return i - j; } return -1; } private int[] getNext(String needle) { int[] next = new int[needle.length()]; int i = 0, j = 1; Arrays.fill(next, 0); while(j &lt; needle.length()) { if (needle.charAt(i) == needle.charAt(j)) { next[j] = i + 1; j += 1; i += 1; } else { if (i == 0) { j += 1; } else { i = next[i - 1]; } } } return next; }}","link":"/2019/04/05/28-implement-strstr/"},{"title":"[LeetCode] 292. Nim游戏","text":"题目描述你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 示例:1234输入: 4输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 思路如果先手时当前所剩石头数量为4，肯定会输。 同理，如果还剩5，6，7个时，可以拿1，2，3个，这样对方就剩4个，先手肯定会赢。但如果有8块，你没法控制到对方时只剩4个，因此会输掉。显然，它以相同的模式不断重复 n=4,8,12,16... 基本可以看出是 4 的倍数。 实现12345class Solution { public boolean canWinNim(int n) { return (n % 4 != 0); }}","link":"/2019/04/03/292-nim-game/"},{"title":"[LeetCode] 343. 整数拆分","text":"题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 思路1237 8 9 10 113*2*2 2*3*3 3*3*3 3*3*4 2*3*3*312 18 27 36 48 大致也发现了一点规律，如果一个数分解后可以写成全是2或全是3，那么全是3的乘积肯定比全是2的大。 比如6 = 2 + 2 + 2 = 3 + 3 肯定是 3*3 &gt; 2*2*2。 求函数y=(n/x)^x(x&gt;0)的最大值，可得x=e时y最大，但只能分解成整数，故x取2或3，由于6=2+2+2=3+3，显然2^3=8&lt;9=3^2,故应分解为多个3 实现123456789101112131415161718192021222324252627282930class Solution { public int integerBreak(int n) { if (n == 2) { return 1; } if (n == 3) { return 2; } int sum = 1; int count1 = 0; //3 int count2 = 0; // 4 int temp = n; while(temp != 0) { if (temp % 3 == 0) { count1 = temp / 3; break; } temp -= 2; count2 += 1; } for (int i = 0; i &lt; count1; i++) { sum *= 3; } for (int i = 0; i &lt; count2; i++) { sum *= 2; } return sum; }}","link":"/2019/04/04/343-integer-break/"},{"title":"[LeetCode] 345. 反转字符串中的元音字母","text":"题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:12输入: &quot;hello&quot;输出: &quot;holle&quot; 示例 2:12输入: &quot;leetcode&quot;输出: &quot;leotcede&quot; 说明:元音字母不包含字母”y”。 思路双指针分别从开始和结束索引记录元音字母的位置，依次进行调换 实现123456789101112131415161718192021222324252627282930class Solution { public String reverseVowels(String s) { if (s.length() == 0) { return s; } String vowels = \"aeiouAEIOU\"; char[] chars = s.toCharArray(); int start = 0, end = s.length() - 1; while(start &lt; end) { if (vowels.indexOf(s.charAt(start)) != -1 &amp;&amp; vowels.indexOf(s.charAt(end)) != -1) { char temp = s.charAt(end); chars[end] = chars[start]; chars[start] = temp; findStart = false; findEnd = false; start += 1; end -= 1; } else if (vowels.indexOf(s.charAt(start)) == -1) { start += 1; } else if (vowels.indexOf(s.charAt(end)) == -1) { end -= 1; } else { start += 1; end -= 1; } } return new String(chars); }}","link":"/2019/04/18/345-reverse-vowels-of-a-string/"},{"title":"[LeetCode] 347. 前K个高频元素","text":"题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2:12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 思路这一题直接使用了Java中的优先队列，根据在哈希表中记录的元素个数来进行排序。 实现123456789101112131415161718192021222324252627282930class Solution { public List&lt;Integer&gt; topKFrequent(int[] nums, int k) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) { int count = map.getOrDefault(num, 0); map.put(num, count + 1); } PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer first, Integer second) { return map.get(first) - map.get(second); } }); for (int key : map.keySet()) { if (queue.size() &lt; k) { queue.offer(key); } else if (map.get(key) &gt; map.get(queue.peek())) { queue.poll(); queue.offer(key); } } while(!queue.isEmpty()) { list.add(0, queue.poll()); } return list; }}","link":"/2019/04/28/347-top-k-frequent-elements/"},{"title":"[LeetCode] 373. 查找和最小的K对数字","text":"题目描述给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。 找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。 示例 1:1234输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3输出: [1,2],[1,4],[1,6]解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 示例 2:1234输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2输出: [1,1],[1,1]解释: 返回序列中的前 2 对数： [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3:123输入: nums1 = [1,2], nums2 = [3], k = 3 输出: [1,3],[2,3]解释: 也可能序列中所有的数对都被返回:[1,3],[2,3] 思路优先队列存储数值的数组，comparator中比较数值对的大小进行排序。 实现123456789101112131415161718192021222324252627class Solution { public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) { PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { return o2[0] + o2[1] - o1[0] - o1[1]; } }); for (int i = 0; i &lt; nums1.length; i++) { for (int j = 0; j &lt; nums2.length; j++) { int[] pair = new int[]{nums1[i], nums2[j]}; if (queue.size() &lt; k) { queue.offer(pair); } else if (pair[0] + pair[1] &lt; queue.peek()[0] + queue.peek()[1]) { // 如果当前pair的和比队列中最大的数值对还要小，则插入 queue.poll(); queue.offer(pair); } } } ArrayList&lt;int[]&gt; list = new ArrayList&lt;&gt;(); while(!queue.isEmpty()) { // 优先队列中的顺序是从大到小 list.add(0, queue.poll()); } return list; }}","link":"/2019/04/30/373-find-k-pairs-with-smallest-sums/"},{"title":"[LeetCode] 378. 有序矩阵中第K小的元素","text":"题目描述给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。请注意，它是排序后的第k小元素，而不是第k个元素。 示例:123456matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8, 返回 13。 说明:你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。 思路使用一个大小为K的优先队列，定义comparator使其为最大堆，优先队列不到k长度时依次添加。当队列中元素已经充满，则判断对头元素是否大于当前元素，如果当前元素较小，则将队头元素弹出，将当前元素加入到队列中。 实现123456789101112131415161718192021222324class Solution { public int kthSmallest(int[][] matrix, int k) { PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(k, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); for (int i = 0; i &lt; matrix.length; i++) { int[] data = matrix[i]; for (int j = 0; j &lt; data.length; j++) { if (queue.size() &lt; k) { queue.offer(data[j]); } else if (queue.peek() &gt; data[j]) { queue.poll(); queue.offer(data[j]); } } } return queue.peek(); }}","link":"/2019/04/28/378-kth-smallest-element-in-a-sorted-matrix/"},{"title":"[LeetCode] 387. 字符串中的第一个唯一字符","text":"题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例:12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 思路首先想到的是用哈希表来记录字符出现的次数，需要遍历两次。不借助哈希表的话，通过把字符串减去’a’就可以得到唯一的数组下标，用这个下标去区分26个字母就可以。下面解法通过判断indexOf和lastIndexOf返回的index是否相同就可以得出结果 实现1234567891011121314class Solution { public int firstUniqChar(String s) { int[] arr = new int[26]; //26个字母 for (int i = 0; i &lt; s.length(); i++) { arr[s.charAt(i) - 'a']++; } for (int i = 0; i &lt; s.length(); i++) { if (arr[s.charAt(i) - 'a'] == 1) { return i; } } return -1; }} 12345678910class Solution { public int firstUniqChar(String s) { for(int i = 0; i &lt; s.length(); i++) { if (s.indexOf(s.charAt(i)) == s.lastIndexOf(s.charAt(i))) { return i; } } return -1; }}","link":"/2019/04/13/387-first-unique-character-in-a-string/"},{"title":"[LeetCode] 437. 路径总和III","text":"题目描述给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例：123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路双重递归首先先序递归遍历每个节点，再以每个节点作为起始点递归寻找满足条件的路径。 实现12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int count = 0; public int pathSum(TreeNode root, int sum) { if (root == null) { return 0; } sum(root, sum); pathSum(root.left, sum); pathSum(root.right, sum); return count; } private void sum(TreeNode node, int sum) { if (node == null) return; sum -= node.val; if (sum == 0) { count += 1; } sum(node.left, sum); sum(node.right, sum); }}","link":"/2019/04/12/437-path-sum-iii/"},{"title":"[LeetCode] 451. 根据字符出现频率排序","text":"题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1:123456789输入:&quot;tree&quot;输出:&quot;eert&quot;解释:&apos;e&apos;出现两次，&apos;r&apos;和&apos;t&apos;都只出现一次。因此&apos;e&apos;必须出现在&apos;r&apos;和&apos;t&apos;之前。此外，&quot;eetr&quot;也是一个有效的答案。 示例 2:123456789输入:&quot;cccaaa&quot;输出:&quot;cccaaa&quot;解释:&apos;c&apos;和&apos;a&apos;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。 示例 3:123456789输入:&quot;Aabb&quot;输出:&quot;bbAa&quot;解释:此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&apos;A&apos;和&apos;a&apos;被认为是两种不同的字符。 思路堆排序，还是要根据字符出现的次数来建堆，刚开始想成把所有出现包括重复的一起建堆，提交了好几次发现还是需要只根据次数把有效的字符建堆即可。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution { Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); StringBuilder sb = new StringBuilder(\"\"); public String frequencySort(String s) { if (s.length() == 0) { return sb.toString(); } char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { int count = map.getOrDefault(chars[i], 0); map.put(chars[i], count + 1); } char[] newChars = new char[map.size()]; int index = 0; for (Character key : map.keySet()) { newChars[index] = key; index += 1; } buildHeap(newChars, newChars.length); sort(newChars, newChars.length); return sb.toString(); } private void buildHeap(char[] chars, int n) { int lastNode = n - 1; int parent = (lastNode - 1) / 2; for (int i = parent; i &gt;= 0; i--) { heapify(chars, n, i); } } private void heapify(char[] chars, int n, int i) { if (i &gt;= n) { return; } int max = i; int c1 = 2 * i + 1; int c2 = 2 * i + 2; if (c1 &lt; n) { if (map.get(chars[c1]) == map.get(chars[max])) { max = chars[c1] - chars[max] &gt; 0 ? c1 : max; } else if (map.get(chars[c1]) &gt; map.get(chars[max])) { max = c1; } } if (c2 &lt; n) { if (map.get(chars[c2]) == map.get(chars[max])) { max = chars[c2] - chars[max] &gt; 0 ? c2 : max; } else if (map.get(chars[c2]) &gt; map.get(chars[max])) { max = c2; } } if (max != i) { swap(chars, max, i); heapify(chars, n, max); } } private void sort(char[] chars, int n) { for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; map.get(chars[0]); j++) { sb.append(chars[0]); } swap(chars, i, 0); heapify(chars, i, 0); } } private void swap(char[] chars, int i, int j) { char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; }}","link":"/2019/04/22/451-sort-characters-by-frequency/"},{"title":"[LeetCode] 461. 汉明距离","text":"题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例:12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 思路实现1234567891011class Solution { public int hammingDistance(int x, int y) { int n = x ^ y,distance = 0; for(int i = 0; i &lt; 32; i++) { if((n &amp; (1 &lt;&lt; i - 1)) != 0) { distance++; } } return distance; }}","link":"/2019/04/09/461-hamming-distance/"},{"title":"[LeetCode] 496. 下一个更大的元素","text":"题目描述给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。 示例 1:123456输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2:12345输入: nums1 = [2,4], nums2 = [1,2,3,4].输出: [3,-1]解释: 对于num1中的数字2，第二个数组中的下一个较大数字是3。 对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。 注意: nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 思路 先遍历数组nums2, 首先将第一个元素入栈。 继续遍历，当当前元素小于栈顶元素时，继续将它入栈。当前元素大于栈顶元素时，此时找到第一个比栈顶元素大的元素，栈顶元素出栈，并和当前元素组成key-value键值对，存入HashMap中。接着当前元素入栈。 遍历完nums2之后，就得到了元素对应第一个大的hash表。 遍历nums1并查询HashMap中结果，查询不到则返回-1。 实现1234567891011121314151617class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums2.length; i++) { while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) { map.put(stack.pop(), nums2[i]); } stack.push(nums2[i]); } int[] result = new int[nums1.length]; for (int i = 0; i &lt; nums1.length; i++) { result[i] = map.getOrDefault(nums1[i], -1); } return result; }}","link":"/2019/04/10/496-next-greater-element-i/"},{"title":"[LeetCode] 521. 最长特殊序列I","text":"题目描述给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 示例 :123输入: &quot;aba&quot;, &quot;cdc&quot;输出: 3解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;) 说明: 两个字符串长度均小于100。 字符串中的字符仅含有 ‘a’~’z’。 思路一个字符串的最长子序列是其自身，分析： 1. 若 s 与 t 相同， 则不存在特殊序列，返回 -1。 2。若 s 与 t 不同，长度更长的字符串不能作为长度更小的字符串的子序列，长度相等时也同理，故特殊序列为长度最大的字符串，返回 s 和 t 之间的最大长度即为答案。 实现1234567class Solution { public int findLUSlength(String a, String b) { if(a.equals(b)) return -1; return a.length()&gt;b.length()?a.length():b.length(); }}","link":"/2019/04/18/521-longest-uncommon-subsequence-i/"},{"title":"[LeetCode] 513. 找树左下角的值","text":"题目描述给定一个二叉树，在树的最后一行找到最左边的值。 示例 1:12345678输入: 2 / \\ 1 3输出:1 示例 2:123456789101112输入: 1 / \\ 2 3 / / \\ 4 5 6 / 7输出:7 思路层序遍历二叉树的每一层，记录每层第一个元素，返回最后一层的元素即可。 实现12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int findBottomLeftValue(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode result = root; // 保存每层最左边的元素 while(!queue.isEmpty()) { int size = queue.size(); int tempSize = size; while(tempSize &gt; 0) { TreeNode node = queue.remove(); if (tempSize == size) { result = node; } if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } tempSize -= 1; } } return result.val; }}","link":"/2019/04/08/513-find-bottom-left-tree-value/"},{"title":"[LeetCode] 535. TinyURL的加密与解密","text":"题目描述TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk. 要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。 思路评论区看来的1tinyurl 格式： http://tinyurl.com/ + 6位随机码(4e9iAK) 使用哈希表map, 加密的时候生成随机 tinyurl, 若 tinyurl 在 map中不存在, 则以 tinyurl 作为 key, url 作为value; 解密时, 通过 tinyurl 作为 key, 即可找到作为 value 的 url. 实现1234567891011121314151617181920212223242526272829public class Codec { Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); static final String INDEX = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"; static final String TINYURL_PREFIX = \"http://tinyurl.com/\"; // Encodes a URL to a shortened URL. public String encode(String longUrl) { char[] chs = new char[6]; while(true) { for (int i = 0; i &lt; 6; i++) { chs[i] = INDEX.charAt((int)(Math.random() * 62)); } String shortUrl = TINYURL_PREFIX + new String(chs); if (!map.containsKey(shortUrl)) { map.put(shortUrl, longUrl); return shortUrl; } } } // Decodes a shortened URL to its original URL. public String decode(String shortUrl) { return map.get(shortUrl); }}// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(url));","link":"/2019/03/10/535-encode-and-decode-tinyurl/"},{"title":"[LeetCode] 540. 有序数组中的单一元素","text":"题目描述给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1:12输入: [1,1,2,3,3,4,4,8,8]输出: 2 示例 2:12输入: [3,3,7,7,10,11,11]输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。 思路利用异或运算的特点，最后的结果即是只出现一次的元素。 实现123456789class Solution { public int singleNonDuplicate(int[] nums) { int result = 0; for (int num : nums) { result ^= num; } return result; }}","link":"/2019/04/18/540-single-element-in-a-sorted-array/"},{"title":"[LeetCode] 551. 学生出勤记录I","text":"题目描述给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： ‘A’ : Absent，缺勤 ‘L’ : Late，迟到 ‘P’ : Present，到场如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤记录判断他是否会被奖赏。 示例 1:12输入: &quot;PPALLP&quot;输出: True 示例 2:12输入: &quot;PPALLL&quot;输出: False 思路这题不难，主要看清题中的要求， 不超过一个A, 并且不超过两个连续的L 实现1234567891011121314151617181920212223class Solution { public boolean checkRecord(String s) { char[] chars = s.toCharArray(); int count1 = 0; // A int count2 = 0; // L for(int i = 0; i &lt; s.length(); i++) { if (chars[i] == 'L') { count2 += 1; } else { if (chars[i] == 'A') { count1 += 1; } if (count2 &lt;= 2) { count2 = 0; } } } if (count1 &lt;= 1 &amp;&amp; count2 &lt;= 2) { return true; } return false; }}","link":"/2019/04/05/551-student-attendance-record-i/"},{"title":"[LeetCode] 561. 数组拆分I","text":"题目描述给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1:1234输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000].数组中的元素范围在 [-10000, 10000]. 思路这道题的关键就是谁与谁组队相比较的问题，由于求最大的值，所以我们要尽可能的保留大的值，假如按照最大+最小，第二大+第二小，就会直接把最大和第二大的数舍去了，如果最大与第二大组队就可以保留第二大的数字，以此类推，我们只需要排序之后，相邻之间组队就可以留下最大的值 实现1234567891011class Solution { public int arrayPairSum(int[] nums) { Arrays.sort(nums); int sum = 0; for(int i = 0; i &lt; nums.length; ) { sum += nums[i]; i += 2; } return sum; }}","link":"/2019/04/03/561-array-partition-i/"},{"title":"[LeetCode] 58. 最后一个单词的长度","text":"题目描述给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: &quot;Hello World&quot;输出: 5 思路主要理解题意就可以，然后列出一些可能的case，这题就很简单了。123456&quot;Hello World&quot;&quot; &quot;&quot; Hello&quot;&quot; Hello &quot;&quot;Hello &quot;&quot;Hello world &quot; 实现1234567891011121314151617181920class Solution { public int lengthOfLastWord(String s) { s = s.trim(); if (s.isEmpty()) { return 0; } char[] chars = s.toCharArray(); int count = 0; for (int i = 0; i &lt; chars.length; i++) { if (chars[i] != ' ') { count += 1; } else { if (count &gt; 0) { count = 0; } } } return count; }}","link":"/2019/04/13/58-length-of-last-word/"},{"title":"[LeetCode] 657. 机器人能否返回原点","text":"题目描述在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 示例 1:123输入: &quot;UD&quot;输出: true解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例 2:123输入: &quot;LL&quot;输出: false解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 思路分别计算在 X 轴和 Y 轴的移动距离，如果最后都为0的话，机器人可以返回原点。 实现123456789101112131415161718192021222324252627282930313233class Solution { public boolean judgeCircle(String moves) { if (moves.length() % 2 != 0) { return false; } // 左右 int x = 0; // 上下 int y = 0; for (int i = 0; i &lt; moves.length(); i++) { char move = moves.charAt(i); switch(move) { case 'L': x -= 1; break; case 'R': x += 1; break; case 'U': y += 1; break; case 'D': y -= 1; break; } } if (x == 0 &amp;&amp; y == 0) { return true; } return false; }}","link":"/2019/04/02/657-robot-return-to-origin/"},{"title":"[LeetCode] 66. 加一","text":"题目描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 思路通过数组表示给定的整数，我们需要在个位+1，然后反位+1后的整数，过程中可能有进位。因为直接转成整数有溢出的风险，因此我们只能遍历数组进行计算。 实现1234567891011121314151617181920212223242526class Solution { public int[] plusOne(int[] digits) { int count = digits.length; boolean flag = false; for (int i = count - 1; i &gt;= 0; i--) { int digit = digits[i]; if (i == count - 1 || flag) { digit += 1; } if (digit &gt;= 10) { digits[i] = digit % 10; flag = true; } else { digits[i] = digit; flag = false; } } if (flag) { // 最高位有进位 int[] copy = new int[count + 1]; copy[0] = 1; System.arraycopy(digits, 0, copy, 1, count); return copy; } return digits; }}","link":"/2019/03/30/66-plus-one/"},{"title":"[LeetCode] 692. 前K个高频单词","text":"题目描述给一非空的单词列表，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 示例 1：1234输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2输出: [&quot;i&quot;, &quot;love&quot;]解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。 注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。 示例 2：1234输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词， 出现次数依次为 4, 3, 2 和 1 次。 注意： 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。 输入的单词均由小写字母组成。 扩展练习： 尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。 思路通过哈希表计算数组中元素的个数，然后根据哈希表中的元素和对应的个数建堆。在建堆的过程中，除了考虑个数不同的情况，还要考虑个数相同的情况（比较String的大小），因为本题要求如果不同的单词有相同出现频率，按字母顺序排序。。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution { HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; topKFrequent(String[] words, int k) { for (int i = 0; i &lt; words.length; i++) { int count = map.getOrDefault(words[i], 0); map.put(words[i], count + 1); } String[] tree = new String[map.size()]; int index = 0; for (String key : map.keySet()) { tree[index] = key; index += 1; } buildHeap(tree, tree.length); sort(tree, tree.length, k); return result; } private void buildHeap(String[] words, int n) { int lastNode = n - 1; int parent = (lastNode - 1) / 2; for (int i = parent; i &gt;= 0; i--) { heapify(words, n, i); } } private void heapify(String[] words, int n, int i) { if (i &gt;= n) { return; } int c1 = 2 * i + 1; int c2 = 2 * i + 2; int max = i; if (c1 &lt; n) { if (map.get(words[max]) &lt; map.get(words[c1])) { max = c1; } else if (map.get(words[max]) == map.get(words[c1])) { max = words[max].compareTo(words[c1]) &lt; 0 ? max : c1; } } if (c2 &lt; n) { if (map.get(words[max]) &lt; map.get(words[c2])) { max = c2; } else if (map.get(words[max]) == map.get(words[c2])) { max = words[max].compareTo(words[c2]) &lt; 0 ? max : c2; } } if (max != i) { swap(words, max, i); heapify(words, n, max); } } private void sort(String[] words, int n, int k) { for (int i = n - 1; i &gt;= 0; i--) { if (result.size() &lt; k) { result.add(words[0]); } swap(words, i, 0); heapify(words, i, 0); } } private void swap(String[] words, int i, int j) { String temp = words[i]; words[i] = words[j]; words[j] = temp; }}","link":"/2019/04/22/692-top-k-frequent-words/"},{"title":"[LeetCode] 700. 二叉搜索树中的搜索","text":"题目描述给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如，123456789给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3和值: 2 你应该返回如下子树:123 2 / \\ 1 3 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。 思路根据二叉搜索树的性质，给定的值大于当前节点值时搜索右节点，小于的时候搜索左节点就可以，最后返回搜索到的节点。 实现12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } TreeNode temp = root; while(temp != null &amp;&amp; temp.val != val) { if (temp.val &gt; val) { temp = temp.left; } else if (temp.val &lt; val) { temp = temp.right; } } return temp; }}","link":"/2019/04/03/700-search-in-a-binary-search-tree/"},{"title":"[LeetCode] 703. 数据流中的第K大元素","text":"题目描述设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。 你的 KthLargest 类需要一个同时接收整数 k 和整数数组 nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。 示例:12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 说明:你可以假设 nums 的长度≥ k-1 且k ≥ 1。 思路实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class KthLargest { private int k; private int[] arr; private int n; public KthLargest(int k, int[] nums) { this.k = k; this.arr = new int[k]; for (int i = 0; i &lt; k &amp;&amp; i &lt; nums.length; i++) { arr[i] = nums[i]; } n = Math.min(k, nums.length); for (int i = n / 2 - 1; i &gt;= 0; i--) { shiftDown(arr, i, n); } for (int i = k; i &lt; nums.length; i++) { if (nums[i] &gt; arr[0]) { arr[0] = nums[i]; shiftDown(arr, 0, k); } } } public int add(int val) { // heap array is not fill full if (n &lt; k) { arr[n] = val; // insert end of this array //shift up from parent node shiftUp(arr, n); n++; return arr[0]; } // val greater that the min value of heap array if (val &gt; arr[0]) { arr[0] = val; // insert value at first index, so shift down shiftDown(arr, 0, k); } return arr[0]; } public void shiftUp(int[] array, int i) { int parentIndex = (i - 1) / 2; while (parentIndex &gt;= 0 &amp;&amp; array[i] &lt; array[parentIndex]) { swap(array, i, parentIndex); i = parentIndex; } } public void shiftDown(int[] arry, int i, int n) { while (2 * i + 1 &lt; n) { // left child index int j = 2 * i + 1; // find the larger child index if (j + 1 &lt; n &amp;&amp; arry[j] &gt; arry[j + 1]) { j += 1; } // no need to heapify if (arry[i] &lt; arry[j]) { break; } // swap parent with child swap(arry, i, j); // continue shift down this node i = j; } } public void swap(int[] arry, int i, int j) { int temp = arry[i]; arry[i] = arry[j]; arry[j] = temp; }}/** * Your KthLargest object will be instantiated and called as such: KthLargest * obj = new KthLargest(k, nums); int param_1 = obj.add(val); */ 123456789101112131415161718192021222324252627282930class KthLargest { private PriorityQueue&lt;Integer&gt; queue; private int k = 0; public KthLargest(int k, int[] nums) { queue = new PriorityQueue(k); this.k = k; for (int i = 0; i &lt; nums.length; i++) { add(nums[i]); } } public int add(int val) { if (queue.size() &lt; k) { queue.offer(val); } else { if (queue.peek() &lt; val) { queue.poll(); queue.offer(val); } } return queue.peek(); }}/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","link":"/2019/04/24/703-kth-largest-element-in-a-stream/"},{"title":"[LeetCode] 806. 写字符串需要的行数","text":"题目描述我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 ‘a’ 需要的单位， widths[1] 代表 ‘b’ 需要的单位，…， widths[25] 代表 ‘z’ 需要的单位。 现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。 示例 1:1234567输入: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;abcdefghijklmnopqrstuvwxyz&quot;输出: [3, 60]解释: 所有的字符拥有相同的占用单位10。所以书写所有的26个字母，我们需要2个整行和占用60个单位的一行。 示例 2:12345678输入: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;bbbcccdddaaa&quot;输出: [2, 4]解释: 除去字母&apos;a&apos;所有的字符都是相同的单位10，并且字符串 &quot;bbbcccdddaa&quot; 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.最后一个字母 &apos;a&apos; 将会被写到第二行，因为第一行只剩下2个单位了。所以，这个答案是2行，第二行有4个单位宽度。 注: 字符串 S 的长度在 [1, 1000] 的范围。 S 只包含小写字母。 widths 是长度为 26的数组。 widths[i] 值的范围在 [2, 10]。 思路遍历字符串中字符，找到长度数组中对应的长度。依次累加所需要的长度，大于100时行数加1，这里需要注意示例2中的case，最后一个a在第一行不够显式，所以需要在第二行占用4个单位。 实现12345678910111213141516class Solution { public int[] numberOfLines(int[] widths, String S) { int[] result = {1, 0}; int sum = 0; for (int i = 0;i &lt; S.length(); i++) { sum += widths[S.charAt(i) - 97]; if (sum &gt; 100) { result[0]++; sum = 0; i--; } } result[1] = sum; return result; }}","link":"/2019/04/09/806-number-of-lines-to-write-string/"},{"title":"[LeetCode] 961. 重复N次的元素","text":"题目描述在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1：12输入：[1,2,3,3]输出：3 示例 2：12输入：[2,1,2,5,3,2]输出：2 示例 3：12输入：[5,1,5,2,5,3,5,4]输出：5 提示： 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length 为偶数 思路刚开始的思路是用HashMap记录元素出现的次数。但要注意这题的条件是大小 2N 的数组有 N+1 个不同的元素，因此数组中必定存在相邻并相等或者分隔相等的情形。 实现1234567891011class Solution { public int repeatedNTimes(int[] A) { for (int i = 0; i &lt; A.length - 2; i++) { if (A[i] == A[i + 1] || A[i] == A[i + 2]) { return A[i]; } } return A[A.length - 1]; }}","link":"/2019/04/10/961-n-repeated-element-in-size-2n-array/"},{"title":"[LeetCode] 965. 单值二叉树","text":"题目描述如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 只有给定的树是单值二叉树时，才返回 true；否则返回 false。示例 1：12输入：[1,1,1,1,1,null,1]输出：true 示例 2： 12输入：[2,2,2,5,2]输出：false 提示： 给定树的节点数范围是 [1, 100]。 每个节点的值都是整数，范围为 [0, 99] 。 思路遍历二叉树查看是否有不同的节点值即可。 实现12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isUnivalTree(TreeNode root) { if (root == null) { return true; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) { TreeNode node = queue.remove(); if (node.val != root.val) { return false; } if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } return true; }}","link":"/2019/03/20/965-univalued-binary-tree/"},{"title":"[LeetCode] 973. 最接近原点的K个点","text":"题目描述我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。 示例 1：1234567输入：points = [[1,3],[-2,2]], K = 1输出：[[-2,2]]解释： (1, 3) 和原点之间的距离为 sqrt(10)，(-2, 2) 和原点之间的距离为 sqrt(8)，由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。 示例 2：123输入：points = [[3,3],[5,-1],[-2,4]], K = 2输出：[[3,3],[-2,4]]（答案 [[-2,4],[3,3]] 也会被接受。） 提示： 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 思路使用优先队列，在Pair类型中保存点和对应的距离，重写优先队列的比较函数，比较Pair中保存的距离即可。 实现1234567891011121314151617181920212223242526272829303132333435class Solution { public int[][] kClosest(int[][] points, int K) { PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Pair&gt;() { @Override public int compare(Pair o1, Pair o2) { return o1.distance - o2.distance; } }); for (int i = 0; i &lt; points.length; i++) { queue.add(new Pair(points[i], getDistance(points[i]))); } int[][] result = new int[K][2]; for (int i = 0; i &lt; K; i++) { result[i] = queue.poll().data; } return result; } private int getDistance(int[] point) { return point[0] * point[0] + point[1] * point[1]; } private class Pair { int[] data; int distance; public Pair(int[] data, int distance) { this.data = data; this.distance = distance; } }}","link":"/2019/04/28/973-k-closest-points-to-origin/"},{"title":"[LeetCode] 98. 验证二叉搜索树","text":"题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 1234567输入: 2 / \\ 1 3输出: true 示例 2: 1234567891011输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 思路根据二叉搜索树的特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 其中序遍历的结果是一个递增序列。所以我们可以中序遍历二叉树，判断其是否为递增序列就可以了。 实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isValidBST(TreeNode root) { if (root == null) { return true; } // 测试用例有Integer.MIN_VALUE检查 long minValue = Long.MIN_VALUE; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode curr = root; while(curr != null || !stack.isEmpty()) { if (curr != null) { stack.push(curr); curr = curr.left; } else { TreeNode node = stack.remove(); if (node.val &lt;= minValue) { return false; } minValue = node.val; curr = node.right; } } return true; }}","link":"/2019/03/30/98-validate-binary-search-tree/"},{"title":"Swift的派发机制","text":"函数派发就是程序判断使用哪种途径去调用一个函数的机制。了解派发机制对于写出高性能代码来说很有必要，而且也能解释很多Swift里”奇怪”的行为。 编译型语言有三种基础的函数派发方式： 直接派发 Direct Dispatch 函数表派发 Table Dispatch 消息机制派发 Message Dispatch 大多数语言都会支持一到两种，Java默认使用函数表派发，但你可以通过final修饰符修改成直接派发。 C++ 默认使用直接派发，但可以加上virtual修饰符来改成函数表派发。而 Objective-C 则总是使用消息机制派发，但允许开发者使用C直接派发来获取性能的提高。这样的方式非常好，但也给很多开发者带来了困扰。 1. 派发方式程序派发的目的是为了告诉 CPU 需要被调用的函数在哪里，在我们深入 Swift 派发机制之前，先来了解一下这三种派发方式，以及每种方式在动态性和性能之间的取舍。 直接派发直接派发是最快的，由编译器来决定调用的函数，并且编译器还能够有很大的优化空间，例如函数内联等。直接派发也被称为静态调用。 然而，对于编程来说直接调用也是最大的局限，而且因为缺乏动态性所有没办法支持继承。 函数表派发函数表派发是编译型语言实现动态行为最常见的实现形式。函数表使用了一个数组来存储声明的每一个函数的指针。大部分语言把这个称为virtual table(虚函数表)， Swift 里称为 witness table.每一个类都会维护一个函数表，里面记录着类所有的函数。如果父类函数被override的话，表里面只会保存被override之后的函数。一个子类新添加的函数，都会被插入到这个数组的最后。运行时会根据这一个表去决定实际要被调用的函数。 查表是一种简单，易实现，而且性能可预知的方式。然而，这种派发方式比起直接派发还是慢一点。从字节码角度来看，多了两次读和一次跳转，由此带来了性能的损耗。另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化。 函数表基于数组实现，缺点在于函数表无法拓展。子类会在虚函数表的最后插入新的函数，但没有位置可以让 extension 安全地插入函数。 消息机制派发消息机制是调用函数最动态的方式。这种运作方式的关键在于开发者可以在运行时改变函数的行为，不止可以通过swizzling来改变，甚至可以用isa-swizzling修改对象的继承关系，可以在面向对象的基础上实现自定义派发。 当一个消息被派发，运行时会顺着类的继承关系向上查找应该被调用的函数。如果你觉得这样做效率很低，它确实很低。然而，只要缓存建立了起来，这个查找过程就会通过缓存来把性能提高到和函数表派发一样快。 Swift 的派发机制那么，到底 Swift 是怎么派发的呢？有四个选择具体派发方式的因素存在： 声明的位置 引用类型 特定的行为 显式的优化(Visibilty Optimizations) 在解释这些因素之前，我有必要说清楚，Swift 没有在文档里具体写明什么时候会使用函数表什么时候使用消息机制。唯一的承诺是使用dynamic修饰的时候会通过 Objective-C 的运行时进行消息机制派发。 声明的位置在 Swift 里，一个函数有两个可以声明的位置： 类型声明的作用域和 extension。 根据声明类型的不同，也会有不同的派发方式。 1234567class MyClass { func mainMethod() {}}extension MyClass { func extensionMethod() {}} 上面的例子中，mainMethod会使用函数表派发，而extensionMethod则会使用直接派发。 Initial Declaration Extension Value Type Static Static Protocol Table Static Class Table Static NSObject subclass Table Message 这张表格展示了默认情况下 Swift 使用的派发方式。 总结起来这么几点： 值类型总是会使用直接派发，简单易懂 而协议和类的 extension 都会使用直接派发 NSObject 的 extension 会使用消息机制进行派发 NSObject 声明作用域里的函数都会使用函数表进行派发 协议里声明的，并且带有默认实现的函数都会使用函数表进行派发 引用类型引用的类型决定了派发的方式。这很显而易见，但也是决定性的差异，一个比较常见的疑惑，发生在一个协议拓展和类型拓展同时实现了同一个函数的时候。 12345678910111213141516171819202122232425protocol MyProtocol {}struct MyStruct: MyProtocol {}extension MyStruct { func extensionMethod() { print(\"Struct\") }}extension MyProtocol { func extensionMethod() { print(\"Protocol\") }}let myStruct = MyStruct()let myProtocol: MyProtocol = myStructmyStruct.extensionMethod() // \"Struct\"myProtocol.extensionMethod() // \"Protocol\" 引用的类型决定了派发的方式，协议拓展里的函数会使用直接派发方式调用。如果把 extensionMethod 的声明移动到协议的声明位置的话，则会使用函数表派发，最终就会调用结构体里的实现。并且，如果两种声明方式都使用了直接派发的话，基于直接派发的运作方式，我们不可能实现预想的override行为。 指定派发方式Swift 有一些修饰符可以指定派发方式。 finalfinal 允许类里面的函数使用直接派发。这个修饰符会让函数失去动态性。任何函数都可以使用这个修饰符，就算是 extension 里本来就是直接派发的函数。这也会让 Objective-C 的运行时获取不到这个函数，不会生成相应的 selector。 dynamicdynamic 可以让类里面的函数使用消息机制派发。 dynamic可以让声明在 extension 里面的函数能够被 override。 dynamic可以用在所有 NSObject的子类和 Swift 的原生类。 @objc &amp; @nonobjc@objc和@nonobjc显式的声明了一个函数是否能被 Objective-C 的运行时捕获到。使用@objc的典型例子就是给 selector 一个命名空间 @objc(methodName),让这个函数可以被 Objective-C 的运行时调用。 @nonobjc会改变派发的方式，可以用来禁止消息机制派发这个函数，不让这个函数注册到 Objective-C 的运行时里。我不确定这跟 final 有什么区别，因为从使用场景来说也几乎一样，我个人更喜欢final,因为意图更明显。 final @objc可以在标记为 final 的同时, 也使用 @objc 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 perform(selector:) 以及别的 Objective-C 特性, 但在直接调用时又可以有直接派发的性能. @inlineSwift 也支持 @inline, 告诉编译器可以使用直接派发. 有趣的是, dynamic @inline(__always) func dynamicOrDirect() {} 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做. 显式的优化Swift 会尽最大能力去优化函数派发的方式。例如，如果你有一个函数从来没有 override，Swift 就会检查并且在可能得情况下使用直接派发。这个优化大多数情况下都表现得很好，但对于使用了 target/action 模式的 Cocoa 开发者就不那么友好了。 12345678override func viewDidLoad() { super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem( title: \"Sign in\", style: .plain, target: nil, action: #selector(ViewController.signInAction) )}private func signInAction() {} 这里编译器会抛出一个错误: Argument of '#selector' refers to a method that is not exposed to Objective-C (Objective-C 无法获取 #selector 指定的函数). 你如果记得 Swift 会把这个函数优化为直接派发的话, 就能理解这件事情了. 这里修复的方式很简单: 加上 @objc 或者 dynamic 就可以保证 Objective-C 的运行时可以获取到函数了. 这种类型的错误也会发生在UIAppearance 上, 依赖于 proxy 和 NSInvocation 的代码. 另一个需要注意的是, 如果你没有使用 dynamic 修饰的话, 这个优化会默认让 KVO 失效. 如果一个属性绑定了 KVO 的话, 而这个属性的 getter 和 setter 会被优化为直接派发, 代码依旧可以通过编译, 不过动态生成的 KVO 函数就不会被触发. 2. 如何通过减少动态派发来提高性能使用final关键字修饰肯定不会被重载的声明在上面的文章里，使用 final 可以允许类里面的函数使用直接派发。而 final 关键字可以用在 class, 方法和属性里来标识此声明不可以被 override。 这可以让编译器安全的将其优化为静态派发。 将文件中使用private关键字修饰的声明推断为final。使用 private 关键字修饰的声明只能在当前文件中进行访问。这样编译器可以找到所有潜在的重载声明。任何没有被重载的声明编译器自动的将它推断为final类型并且去除间接的方法调用和属性访问。 使用全局模块优化推断internal声明为final -&gt; whole module Optimization使用internal（如果声明没有使用关键词修饰，默认是internal）关键字修饰的声明的作用域仅限于它被声明的模块中。因为Swift通常的将这些文件作为一个独立的模块进行编译，所以编译器不能确定一个internal声明有没有在其他的文件中被重载。然而如果全局模块优化（Whole Module Optimization，关于全局模块优化参看下文的相关名词解释）是打开的那么所有的模块将要在同一时间被一起编译。这样以来编译器就可以为整个模块一起做出推断，将没有被重载的internal修饰的声明推断为final类型。","link":"/2019/04/06/swift-method-dispathch-mechanism/"},{"title":"Using Collections Effectively","text":"Swift 提供了Array, Set, Dictionary 三种基本的集合类型用来存储数据。Array是有序数据的集合，Set是无序无重复数据的集合，Dictionary是无序的键值对的集合。 集合非常普遍并且共享非常多的常见特性和算法，因为在Swift中它们都遵守一个通用协议Collection。在Swift中，集合就是序列，其中的元素可以以非破坏性的方式多次遍历，并且其元素可以通过下标访问。 这可能是一个在连续内存中定义的数组，哈希表，红黑树，链表或者你可以想象的任何其他东西。作为集合它们都支持起始索引（startIndex）和结束索引（endIndex），可以用来访问集合的初始元素和用来标识集合的结束。集合支持从其startIndex到endIndex直接遍历元素，同时也支持使用下标（subscript[index]）来获取集合中的元素。 Collection 集合集合的定义1234567891011121314151617181920protocol Collection : Sequence { // 集合中元素的类型 associatedtype Element // 索引类型, 需要遵守Comparable协议 associatedtype Index : Comparable // 遍历时所用到的方法了, 即通过索引查询到对应的元素 subscript(position: Index) -&gt; Element { get } // 开始索引 var startIndex: Index { get } // 结束索引 var endIndex: Index { get } // 通过一个索引, 获取它后面的索引 func index(after i: Index) -&gt; Index } 这里用到了associatedtype关键字, 在Swift协议定义的时候, 会看到使用这个关键字, 你可以认为这是一个占位符, 具体的类型直到被用到的时候才会确定. 但是有时候我们需要规定这个占位符要有一些能力, 比如这里的Index, 他就需要遵守Comparable协议. 集合协议的扩展 通过遵守Collection协议，你可以访问集合中各种丰富的功能, 有一些我们常用的first, last，isEmpty,count等属性，以及dropFirst，dropLast,reversed，split等函数以及一些map，filter之类的高阶函数。 我们也可以通过自定义一些协议扩展来实现更加强大的功能。 如隔元素遍历的功能： 12345678910111213141516171819202122extension Collection { // 扩展集合协议 func everyOther(_ body: (Element) -&gt; Void) { // 获取首元素索引 let start = self.startIndex // 获取末尾元素索引 let end = self.endIndex var iter = start // 未走到末尾 while iter != end { // 执行外部的闭包 body(self[iter]) // 获取当前元素的下一个索引 let next = index(after: iter) // 检查索引是否走到末尾 if next == end { break } // 将当前索引指向next的下一个 iter = index(after: next) } } } (1...10).everyOther { print($0) } 集合的继承结构 除了强大的Collection本身，Swift中还有其他很多继承自Collection的协议。 BidirectionalCollection 双向集合，可以向前访问元素 RandomAccessCollection 随机访问集合，提供了复杂度O(1)的访问方法，因为继承自BidirectionalCollection,也可以向前向后访问元素 MutableCollection 可变集合，提供了修改集合元素的能力 RangeReplaceableCollection 范围替换集合，可以通过指定范围替换元素 Indces 索引集合可以通过索引的方式来访问其中的元素，其中 每个集合都有自己的索引 索引必须满足Comparable 将索引作为不透明的类型(索引可能是正数，也可能是其他类型) 如何访问第一个元素通过下标进行直接访问使用array[0]访问第一个元素, 当然没有问题, 可是如果我们扩展开来, 如果给的集合不是数组, 而是一个set, 那么, 这样的方式就行不通了. 通过索引进行访问使用set[set.startIndex]进行访问, 这样就可以了。 这个方法普遍适用于其他集合类型，如array[array.startIndex] 但是, 你同样需要注意一些潜在的问题, 如需要判空, 需要判断越界, 诸如此类 first我们可以使用set.first进行获取. 而且不用担心那些潜在的问题 如何访问集合的第二个元素我们可以通过向集合来添加一个新属性来实现 显然我们不能通过这两种方式来进行获取，因为我们之前说过，Collection的索引类型并不一定是Int，而是一个遵守Comparable协议的类型。 Slice 切片切片是仅描述集合一部分元素的类型，每个切片都有自己的起始和结束索引，并且切片与其原始集合分开存在。切片不占用额外的存储空间，只是引用原始集合，因此非常高效。当使用切片下标时，它将读出原始缓冲区中的数据，切片能这么做的原因是因为它与其原始集合共享同样的索引。 通过切片，我们可以更优雅的实现访问第二个元素的功能。 我们去掉首元素，然后再获取新得到的集合的第一个元素就可以实现了。 切片与源集合共享索引 每个类型都可以自由定义自己的切片类型 内存问题值得注意的是, 持有切片, 将使得即便将原来的集合置空, 内存也不会释放。切片是一个 原有集合 + 映射关系 的产物. 所以, 除非将切片也置空, 否则, 原有集合并不会被释放. 1234567891011121314151617extension Array { var firstHalf: ArraySlice&lt;Element&gt; { return self.dropLast(self.count / 2) }}var array = [1, 2, 3, 4, 5, 6, 7, 8]var firstHalf = array.firstHalf // [1, 2, 3, 4]// 将数组设置为空array = []print(firstHalf.first!) // 1let copy = Array(firstHalf) // [1, 2, 3, 4]// 将切片置为空firstHalf = []print(copy.first!) // 1 在这里，只有将源数组array设置为空且将切片firstHalf也设置为空之后，底层的存储才会真正消失。 过程如下 切片的工作方式有点像延迟拷贝，可以选择何时自己创建元素的副本，事实证明这种”懒”行为和延迟做某事的概念，在其他情况下也非常有用。 一种情况是函数调用。 Lazy Function默认情况下，Swift中的函数是”Eager(急切)”的，也就是说它们接收了输入并按照要求返回输出。 经过这样的一套操作, 我们计算了4004个元素, 如果我们后面还有一些其他的操作, 更糟糕的是, 如果我们最终只是取取first, 这样, 前面生成的那些元素, 都成为了浪费. 我们可以通过lazy关键字来规避这样的浪费。可以看到, 使用lazy后, 刚才的遍历过程, 变成了组织一个新集合的过程, 只有在first进行计算的时候，才进行计算。 使用lazy时如何避免重复计算的过程 lazy的目的是只根据需要进行计算，但它避免的另一件事是创建中间存储。 何时使用 Lazy 链式计算 只需要结果中的一部分 没有其他副作用 No side effects 避免跨越API边界时 MutableCollection当尝试修改集合时，使用了失效的索引： 如何避免 在持有索引和切片时, 处理要谨慎 集合发生改变时, 要更新索引后再使用 在需要索引和切片的情况下才对其进行计算 多线程访问 如何避免 隔离数据使其只能被单个线程访问 实现适当形式的互斥，如串行调度队列或锁 使用Thread Sanitizer来检查 建议首选不可变集合来避免之前提到的问题 如果可以避免，就不要使用可变集合 可以使用切片和lazy操作符来模拟想要执行的改变 当尝试修改不可变集合石，编译器会提示你 如果可以, 尽量使用带capacity的初始化函数去初始化你的集合, 因为这样节省一些不必要的内存开销, 虽然这并不能节省多少, 但是想象你的项目中有成千上万个集合对象, 他们可以省出一个相当可观的内存数量. Foundation Collection引用类型的集合： 值类型和引用类型 对于值类型来说, 这样有什么好处呢? 因为在现代CPU在设计的时候, 采用了缓存机制, 可以快速的访问连续区域的地址. 而值类型的这种操作, 各个元素之间的内存是相连的, 而引用类型的则不是. 在Swift中使用Foundation集合时，通过桥接的方式将Objective-C中的API以Swift原生的值类型。桥接使我们可以在两种不同的运行时表示之间进行转换。尽管已经对Swift和Objective-C之间的桥接进行了优化，但是两种语言之间桥接时总会产生一些开销。 当在语言之间桥接时，必须先建立新的对等的存储空间，然后需要逐个元素的在它们之间进行转换。当桥接发生在两种语言的边界时，称之为”Eager”桥接，当集合中元素也需要桥接时，集合本身将总是进行”Eager”桥接，这种情况最常出现在以字符串作为键的字典中。当集合桥接并不急切时，我们称之为’lazy’桥接。当集合元素的类型并不需要桥接时，就会发生这种情况，比如NSView，在这种情况下，桥接将会被推迟到首次使用该集合时。 发生桥接的地方和所需开销： 这里的桥接发生在 NSMutableAttributedString取string上, return bridge. 需要传入一个NSString, 参数类型桥接 param bridge 其中 “Brown” 这里也会有一个小的桥接，这里的”Brown”是一个Swift值类型的字符串，每当我们调用NSString的range(of:)时，实际上会把这个字符串桥接回NSString。 建议什么时候应该使用Foundation Collection？ 现在我们对Swift中强大的集合世界的探索已经接近尾声，希望你能够使用这种新视角来检视你现在使用集合的方式，寻找可以通过更有效地使用索引和切片来改进代码的地方，寻找可以通过惰性或者调整桥接方式而受益的地方，用ThreadSanitizer辅助审查可变状态。并通过应用今天讨论的所有概念在自己的App或者Playground中进一步锻炼你对集合的掌握.","link":"/2019/04/16/using-collections-effectively/"},{"title":"iOS 多线程的使用与总结","text":"Grand Central Dispatch(GCD) 是用来管理并发操作的底层API。 允许将一个程序切分为多个单一任务，然后提交到工作队列中并发或者串行地执行 为多核的并行运算提出了解决方案，自动合理的利用CPU内核（比如双核，四核） 自动的管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，只需要告诉它任务是什么就行 配合Block，使得使用起来更加方便灵活 相对于线程和锁来说，GCD 提供了一个更加易用的模板，从而避免发生并发问题。 在了解GCD之前，我们需要了解一些跟并发和线程的概念。 Concurrency 并发iOS应用中包含一个或者多个线程，这些线程由系统的调度器彼此独立的管理。每个线程可以被并发的执行，但是如何实现并发却是由系统决定的。 单核设备通过 时间切片(time-slicing) 的方式来实现并发，它们运行在一个线程上，当切换其它线程时就执行上下文切换。这种切换一般进行得非常快，让用户感觉像是同时在运行多个线程一样。 而在多核设备上，可以通过并行的方式同时执行多个线程。 GCD 建立在线程之上，它负责管理共享线程池。使用 GCD，我们可以添加code block或者工作项(work items)来调度队列，GCD 决定执行它们的线程。 所以，虽然你可以使用 GCD 的接口来编写并发代码，但是 GCD 才是真正决定是否使用并行实现的人。并行要求并发，但是并发并不一定能够保证并行。 更深一层地说，并发设计其实是结构的设计。如果你带着 GCD 的思维去编写代码，你就得小心地设计代码的结构，暴露的接口要考虑可以同时执行和不可以同时执行的代码。 根本上来说，并发(concurrency)是关于结构而并行(parallelism)是关于执行。 Queues 队列GCD 通过DispatchQueue类来操作调度队列。当我们提交工作项单元到队列中，GCD将以FIFO顺序执行它们，它会保证第一个任务是第一个启动的。 调度队列本身是线程安全的，因此你可以同时从多个线程访问它们。当了解调度队列如何为代码提供线程安全时，你就可以认识到GCD的好处是显而易见的。关键是要选择正确类型的调度队列和正确的调度函数，将你的工作提交到队列。 队列可以是并行(serial)或者串行(concurrent)的。DispatchQueue的默认初始化方法创建的是一个同步队列，如果要创建并行队列，需要在attributes中声明concurrent。第一个参数表示队列的标签，这个标签在调试器中是可见的。 12345// 同步队列let serialQueue = DispatchQueue(label: \"queuename\")// 并发队列let concurrentQueue = DispatchQueue(label: \"queuename\", attributes: .concurrent) 串行可以保证在任何给定时间只运行一个任务，由 GCD 来控制执行的时间点，你也无法知道一个任务结束和下一个任务开始之间的时间量。 而并发队列允许多个任务同时运行。队列保证它们以添加的顺序来执行，但是它们会以任何可能的顺序完成。 何时开始任务完全取决于 GCD。如果一个任务的执行时间与另一个任务的执行时间重叠，则由 GCD 决定是否应该在不同的核心上运行，如果是单核设备，则执行上下文切换以运行不同的任务。 下面通过代码来看下串行和并发的区别： 1234567891011121314151617181920212223242526272829let serialDispatchQueue = DispatchQueue(label: \"custom_queue\")serialDispatchQueue.async { print(\"serialDispatchQueue async 1 is begin.\") sleep(3) print(\"serialDispatchQueue async 1 is end\")}serialDispatchQueue.async { print(\"serialDispatchQueue async 2 is begin.\") sleep(3) print(\"serialDispatchQueue async 2 is end\")}serialDispatchQueue.async { print(\"serialDispatchQueue async 3 is begin.\") sleep(3) print(\"serialDispatchQueue async 3 is end\")}print(\"🤠Welcome to the main thread from serialDispatchQueue\")// output: // serialDispatchQueue async 1 is begin.// 🤠Welcome to the main thread from serialDispatchQueue// serialDispatchQueue async 1 is end// serialDispatchQueue async 2 is begin.// serialDispatchQueue async 2 is end// serialDispatchQueue async 3 is begin.// serialDispatchQueue async 3 is end 关于并发： 123456789101112131415161718192021222324let concurrentDispatchQueue = DispatchQueue(label: \"custom_queue\", attributes: .concurrent)concurrentDispatchQueue.async { print(\"concurrentDispatchQueue async 1 is begin.\") sleep(3) print(\"concurrentDispatchQueue async 1 is over.\")}concurrentDispatchQueue.async { print(\"concurrentDispatchQueue async 2 is begin.\") sleep(3) print(\"concurrentDispatchQueue async 2 is over.\")}print(\"🤠Welcome to the main thread from concurrentDispatchQueue\")// output:// concurrentDispatchQueue async 1 is begin.// concurrentDispatchQueue async 2 is begin.// concurrentDispatchQueue async 3 is begin.// 🤠Welcome to the main thread from concurrentDispatchQueue// concurrentDispatchQueue async 1 is over.// concurrentDispatchQueue async 2 is over.// concurrentDispatchQueue async 3 is over. Synchronous vs. Asynchronous 同步与异步使用GCD，我们可以同步或异步分配任务。 任务完成后，同步函数会将控制权返回给调用者。 您可以通过调用DispatchQueue.sync（execute :)来同步调度工作单元。 异步函数立即返回，命令任务开始但不等待它完成。 因此，异步函数不会阻塞当前执行线程继续执行下一个函数。 您可以通过调用DispatchQueue.async（execute :)来异步调度工作单元。 GCD 提供了三种主要类型的队列： Main queue 主队列，在主线程上运行，是一个串行队列 Global queues 全局队列，整个系统共享的并发队列。全局队列有四种不同的优先级：high,default,low和background。background优先级最低，在任何I/O活动中受到限制，以最大限度地减少对系统地负面影响。 Custom queue 自定义队列，由开发创建的队列，可以是串行或者并发的队列。而在这个队列上的请求最终会在全局队列中的一个上执行。 而将任务发送到全局并发队列时，不直接指定优先级，而是指定服务质量(QoS)属性。QoS用来标志任务的重要性，并指导GCD赋予任务优先级。 123456queue.async(qos: .background) { print(\"Maintenance work\")}queue.async(qos: .userInitiated) { print(“Button tapped”)} 下面介绍一下在创建队列时，可以设置的一些更丰富的属性。创建队列的完整方法如下：1convenience init(label: String, qos: DispatchQoS = default, attributes: DispatchQueue.Attributes = default, autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = default, target: DispatchQueue? = default) label 表示队列的标识符，在debug的时候可以通过label来分辨。 QoS队列在执行上是有优先级的，更高的优先级可以享受更多的计算资源，从高到低包括： userInteractive 用户交互，表示需要立即完成的任务，用以提供良好的用户体验。将其用于UI更新，事件处理和需要低延迟地小型工作负载。在执行您的应用程序期间，此类中完成的工作总量应该很小。这应该在主线程上运行。 userInitiated 用户活动 用户从UI启动这些异步任务。当用户等待立即结果以及继续用户交互所需地任务时使用它们。它们在高优先级全局队列中执行。 utility 表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 background 这表示用户不需要直接了解的任务。用于预取，维护和其他不需要用户交互且时间不敏感的任务。这将被映射到后台优先级全局队列。 Attributes包含两个属性： concurrent 标识队列为并发队列 initiallyInactive 标识队列中的任务需要手动触发（为添加该标识时，向队列中添加任务会自动运行），触发时通过queue.activate()方法 AutoreleaseFrequency这个属性表示 autorelease pool的自动释放频率，autorelease pool 管理着任务对象的内存周期。 包含三个属性： inherit 继承目标队列的该属性 workItem 跟随每个任务的执行周期进行自动创建和释放 never 不会自动创建 autorelease pool，需要手动管理 一般任务采用 .workItem 就够了，特殊任务如在任务内部大量重复创建对象的操作可选择 .never属性手动创建 autorelease pool。 Target这个属性设置的是一个队列的目标队列，即实际将该队列的任务放入指定队列中运行。目标队列最终约束了队列优先级等属性。 在程序中手动创建的队列，其实最后都指向系统自带的 主队列 或 全局并发队列。 你也许会问，为什么不直接将任务添加至系统队列中，而是自定义队列，因为这样的好处是可以将任务进行分组管理。如单独阻塞队列中的任务，而不是阻塞系统队列中的全部任务。如果阻塞了目标队列，所有指向它的原队列也将被阻塞。 在 Swift 3 及之后，对目标队列的设置进行了约束，只有两种情况可以显式地设置目标队列（原因参考）： 初始化方法中，指定目标队列。初始化方法中，attributes 设定为 initiallyInactive，然后在队列执行 activate() 之前可以指定目标队列。在其他地方都不能再改变目标队列。 推迟时间后执行有时候你并不需要立即将任务加入队列中运行，而是需要等待一段时间后再进入队列中，这时候可以使用 asyncAfter 方法。可以用静态方法now获得当前时间，然后再通过加上一个DispatchTimeInterval枚举来获得一个需要延迟的时间。 1234let delay = DispatchTime.now() + DispatchTimeInterval.seconds(60)DispatchQueue.main.asyncAfter(deadline: delay) { // 延迟执行} 这里也可以直接加上一个秒数。1let three = DispatchTime.now() + 3.0 因为DispatchTime中自定义了+号。1public func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime 同步锁如果一段代码所在的进程中有多个线程在同时运行，那么这些线程就有可能会同时运行这段代码。假如多个线程每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。由于可读写的全局变量及静态变量（在 Objective-C 中还包括属性和实例变量）可以在不同线程修改，所以这两者也通常是引起线程安全问题的所在。 注意，pthread_mutex_t，pthread_rwlock_t 和 OSSpinLock 是值类型，而不是引用类型。这意味着如果你用 = 进行赋值操作，实际上会复制一个副本。这会造成严重的后果，因为这些类型无法复制！如果你不小心复制了它们中的任意一个，这个副本无法使用，如果使用可能会直接崩溃。这些类型的 pthread 函数会假定它们的内存地址与初始化时一样，因此如果将它们移动到其他地方就可能会出问题。OSSpinLock 不会崩溃，但复制操作会生成一个完全独立的锁，这不是你想要的。 如果使用这些类型，就必须注意不要去复制它们，无论是显式的使用 = 操作符还是隐式地操作。例如，将它们嵌入到结构中或在闭包中捕获它们。 另外，由于锁本质上是可变对象，需要用 var 来声明它们。 其他锁都是是引用类型，它们可以随意传递，并且可以用 let 声明。 在 Swift 中可以使用 Darwin 中传统的锁的方式。但是 pthread 类型很难在 swift 中使用。它们在被定义为不透明的结构体中包含了一堆存储变量。所以，很不建议在 Swift 中使用这一类型的锁。 如果想要使用传统类型的锁，我们可以使用Foundation.Lock, 因为不同于传统的基于C语言锁的结构，它是一个类，因此不会产生之前提到的那个问题。 同时我们推荐使用调度队列来进行同步 如何使用调度队列来实现同步： 同时，可以使用预设条件来确保代码运行在特定的队列中运行。 DispatchGroup当有多个任务需要处理时，你可以异步的一个个处理这些任务， 你还可以将它们组合在一起然后等待这个组合工作的结束。 DispatchGroup相当于一系列任务的松散集合，它可以来自相同或者不同队列，扮演者组织者的角色。它可以通知外部队列，组内的任务是否都已完成。或者阻塞当前的线程，直到组内的任务都完成。所有适合组内执行的任务都可以使用任务组，且任务组更适合集合异步任务(如果都是同步任务，直接使用串行队列即可)。 通过创建的DispatchGroup对象，当你向调度器提交工作的时候，可以向异步调用增加这个group作为一个可选的参数。你可以向这个group添加更多的工作以及在不同的队列中使用同一个group将它们联系起来。 每次向group提交工作，它都会增加需要完成的项目的数量。最后当你提交了所有的工作，可以让group在所有工作被完成时在指定的队列上通知你。 有两种方式加入任务组： 添加任务时指定任务组 12345let group = DispatchGroup()let queue = DispatchQueue.global()queue.async(group: group) { // do something} 使用 group.enter(), group.leave() 配对方法，标识任务加入任务组。123456let group = DispatchGroup()group.enter()queue.async() { // do something group.leave()} 两种加入方式在对任务处理的特性上是没有区别的，只是便利之处不同。如果任务所在的队列是自己创建或系统队列，那么直接使用第一种方式直接加入即可。如果任务是由系统或第三方的API创建的，由于无法获取对应的队列，只能使用第二种方式将任务加入组内，例如将 URLSession 的 addDataTask 方法加入任务组中。 1234567891011extension URLSession { func addDataTask(to group: DispatchGroup, with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask { group.enter() // 进入任务组 return dataTask(with: request) { (data, response, error) in completionHandler(data, response, error) group.leave() // 离开任务组 } }} 我们也可以等待任务组中的任务全部完成后，可以统一对外发送通知，有两种方式： group.notify() 方法，它可以在所有任务完成后通知指定队列并执行一个指定任务，这个通知的操作是异步的（意味着通知后续的代码不需要等待任务，可以继续执行）： 12345678910111213141516171819202122let group = DispatchGroup()let queueBook = DispatchQueue(label: \"book\")queueBook.async(group: group) { // do something 1}let queueVideo = DispatchQueue(label: \"video\")queueVideo.async(group: group) { // do something 2}group.notify(queue: DispatchQueue.main) { print(\"all task done\")}print(\"do something else.\")// 执行结果// do something else.// do something 1(任务 1、2 完成顺序不固定)// do something 2// all task done group.wait() 方法， 它会在所有任务完成后再执行当前线程中后续的代码，因此这个操作是有阻塞作用。 12345678910111213141516171819let group = DispatchGroup()let queueBook = DispatchQueue(label: \"book\")queueBook.async(group: group) { // do something 1}let queueVideo = DispatchQueue(label: \"video\")queueVideo.async(group: group) { // do something 2}group.wait()print(\"do something else.\")// 执行结果// do something 1(任务 1、2 完成顺序不固定)// do something 2// do something else. wait 方法中还可以指定具体的时间，它表示将等待不超过这个时间，如果任务组在指定时间之内完成则立即恢复当前线程，否则将等到时间结束时再恢复当前线程。 方式1，使用 DispatchTime，它表示一个时间间隔，精确到纳秒（1/1000,000,000 秒）： 12let waitTime = DispatchTime.now() + 2.0 // 表示从当前时间开始后 2 秒，数字字面量也可以改为使用 TimeInterval 类型变量group.wait(timeout: waitTime) 方式2，使用 DispatchWallTime，它表示当前的绝对时间戳，精确到微秒（1/1000,000 秒），通常使用字面量即可设置延时时间，也可以使用 timespec 结构体来设置一个精确的时间戳，具体参见附录章节的《时间相关的结构体说明 - DispatchWallTime》： 12// 使用字面量设置var wallTime = DispatchWallTime.now() + 2.0 // 表示从当前时间开始后 2 秒，数字字面量也可以改为使用 TimeInterval 类型变量 SemaphoreDispatchSemaphore 是传统计数信号量的封装，用来控制资源被多任务访问的情况。简单来说就是控制访问资源的数量，比如系统有两个资源可以被利用，同时有三个线程要访问，只能允许两个线程访问，第三个应当等待资源被释放后再访问。例如，控制同一时间写文件的任务数量、控制端口访问数量、控制下载任务数量等。 信号量的使用非常的简单： 首先创建一个初始数量的信号对象 使用 wait 方法让信号量减 1，再安排任务。如果此时信号量仍大于或等于 0，则任务可执行，如果信号量小于 0，则任务需要等待其他地方释放信号。 任务完成后，使用 signal 方法增加一个信号量。 等待信号有两种方式：永久等待、可超时的等待。 123456789101112131415161718192021222324252627282930313233343536let queue = DispatchQueue( label: \"com.sinkingsoul.DispatchQueueTest.concurrentQueue\", attributes: .concurrent)let semaphore = DispatchSemaphore(value: 2) // 设置数量为 2 的信号量semaphore.wait()queue.async { print(\"Task 1 start\") sleep(2) print(\"Task 1 finish\") semaphore.signal()}semaphore.wait()queue.async { print(\"Task 2 start\") sleep(2) print(\"Task 2 finish\") semaphore.signal()}semaphore.wait()queue.async { print(\"Task 3 start\") sleep(2) print(\"Task 3 finish\") semaphore.signal()}// 运行结果：// Task 1 start// Task 2 start// Task 1 finish// Task 2 finish// Task 3 start// Task 3 finish 运行结果中可以看到任务 3 在前两个任务完成后才开始运行。 DispatchWorkItemDispatchQueue执行操作除了直接传递一个闭包外，还可以传入一个DispatchWorkItem。 DispatchWorkItem 的初始化方法可以配置 QoS 和 DispatchWorkItemFlags, 但是这两个参数都有默认参数，所以也可以只传入一个闭包。 DispatchWorkItemFlags 枚举中 assignCurrentContext 表示 QoS 根据创建时的 context 决定，这个 workItem 会从负责执行该任务的调度队列或者线程继承其QoS设置。 另外，DispatchWorkItem 也有 wait 方法，调用会等待这个 workItem 执行完。 DispatchWorkItemFlags 枚举中还有其他选项，如 barrier, detached, enforceQos, inheritQos, noQos。 .barrier: 如果DispatchWorkItem被提交到.concurrent并发队列，那么这个DispatchWorkItem中的操作会具有独占性(防止此DispatchWorkItem中的block内的操作与其他操作同时执行)。执行该任务时，它会先等待队列中已有的任务全部执行完成，然后它再执行，在它之后加入的任务也必须等栅栏任务执行完成后才能执行。 123456789101112131415161718let queue = DispatchQueue(label: \"BarrierWorkItem\", attributes: .concurrent)queue.async { sleep(4) print(\"async task 1 finish.\")}let task = DispatchWorkItem(flags: .barrier) { sleep(2) print(\"barrier task finish.\")}queue.async(execute: task)queue.async { sleep(1) print(\"async task 2 finish.\")}//async task 1 finish.//barrier task finish.//async task 2 finish. .detached 表明DispatchWorkItem会无视当前执行上下文的参数。 .noQos 不指定QoS，由调用线程或队列来指定。 .inheritQos 表明DispatchWorkItem会采用队列的QoS class，而不是当前的。 .enforceQos 表明DispatchWorkItem会采用当前的QoS class，而不是队列的。 DispatchSourceDispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。 可监听的对象的具体类型： Timer Dispatch Source：定时调度源。 Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。 Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。 Process Dispatch Source：监听进程相关状态的调度源。 Mach port Dispatch Source：监听Mach相关事件的调度源。 Custom Dispatch Source：监听自定义事件的调度源。 下面以文件监听为例看下使用方法，下面例子中监听了一个指定目录下文件的写入事件，创建监听主要有几个步骤： 通过 makeFileSystemObjectSource 方法创建 source 通过 setEventHandler 设定事件处理程序，setCancelHandler 设定取消监听的处理。 执行 resume() 方法开始接收事件 1234567891011let queue = DispatchQueue.global()let filePath = \"...\"let fileURL = URL(fileURLWithPath: filePath)let fd = open(fileURL.path, O_EVTONLY)let source = DispatchSource.makeFileSystemObjectSource(fileDescriptor: fd, eventMask: .write, queue: queue)source.setEventHandler(handler: closure)source.setCancelHandler { close(fd)}source.resume() DispatchSourceTimer 的例子：1234567891011121314151617181920212223242526func printTime(withComment comment: String){ let date = Date() let formatter = DateFormatter() formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\" print(comment + \": \" + formatter.string(from: date))}let timer = DispatchSource.makeTimerSource()timer.schedule(deadline: .now() + .seconds(10), repeating: .seconds(5), leeway: .seconds(5))timer.setEventHandler { printTime(withComment: \"hello world\")}timer.activate()printTime(withComment: \"3\")// 运行结果：// 3: 2019-04-25 16:43:53// hello world: 2019-04-25 16:44:03// hello world: 2019-04-25 16:44:08// hello world: 2019-04-25 16:44:13// hello world: 2019-04-25 16:44:18// hello world: 2019-04-25 16:44:23 表明DispatchWorkItem会采用当前的QoSDispatchIO 对象提供一个操作文件描述符的通道。简单讲就是你可以利用多线程异步高效的读写文件。 发起读写操作一般步奏如下： 创建 DispatchIO 对象，或者说创建一个通道，并设置结束处理闭包。 调用 read/write 方法。 调用 close 方法关闭通道。 在 clone 方法后系统将自动调用结束处理闭包。 初始化方法 一般使用两种方式初始化： 文件描述符，或者文件路径 文件描述符方式 文件描述符使用 open 方法创建： open(_ path: UnsafePointer&lt;CChar&gt;, _ oflag: Int32, _ mode: mode_t) -&gt; Int32, 第一个参数是 UnsafePointer 类型的路径，oflag 、mode 指文件的操作权限，一个是系统 API 级的，一个是文件系统级的，可选项如下: oflag： Flag 备注 功能 O_RDONLY 以只读方式打开文件 此三种读写类型只能有一种 O_WRONLY 以只写方式打开文件 此三种读写类型只能有一种 O_RDWR 以读和写的方式打开文件 此三种读写类型只能有一种 O_CREAT 打开文件，如果文件不存在则创建文件 创建文件时会使用Mode参数与Umask配合设置文件权限 O_EXCL 如果已经置O_CREAT且文件存在，则强制open()失败 可以用来检测多个进程之间创建文件的原子操作 O_TRUNC 将文件的长度截为0 无论打开方式是RD,WR,RDWR，只要打开就会把文件清空 O_APPEND 强制write()从文件尾开始不care当前文件偏移量所处位置，只会在文件末尾开始添加 如果不使用的话，只会在文件偏移量处开始覆盖原有内容写文件 mode：包含 User、Group、Other 三个组对应的权限掩码。 User Group Other 说明 S_IRWXU S_IRWXG S_IRWXO 可读、可写、可执行 S_IRUSR S_IRGRP S_IROTH 可读 S_IWUSR S_IWGR S_IWOTH 可写 S_IXUSR S_IXGRP S_IXOTH 可执行 创建的通道有两种类型： 连续数据流：DispatchIO.StreamType.stream，这个方式是对文件从头到尾完整操作的。随机片段数据：DispatchIO.StreamType.random，这个方式是在文件的任意一个位置（偏移量）开始操作的。 1234567let filePath: NSString = \"test.zip\"// 创建一个可读写的文件描述符let fileDescriptor = open(filePath.utf8String!, (O_RDWR | O_CREAT | O_APPEND), (S_IRWXU | S_IRWXG))let queue = DispatchQueue(label: \"com.sinkingsoul.DispatchQueueTest.serialQueue\")let cleanupHandler: (Int32) -&gt; Void = { errorNumber in}let io = DispatchIO(type: .stream, fileDescriptor: fileDescriptor, queue: queue, cleanupHandler: cleanupHandler) 文件路径方式 1let io = DispatchIO(type: .stream, path: filePath.utf8String!, oflag: (O_RDWR | O_CREAT | O_APPEND), mode: (S_IRWXU | S_IRWXG), queue: queue, cleanupHandler: cleanupHandler) 数据块大小阀值DispatchIO 支持多线程操作的原因之一就是它将文件拆分为数据块进行并行操作，你可以设置数据块大小的上下限，系统会采取合适的大小，使用这两个方法即可：setLimit(highWater: Int)、setLimit(lowWater: Int)，单位是 byte。1io.setLimit(highWater: 1024*1024) 数据块如果设置小一点（如 1M），则可以节省 App 的内存，如果内存足够则可以大一点换取更快速度。在进行读写操作时，有一个性能问题需要注意，如果同时读写的话一般分两个通道，且读到一个数据块就立即写到另一个数据块中，那么写通道的数据块上限不要小于读通道的，否则会造成内存大量积压无法及时释放。 读操作方法示例：123456789101112ioRead.read(offset: 0, length: Int.max, queue: ioReadQueue) { doneReading, data, error in if (error &gt; 0) { print(\"读取发生错误了，错误码：\\(error)\") return } if (data != nil) { // 使用数据 } if (doneReading) { ioRead.close() }} offset 指定读取的偏移量，如果通道是 stream 类型，值不起作用，写为 0 即可，将从文件开头读起；如果是 random 类型，则指相对于创建通道时文件的起始位置的偏移量。 length 指定读取的长度，如果是读取文件全部内容，设置 Int.max 即可，否则设置一个小于文件大小的值（单位是 byte）。 每读取到一个数据块都会调用你设置的处理闭包，系统会提供三个入参给你：结束标志、本次读取到的数据块、错误码： 在所有数据读取完成后，会额外再调用一个闭包，通过结束标志告诉你操作结束了，此时 data 大小是 0，错误码也是 0。如果读取中间发生了错误，则会停止读取，结束标志会被设置为 true，并返回相应的错误码，错误码表参考稍后的【关闭通道】小节：写操作方法示例： 12345678910ioWrite.write(offset: 0, data: data!, queue: ioWriteQueue) { doneWriting, data, error in if (error &gt; 0) { print(\"写入发生错误了，错误码：\\(error)\") return } if doneWriting { //... ioWrite.close() }} 写操作与读操作的唯一区别是：每当写完一个数据块时，回调闭包返回的 data 是剩余的全部数据。同时注意如果是 stream 类型，将接着文件的末尾写数据。 关闭通道当读写正常完成，或者你需要中途结束操作时，需要调用 close 方法，这个方法带一个 DispatchIO.CloseFlags 类型参数，如果不指定将默认值为 DispatchIO.CloseFlags.stop。 这个方法传入 stop 标志时将会停止所有未完成的读写操作，影响范围是所有 I/O channel，其他 DispatchIO 对象进行中的读写操作将会收到一个 ECANCELED 错误码，rawValue 值是 89，这个错误码是 POSIXError 结构的一个属性，而 POSIXError 又是 NSError 中预定义的一个错误域。 因此如果要在不同 DispatchIO 对象中并行读取操作互不影响， close 方法标志可以设置一个空值：DispatchIO.CloseFlags()。如果设置了 stop 标志，则要做好不同 IO 之间的隔离，通过任务组的enter、leave、wait 方法可以做到较好的隔离。12ioWrite.close() // 停止标志ioWrite.close(flags: DispatchIO.CloseFlags()) // 空标志","link":"/2019/04/03/ios-gcd-understanding/"},{"title":"Understanding Swift Performance","text":"理解 Swift 的性能，首先要搞清楚 Swift 的数据结构，组件关系和它们的内在实现，从而通过选择最合适的抽象机制来提升性能。 当你在创建一个抽象并选择一个抽象机制时，你应该问问自己 我的实例时分配给堆栈还是堆？ 当我传递这个实例时，我要产生多少开销？ 当我在这个实例中调用方法时，是静态还是动态发送? 当我们想快速地写Swift代码时, 就要避免为不能利用的动态和运行时间付出代价。我们需要学习何时以及如何在这些不同维度之间切换来获得更好的性能。 下面我们将从不同维度来评估不同的抽象机制选项。 Allocation 内存分配Swift 会替你自动分配和回收内存的分配。 有些内存会分配给栈(Stack)，有些则会分配到堆(Heap)上。 栈时一种非常简单的数据结构，你可以将元素压到栈底或者弹出栈底。因为你只能添加或移出栈底，所以只需要通过保存的栈底指针就可以实现栈的入栈和出栈。 这意味着当调用函数时, 只需要通过递减栈底指针数值来获取空间。当函数执行完毕后，同样只需要把栈底指针增加至调用函数之前的的数值即可达到释放内存的目的。因此栈的分配速度非常快，它其实仅仅是分配一个整数的消耗。 那么，这就与堆形成了对比。 堆更动态化，但比栈效率低。堆可以让你实现栈不能实现的功能，比如动态周期性的分配内存，但它同时也需要更高级的数据结构。如果你要在堆上分配内存，实际上要去搜索堆数据结构，寻找适当大小的闲置内存块，用完之后要释放内存，还需要把那个内存块插回到正确的位置。很显然，相比在栈中实现的，这涉及的东西更多。同时，因为涉及到多线程分配内存，堆需要使用锁或其它同步机制来保护它的完整性，这是一个很大的消耗。 下面通过一些代码来看看 Swift 都替我们做了什么 12345678910struct Point { var x, y: Double func draw() { … } }let point1 = Point(x: 0, y: 0) var point2 = point1 point2.x = 5 // use `point1` // use `point2` 上面定义了一个Point的结构体, 有x和y存储属性, 还有draw方法。用(0, 0) 构造点，把point1 赋值给point2, 并把point2.x赋一个为5的值。 在执行任何代码之前, 系统已为point1和point2实例在堆栈上分配了一个空间，因为Point是一个结构体，而x和y属性被存储在栈中。当把point1赋值给point2时，我们仅仅是复制了那个点，并初始化了point2的内存，也就是之前已经分配到栈上的内存。请注意，point1和point2是独立的实例，意思就是，当我们给point2.x赋一个为5的值时，point2.x是5，但point1.x仍然是0，这就是值语义。 然后我们继续使用point1和point2，并完成函数的执行之后，只需要通过把堆栈指针的值增至进入函数之前的值就可以释放point1和point2的内存。 同之前的代码比较，下面使用 class 来定义Point 12345678910 struct Point { var x, y: Double func draw() { … } }let point1 = Point(x: 0, y: 0) var point2 = point1 point2.x = 5 // use `point1` // use `point2` 跟之前的一样，我们给栈分配内存，但并不实际存储’Point’的属性。我们要给point1和point2分配内存引用，引用要分配到堆上的内存。当用(0, 0)进行初始化时，Swift会锁住堆并寻找堆上适当大小的闲置内存块。在得到合适的内存块后，我们要以x为0，y为0进行初始化, 并且把point1初始化为那个堆上分配的内存地址。请注意，当在堆上分配时，Swift其实是为Point类分配了四个字的存储，这跟Point是结构体时所分配的两个字形成了对比。Swift 会多出的两个字进行管理，这两个字通过图中的这些蓝色框来指示。 注： 多出的第一个字可以简单的说就是指向 Class 的指针，第二个字存放的是引用计数。 https://juejin.im/post/5a7b04c86fb9a0634b4d632a 当把point1赋值给point2时，我们并不是要复制point1的内容，相反它是复制引用。point1和point2其实指的正是堆上的同一个实例。意思是，当我们给point2.x赋一个为5的值时，point1.x和point2.x的值都为5，这就是引用的语义，可导致非计划的状态共享。 然后Swift会释放这个内存,锁住堆,再分配闲置内存块到适当的位置后就可以出栈了。 我们看到类的构造比结构的构造消耗更多。由于类是在堆上分配的并且有引用语义，所以类有一些强大的特性，如一致性和间接存储。但是如果我们的抽象不需要这些特性，最好还是用结构体，而且结构不会导致像类那样的非计划的状态共享。 Reference Counting 引用计数当我们谈堆式分配时，Swift 是如何了解何时释放在堆上分配的内存是安全的呢？ 答案是 Swift 会保持一个堆中任何实例的引用个数的总计数，并把它存储在实例本身。当你添加引用或移除引用时，就会增加或减少引用计数。当计数为零时，Swift就知道没有指向堆上的这个实例的引用，而且释放那个内存很安全。 引用计数的关键点是，这是个非常频繁的运算。实际上比只增加和减少一个整数更复杂。首先，涉及到成对出现的间接层级来执行增加和减少计数。更重要的是跟堆式分配一样，需要考虑线程的安全性，因为引用能在多线程的时候被添加或移除到任何堆实例，由于引用计数运算的频率高，这会增加消耗。 以 Point 类为例，来看看 Swift 替我们做了什么。这里有用来作为对比的一些伪代码： Point获得了一个附加属性refCount,并且 Swift 添加了一对调用 retain 和 release, retain会自动增加引用计数，release会自动减少引用计数，这样 Swift就可以追踪堆上的Point上有多少激活的引用。 在堆上构造Point之后，因为有一个实例的实时引用，那个实例就被初始化为引用计数为1。查看整个程序，并把point1赋值给point2，我们现在就有两个引用了，那么Swift添加一个retain调用，来自动增加点实例的引用计数。继续执行，一旦我们不再使用point1，因为point1不再是它所关注的一个激活的引用，Swift 会添加一个release调用来自动减少引用计数。同样地，一旦我们不再使用point2，Swift会添加另一个release调用,自动减少引用计数。在这时，没有对Point的实例引用被使用，所以Swift就知道很安全，会锁住堆并把那个内存块返回给它。 如果是结构体会怎么样呢？结构是否涉及引用计数呢？当我们构造点结构时，不会涉及任何堆式分配，当我们复制时也不会涉及任何堆式分配，每个步骤都不会涉及引用。所以Point结构体没有引用计数。 那更复杂的结构呢？ 12345678910struct Label { var text: String var font: UIFont func draw() { … } }let label1 = Label(text: \"Hi\", font: font) let label2 = label1 // use `label1` // use `label2` 在这里有个Label结构体，属性包含字符串类型的text，和类型为UIFont的font。刚才提到过字符串，实际上是把它的字符内容存储在堆上，所以需要引用计数。字体是一个类,也需要引用计数。 当我们复制它时，实际上增加了两个引用。 Swift的追踪这些堆式分配的方式是通过保留和释放的调用来实现的。 由于类是在堆上分配的，Swift得管理那个堆式分配的使用期限，这是通过引用计数实现的。 而引用计数的难点在于运算相对频繁,且具备原子性。这也是我们使用结构的另一个原因。 但是，如果结构包含引用，也会进行引用计数。事实上，结构体会进行引用计数,相应地与它们所包含的引用数量成比例的。所以 如果它们有一个以上的引用，它们会保留一个类以上的引用计数。 Method Dispatch 方法派发在运行过程中，当调用一个方法时，Swift 需要执行正确的实现。 如果能在编译时确定要执行的实现，这就是静态派发。 在运行过程中，我们能直接跳到正确的实现，这很酷。因为编译器实际上可以看到要执行哪些实现，并且也可以做一些如内联之类的优化，这跟动态调度形成了对比。 动态调度时，在编译时无法直接决定要执行哪个实现。在运行时，需要去查找实现，然后调到那个。相比静态派发，虽然动态派发增加了一个间接层级，这样做的成本并不高。但是动态派发阻碍了编译器的可见性，编译器无法对动态派发进行一些包括内联的优化操作。 我们究竟为什么要这个动态调度呢？原因之一是通过它可以使一些特性成为可能，比如多态。 我们通过一个传统的面向对象的程序来看下具体原理。有一个可绘制的抽象超类,我可以定义一个Point子类和Line子类，然后用自定义实现来覆盖draw方法。 然后我可以多态地创建Drawable实例的数组，可能包含Point实例，也可能包含Line实例，可以分别调用draw。 那么是如何实现的呢？ 因为可绘制的Point和Line都是类，我们可以创建一个包含这些实例的数组, 因为我们保存在数组里的是对它们的引用，因此它们都是相同大小的对象。但当我们查看数组中的元素并且尝试调用draw的时候，因为这个d.draw可以是Point，也可以是个Line,这是不同的代码路径。那么，如何决定调用哪个呢？ 编译器向类中添加了另一个字段，是这个类的类型信息的指针，指向存储在静态内存中的类型信息。 因此 当调用draw时，编译器实际上生成的了一个对类型信息的查询，查找一个虚拟方法表，在类型和包含指针的静态内存上找到要执行的正确的实现。 如果我们修改了这个d.draw，编译器替我们做的是查询虚拟方法表，找到要执行的正确的draw实现，然后把那个实际的实例作为隐式的self参数传过来。 类默认动态地调度它们的方法，这对于它本身并没有什么不同。但是如果形成方法链，会阻碍编译器进行内联及一些其他可添加的优化。 但是，并不是所有类都需要动态调度。如果你从未打算给一个类创建子类，你可以把它标记为final类，编译器会注意到这一点，并静态地调度这些方法。 此外 如果编译器可以推理和证明你从不打算在应用中给类建立子类，它将适时地替你把那些动态调度变成静态调度。 Summary因此无论何时，当你读和写Swift代码时你都应该观察和思考： 这个实例要在堆栈中还是在堆中分配？ 当我传递这个实例时,要引发多少引用计算？ 当我在这个实例中调用方法时是动态调度还是静态调度？ 你可能会问Struct如何实现多态呢?答案是 Protocol Oriented Programming。 以上分析了影响性能的几个标准，那么不同的算法机制Class，Protocol Types和Generic code，它们在这三方面的表现如何，Protocol Type 和 Generic code 分别是怎么实现的呢？我们带着这个问题看下去。 Protocol Types这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。 这次我们不再用Drawable地抽象基类，我们要用声明了draw方法的Drawable协议，并且我们有数值类型的Point结构体和遵循协议的Line结构体。 请注意，我们同样还可以有一个遵循协议的SharedLine类。然而，由于类所具有的引用语义会使非计划的共享出现，因此我们决定不再使用它。 我们程序仍然是多态的，仍然可以在Drawable的协议类型数组中存储Point和Line类型实例。然而 跟以前相比有一个不同点，Point数值类型结构和Line结构并不共享一个使用 v-table 调度所需要的共同的继承关系。 123456789101112131415protocol Drawable { func draw() }struct Point : Drawable { var x, y: Double func draw() { … } }struct Line : Drawable { var x1, y1, x2, y2: Double func draw() { … } }var drawables: [Drawable] for d in drawables { d.draw() } 那么 Swift是如何调度正确的方法的呢？在这个例子中，是通过被称为Protocol Witness Table的基于表的机制。每个实现协议的类型中都有这么一张表，并且表中的条目会链接到类型中的具体实现。 那么 现在我们了解了如何找到那个方法，如何把元素从数组中拿到表中仍然有个问题。 还有另一个问题，请注意，我们现在有数值类型的Point和Line，Line需要四个字，而Point需要两个字，它们的大小不一样。 但数组需要以一致的固定偏移量存储元素，那是如何实现的呢？ 这个问题的答案是，Swift使用一个特殊存储布局叫存在容器(Existential Container)。 存在容器内的前三个字是留给valueBuffer的。小类型，比如我们的Point类型只需要两个字，刚好能放进valueBuffer中。 而Line类型需要四个字，该把它放在哪呢？在这种情况下，Swift会在堆上分配内存，把值存入堆中，并将这块内存的地址指针存储在存在容器中。 现在 你看到了Point和Line之间的不同点，因此，存在容器无论如何得管理这个不同点，那么该如何实现呢？ 嗯，答案是，还是基于表的机制，在这个示例中，我们叫它 值证明表(Value Witness Table)。值证明表会管理值的有效期。 在程序中，每种类型都有一张表。现在，通过观察局部变量的有效期来看下这个表是如何运作的。 在协议类型的局部变量有效期的开始，Swift 在那个表内部调用了分配函数。在这个函数中，因为这个例子有一个Line值证明表，我们将在堆上分配内存，并给该内存存一个指针，存在容器的valueBuffer内。 下一步 Swift要将初始化局部变量的原始值复制到存在容器中，我们在这里有一个Point，所以值证明表的复制条目会做出正确的判断并把它在堆中分配的值复制到valueBuffer中。如果是Line则将值复制到valueBuffer存储的指针对应的堆内存上。 我们现在是在局部变量有效期的最后阶段，Swift会调用值证明表的 destruct 条目，这将递减可能包含在类型中的值的引用计数。 在最后，Swift会调用表中的deallocate函数，这将释放在堆上为值分配的内存。 那么，我们已经看到了 Swift 处理不同种类的值的一般性机制。但无论如何它仍需要进入这些表，对吧？ 嗯，答案很明显,在存在容器(Existential Container)中含有对值证明表(Value Witness Table)的引用。 如何进入协议证明表(Protocol Witness Table)呢？它是在存在容器中进行引用的。 我们已经了解了 Swift 管理协议类型的机制，现在我们来看个例子，看看运行中的存在容器。 1234567// Protocol Types // The Existential Container in action func drawACopy(local : Drawable) { local.draw() } let val : Drawable = Point() drawACopy(val) 在这个例子中，我们有一个函数，把协议类型参数当做局部参数，并在局部参数上执行draw方法。 程序会创建一个Drawable的局部变量，并用Point类型对其进行初始化。然后把这个局部变量作为参数传给一个drawACopy函数调用。 为了显示Swift编译器为我们生成的代码，在这个例子中，我将使用Swift作为伪代码注释。 那么，对于存在容器(Existential Container)而言，下面这个结构体存储了valueBuffer的三个字，还有一个值证明表(VWT)和协议证明表(PWT)的引用。 当drawACopy函数调用执行时，它会接收实参并把它传给函数。在生成的代码中我们看到，Swift 把存在容器作为实参传给了函数，当函数开始执行时，函数为那个形参创建了一个局部变量，并给它赋了一个实参。 在所生成的代码中，Swift将在栈上分配一个存在容器。 然后，它将从实参存在容器中读取值证明表和协议证明表，并在局部实参容器中对字段进行初始化。 下一步，它将调用值证明函数分配valueBuffer，如果必要的话还会复制值。在这个例子中，我们传了一个Point，所以就不需要任何动态堆式分配了，这个函数只是从实参中把值复制到局部存在容器的valueBuffer中。然而，如果我们传一个Line，这个函数将会分配堆内存，并在堆中复制值。 下一步执行draw方法，Swift 会从存在容器字段中查询协议证明表(PWT)，在那个表的固定偏移中查询draw方法，并跳到那个实现。这里还有另一个值证明(VWT)调用，就是projectBuffer。draw方法把值的地址当成了它的输入。如果这里正好能放进valueBuffer的小值，返回的地址为存在容器的开始，若我们有一个大值不适合放进valueBuffer，那个地址就是在堆上分配的内存的开始。 然后draw方法执行完毕。 现在，程序执行到函数的末端，也就是说为形参创建的局部变量超出了适用范围，所以Swift调用值证明函数来destruct这个局部变量，如果值还有引用的话，这将递减引用计数，并且如果分配了valueBuffer，同样会释放缓冲区。 函数执行完毕，移除了栈，同时也移除了在堆栈上创建的局部存在容器。 一个简单的调用实际做了这么多事情。这些代价都是花在需要动态判断具体struct的信息和跳转到对应的方法上的。 这项工作是使结合的值类型,如结构体Point和结构体Line还有协议获得动态行为、动态多态性，我们可以存储一条线和一个点在Drawable的协议类型的数组中。如果你需要这个多态性，一切都值得你付出。 Protocol Type Stored Properties我们知道，Swift中Class的实例和属性都存储在堆区，Struct实例在栈区，如果包含指针属性则存储在堆区，Protocol Type如何存储属性？Small Number通过Existential Container内联实现，大数存在堆区。如何处理Copy呢？ 所以当出现大数的struct值时，会将新的Exsitential Container的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道Struct值的修改和Class不同，Copy是不应该影响原实例的值的。 这里直接使用引用语义会引发非计划的状态共享问题。 这里用到了一个技术叫做Indirect Storage With Copy-On-Write，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下： 1234567891011121314151617class LineStorage { var x1, y1, x2, y2:Double }struct Line :Drawable { var storage: LineStorage init() { storage = LineStorage(Point(), Point()) } func draw() { … } mutating func move() { if !isUniquelyReferencedNonObjc(&amp;storage) { //如何存在多份引用，则开启新内存，否则直接修改 storage = LineStorage(storage) } storage.start = ... }} Protocol Type 多态总结 支持Protocol Type的动态多态（Dynamic Polymorphism）行为。 通过使用Witness Table和Existential Container来实现。 对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。 说到动态多态Dynamic Polymorphism，我们就要问了，什么是静态多态Static Polymorphism，看看下面示例： 12345678910111213// Drawing a copyprotocol Drawable { func draw()}func drawACopy(local: Drawable) { local.draw()}let line = Line()drawACopy(line)// ...let point = Point()drawACopy(point) 这种情况我们就可以用到泛型Generic code来实现，进行进一步优化。 Generic我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和Protocol Type的区别在于： 泛型支持的是静态多态。 每个调用上下文只有一种类型。查看下面的示例，foo和bar方法是同一种类型。 在调用链中会通过类型降级进行类型取代。 对于以下示例： 1234567func foo&lt;T: Drawable&gt;(local: T) { bar(local)}func bar&lt;T: Drawable&gt;(local: T) { … }let point = Point()foo(point) 分析方法foo和bar的调用过程： 12foo(point) --&gt; foo&lt;T = Point&gt;(point) //在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Pointbar(local) --&gt; bar&lt;T = Point&gt;(local) //在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代 泛型方法调用的具体实现为： 同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。 使用Protocol/Value Witness Table。 每个调用上下文只有一种类型：这里没有使用Existential Container(当会在栈上分配valueBuffer存储值)，而是将Protocol/Value Witness Table作为调用方的额外参数进行传递。 变量初始化和方法调用，都使用传入的VWT和PWT来执行。 看到这里，我们并不觉得泛型比Protocol Type有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为特定泛型优化。 泛型特化 静态多态：在调用栈中只有一种类型。 Swift使用只有一种类型的特点，来进行类型降级取代。 类型降级后，产生特定类型的方法。 为泛型的每个类型创造对应的方法。这时候你可能会问，那每一种类型都产生一个新的方法，会生成更多的代码？ 静态多态下进行特定优化 specialization 。 因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。 例如：123func min&lt;T: Comparable&gt;(x: T, y: T) -&gt; T { return y &lt; x ? y : x} 从普通的泛型展开如下，因为要支持所有类型的min方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常复杂庞大的工程。12345678func min&lt;T:Comparable&gt;(x: T, y: T, FTable: FunctionTable) -&gt; T { let xCopy = FTable.copy(x) let yCopy = FTable.copy(y) let m = FTable.lessThan(yCopy， xCopy) ? y :x FTable.release(x) FTable.release(y) return m} 在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为： 123func min&lt;Int&gt;(x: Int, y: Int) -&gt; Int { return y &lt; x ? y :x} 泛型特化specilization是何时发生的? 在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了whole module optimization。而whole module optimization是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。 泛型进一步优化特定泛型的进一步优化： 123456789101112struct Pair&lt;T: Drawable&gt; { init(_ f: T， _ s: T) { first = f second = s } var first: T var second: T}let pairOfLines = Pair(Line(), Line())// ...let pairOfPoint = Pair(Point(), Point()) 在用到多种泛型，且确定泛型类型不会在运行时修改时，就可以对成对泛型的使用进行进一步优化。 优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调此种优化只适用于在运行时不会修改泛型类型，即不能同时支持一个方法中包含Line和Point两种类型。 Summary","link":"/2019/04/06/understanding-swift-performance/"},{"title":"[LeetCode] 2. 两数相加","text":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路这题做起来并不难，只是有点麻烦，有一些需要注意的地方。使用一个dummyHead用来存储头结点，判断l1和l2为空的情况，以及最后一位的进位的case。 实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode cur = temp; ListNode left = l1; ListNode right = l2; int comp = 0; while(left != null | right != null) { if (left == null) { cur.next = new ListNode((right.val + comp) % 10); cur = cur.next; comp = (right.val + comp) / 10; right = right.next; continue; } if (right == null) { cur.next = new ListNode((left.val + comp) % 10); cur = cur.next; comp = (left.val + comp) / 10; left = left.next; continue; } cur.next = new ListNode((left.val + right.val + comp) % 10); cur = cur.next; comp = (left.val + right.val + comp) / 10; left = left.next; right = right.next; } if (comp &gt; 0) { cur.next = new ListNode(comp); } return temp.next; }}","link":"/2019/02/24/2-add-two-numbers/"},{"title":"[LeetCode] 7.整数反转","text":"题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 思路我们可以一次构建反转整数的一个数字。这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 1234567//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 temp = rev ⋅ 10 + pop 时会导致溢出。 幸运的是，事先检查这个语句是否会导致溢出很容易。 为了便于解释，我们假设rev是正数。 如果 temp = rev * 10 + pop 导致溢出，那么一定有 rev &gt;= Integer.MAX_VALUE / 10 如果 rev &gt; Integer.MAX_VALUE, 那么 temp = rev * 10 + pop 一定会溢出 如果 rev == Integer.MAX_VALUE / 10, 那么 pop &gt; 7, temp = rev * 10 + pop 就会溢出 当 rev 为负时可以应用类似的逻辑。 Integer.MAX_VALUE -&gt; 2147483647Integer.MAX_VALUE -&gt; -2147483648 实现12345678910111213class Solution { public int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; }}","link":"/2019/03/20/7-reverse-integer/"},{"title":"[LeetCode] 1. 两数之和","text":"题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路将数组中的值作为Key, 索引值作为Value，存入HashMap中，遍历时查找HashMap中是否存在所需要的差值。 实现1234567891011121314151617class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) { map.put(nums[i], i); } for (int i = 0; i &lt; nums.length; i++) { int comp = target - nums[i]; if (map.containsKey(comp) &amp;&amp; map.get(comp) != i) { return new int[]{i, map.get(comp)}; } } return new int[]{}; }}","link":"/2019/04/17/1-two-sum/"},{"title":"[LeetCode] 9. 回文数","text":"题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 思路解法1: 将整数转换为字符数组，通过双指针比较前后字符是否相同来判断 解法2: 评论区看到的一个方法，将转换的字符串反转之后判断与原字符串是否相等 实现解法1 1234567891011121314151617class Solution { public boolean isPalindrome(int x) { char[] chars = String.valueOf(x).toCharArray(); boolean result = true; for (int i = 0; i &lt; chars.length / 2 + 1; i++) { int indexComplement = chars.length - i - 1; if (indexComplement == i) { continue; } if (chars[indexComplement] != chars[i]) { result = false; break; } } return result; }} 解法212345678class Solution { public boolean isPalindrome(int x) { StringBuffer sb = new StringBuffer(); sb.append(x); sb.reverse(); return (\"\" + x).equals(sb.toString()); }}","link":"/2018/08/20/9-palindrome-number/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Swift","slug":"Swift","link":"/categories/Swift/"}]}