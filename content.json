{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"Github: https://github.com/awind","link":"/about/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"}],"posts":[{"title":"Swift 中 map & flatMap & compactMap 的区别","text":"Swift 中提供了很多的高阶函数，而其中map，flatMap 与 compactMap 又有许多的相似之处，经常对他们使用的时机有些模糊，今天我们就从标准库实现的角度来看下他们各自的区别以及适用的情况。 Overview关于它们的定义： 123456// Sequencepublic func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]public func flatMap&lt;SegmentOfResult : Sequence&gt;(_ transform: (Element) throws -&gt; SegmentOfResult) rethrows -&gt; [SegmentOfResult.Element]public func compactMap&lt;ElementOfResult&gt;(_ transform: (Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult] 只是从上面的函数签名来看这三个函数，它们虽然都接受一个 transform 的闭包作为参数，且闭包捕获的参数都为 Sequence 中的元素类型，但是闭包所返回的类型可以与 Sequence 元素的类型不同。map 中的闭包返回类型为 T，而 map 函数的返回类型为 [T]。 flatMap 中的闭包的参数同样是 Sequence 中的元素类型，但其返回类型为 SegmentOfResult。在函数体的范型定义中，SegmentOfResult 的类型其实就是是 Sequence。 而flatMap 函数返回的类型是 SegmentOfResult.Element 的数组。从函数的返回值来看，与 map 的区别在于 flatMap 会将 Sequence 中的元素进行”降温”，返回的类型会是 Sequence 中元素类型的数组，而 map 返回的这是闭包返回类型T的数组。 compactMap 闭包参数的返回类型为 ElementOfResult?, 而函数返回类型为 [ElementOfResult]。因此，compactMap 会将闭包返回的 Optional 的类型解包并返回解包后的数组。 下面分别从源码角度再看下标准库的具体实现方式： map12345678910111213141516171819202122public func map&lt;T&gt;( _ transform: (Element) throws -&gt; T ) rethrows -&gt; [T] { // underestimatedCount 返回值的大小会略小于或等于当前序列元素的数量 let initialCapacity = underestimatedCount var result = ContiguousArray&lt;T&gt;() // 保留当前序列预估容量的存储空间 result.reserveCapacity(initialCapacity) var iterator = self.makeIterator() // Add elements up to the initial capacity without checking for regrowth. // initialCapacity 会略小于当前序列的数量，因此这一段的遍历可以使用强制解包`interatpr.next()` for _ in 0..&lt;initialCapacity { result.append(try transform(iterator.next()!)) } // Add remaining elements, if any. while let element = iterator.next() { result.append(try transform(element)) } return Array(result) } 在上面 map 的实现中，主要做了以下几件事： 首先根据序列中的 underestimatedCount 和变换的目标类型 T，初始化一个 result 的数组来存放结果。 通过 iterator 遍历序列中的每一个元素，并调用 transform 闭包对元素进行变换。 将把变换后的结果保存结果数组中。 因此，经过 map 变换的 Sequence 就不再是一个简单的序列了，而是一个数组。我们只能对有限序列使用map进行变换。 ContiguousArray 和名字所暗示的不同，它其实是 Swift 中最简单的数组类型。相比标准的数组，它可以有更好的性能表现，而即便没有，也至少可以提供与 Array 相同性能水平的表现。同时也暴露出相同的接口。 flatMap123456789public func flatMap&lt;SegmentOfResult : Sequence&gt;( _ transform: (Element) throws -&gt; SegmentOfResult ) rethrows -&gt; [SegmentOfResult.Element] { var result: [SegmentOfResult.Element] = [] for element in self { result.append(contentsOf: try transform(element)) } return result } 对于 flatMap 的实现，我们可以看出，它做了以下几件事情： 初始化一个名为 result 的新数组，用于存放结果。 遍历自己的元素，对于每个元素，调用闭包的转换函数 transform 进行转换。 将转换的结果，使用 appendContentsOf 方法，将结果放入 result 数组中。 而这个 appendContentsOf 方法，即是把数组中的元素取出来，放入新数组。 compactMap1234567891011121314151617public func compactMap&lt;ElementOfResult&gt;( _ transform: (Element) throws -&gt; ElementOfResult? ) rethrows -&gt; [ElementOfResult] { return try _compactMap(transform) }public func _compactMap&lt;ElementOfResult&gt;( _ transform: (Element) throws -&gt; ElementOfResult? ) rethrows -&gt; [ElementOfResult] { var result: [ElementOfResult] = [] for element in self { if let newElement = try transform(element) { result.append(newElement) } } return result } 而compactMap 的实现则做了以下事情： 构造一个名为 result 的新数组，用于存放结果。 遍历自己的元素，对于每个元素，调用闭包的闭包参数 transform，进行转换。 将转换的结果进行解包，如果有值则使用 append 方法，将结果放入 result 数组中。 所以，该 compactMap 函数可以过滤闭包执行结果为 nil 的情况，仅收集那些转换后非空的结果。 如何选择他们使用的时机呢？ When to use compactMap当转换闭包返回可选值并且你期望得到的结果为非可选值的序列时，使用 compactMap。 compactMap 与 map 的区别参考下面的例子： 1234567let scores = [\"1\", \"2\", \"three\", \"four\", \"5\"]let mapped: [Int?] = scores.map { str in Int(str) }// [1, 2, nil, nil, 5] - Two nil values as \"three\" and \"four\" are strings.let compactMapped: [Int] = scores.compactMap { str in Int(str) }// [1, 2, 5] - The nil values for \"three\" and \"four\" are filtered out. 根据这些不同点，可以归纳出三个函数适用的不同情况，当闭包返回的结果需要是序列类型且期望返回的结果是一维数组时，使用 flatMap, 而需要过滤 transform 结果的可选值时，使用 compactMap。 如： 12345678910111213let arr = [[1, 2, 3], [4, 5]]let result = arr.map { $0 }// [[1, 2, 3], [4, 5]]let result = arr.flatMap { $0 }// [1, 2, 3, 4, 5]let arr = [1, 2, 3, nil, nil, 4, 5]let result = arr.compactMap { $0 }// [1, 2, 3, 4, 5] When to use flatMap当对于序列中元素，转换闭包返回的是序列或者集合时，而你期望得到的结果是一维数组时，使用 flatMap。 12345678let scoresByName = [\"Henk\": [0, 5, 8], \"John\": [2, 5, 8]]let mapped = scoresByName.map { $0.value }// [[0, 5, 8], [2, 5, 8]] - An array of arraysprint(mapped)let flatMapped = scoresByName.flatMap { $0.value }// [0, 5, 8, 2, 5, 8] - flattened to only one array 其实 s.flatMap(transform) 的结果等同于 Array(s.map(transform).joined())。 compactMap vs flatMap当在序列元素上使用转换闭包，且返回值为Optional 类型时，使用 compactMap, 其他情况下 map 与 flatMap 都可以得到你所想要的结果。","link":"/2019/06/13/map-flatMap-compactMap-difference/"},{"title":"Swift 标准库阅读笔记 - Optional","text":"Optional 是 Swift 重要的语言特性之一，通过引入 Optional， 可以很好的判断变量是否存在 nil 值的情况，可以很好的防止出现因为未处理 nil 而带来的程序崩溃问题。 下面让我们通过源码来了解一下 Optional 具体的实现逻辑。 Optional 具体的实现是一个包含 .none 和 .some 两个 case 的 enum。 123456789101112public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral { case none case some(Wrapped) public init(_ some: Wrapped) { self = .some(some) } public init(nilLiteral: ()) { self = .none }} init由于 Optional 是多类型的，因此我们通过 &lt;Wrapped&gt; 来声明范型。 初始化方法init(_ some:) 可以用来初始化一个非 nil 的实例。 而遵守 ExpressibleByNilLiteral 协议则定义了一个初始化方法init(nilLiteral:), 可以使用 nil 初始化一个实例。 map12345678public func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U? { switch self { case .some(let y): return .some(try transform(y)) case .none: return .none }} Optional 类型执行 map 方法时，如果值为 .none 时，直接返回 nil。如果为 .some(Wrapped) 时，返回 .some(transform(Wrapped)), 即仍会返回 Optional 类型，仍需进行解包。 可用如下代码验证：123456789let possibleNumber: Int? = Int(\"42\")let possibleSquare = possibleNumber.map { $0 * $0 }print(possibleSquare)// \"Optional(1764)\"let noNumber: Int? = nillet noSquare = noNumber.map { $0 * $0 }print(noSquare)// \"nil\" flatMap123456789public func flatMap&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U?) rethrows -&gt; U? { switch self { case .some(let y): return try transform(y) case .none: return .none } }} 而在使用 flatMap 时， 如果值为 nil 时，直接返回 nil， 如果不为 nil，会进行解包并执行闭包。需要注意的是，transform 时是解包值，但 return 返回的还是 Optional。 1234567let possibleNumber: Int? = Int(\"42\")let nonOverflowingSquare = possibleNumber.flatMap { x -&gt; Int? in let (result, overflowed) = x.multipliedReportingOverflow(by: x) return overflowed ? nil : result}print(nonOverflowingSquare)// Prints \"Optional(1764)\" UnsafelyUnwrapped123456789public var unsafelyUnwrapped: Wrapped { @inline(__always) get { if let x = self { return x } _debugPreconditionFailure(\"unsafelyUnwrapped of nil optional\") }} unsafelyUnwrapped 和 强制解包符 ! 的功能是相似的，如果为 .none 时会报错。 1234567let possibleNumber: Int? = Int(\"42\")print(possibleNumber.unsafelyUnwrapped)// 42let noNumber: Int? = nilprint(noNumber.unsafelyUnwrapped)// Fatal error: unsafelyUnwrapped of nil optional Nil Coalescing (??)123456789public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T { switch optional { case .some(let value): return value case .none: return try defaultValue() }} 上面就是我们在解包时常用的 ?? 操作符，它强制要求可能为 nil 的变量放在左边， 默认值写在右边。当 Optional为 .none 的时候，则返回 defaultValue 的值。 == &amp; !=1234567891011121314151617181920212223242526public static func ~=(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -&gt; Bool { switch rhs { case .some: return false case .none: return true }}public static func ==(lhs: Wrapped?, rhs: _OptionalNilComparisonType) -&gt; Bool { switch lhs { case .some: return false case .none: return true }}public static func !=(lhs: Wrapped?, rhs: _OptionalNilComparisonType) -&gt; Bool { switch lhs { case .some: return true case .none: return false }} 其中重载的一些操作符，用来比较 Optional 类型与 nil 进行， 即我们进行判空时调用的方法。 _ObjectiveCBridgeable123456789101112131415161718associatedtype _ObjectiveCType : AnyObject /// Convert `self` to Objective-C. func _bridgeToObjectiveC() -&gt; _ObjectiveCType static func _forceBridgeFromObjectiveC( _ source: _ObjectiveCType, result: inout Self? ) @discardableResult static func _conditionallyBridgeFromObjectiveC( _ source: _ObjectiveCType, result: inout Self? ) -&gt; Bool static func _unconditionallyBridgeFromObjectiveC(_ source: _ObjectiveCType?) -&gt; Self 实现的目的主要用来 Swift 跟 Objective C 中类型进行桥接。Swift 的 Array 和 Dictionary 等遵守这个协议的类型可以转换成OC中对应的 NSArray 和 NSDictionary 类型。 上面就是对 Optional 类型的源码分析，可以看出实现十分巧妙，通过 enum 类型的特性便实现了 Optional 所需要的功能。","link":"/2019/06/06/swift-stl-optional/"},{"title":"Swift的派发机制","text":"函数派发就是程序判断使用哪种途径去调用一个函数的机制。了解派发机制对于写出高性能代码来说很有必要，而且也能解释很多 Swift 里”奇怪”的行为。 编译型语言有三种基础的函数派发方式： 直接派发 Direct Dispatch 函数表派发 Table Dispatch 消息机制派发 Message Dispatch 大多数语言都会支持一到两种，Java 默认使用函数表派发，但你可以通过 final 修饰符修改成直接派发。 C++ 默认使用直接派发，但可以加上 virtual 修饰符来改成函数表派发。而 Objective-C 则总是使用消息机制派发，但允许开发者使用C直接派发来获取性能的提高。这样的方式非常好，但也给很多开发者带来了困扰。 1. 派发方式程序派发的目的是为了告诉 CPU 需要被调用的函数在哪里，在我们深入 Swift 派发机制之前，先来了解一下这三种派发方式，以及每种方式在动态性和性能之间的取舍。 直接派发直接派发是最快的，由编译器来决定调用的函数，并且编译器还能够有很大的优化空间，例如函数内联等。直接派发也被称为静态调用。 然而，对于编程来说直接调用也是最大的局限，而且因为缺乏动态性所有没办法支持继承。 函数表派发函数表派发是编译型语言实现动态行为最常见的实现形式。函数表使用了一个数组来存储声明的每一个函数的指针。大部分语言把这个称为 virtual table (虚函数表)， Swift 里称为 witness table.每一个类都会维护一个函数表，里面记录着类所有的函数。如果父类函数被 override 的话，表里面只会保存被 override 之后的函数。一个子类新添加的函数，都会被插入到这个数组的最后。运行时会根据这一个表去决定实际要被调用的函数。 查表是一种简单，易实现，而且性能可预知的方式。然而，这种派发方式比起直接派发还是慢一点。从字节码角度来看，多了两次读和一次跳转，由此带来了性能的损耗。另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化。 函数表基于数组实现，缺点在于函数表无法拓展。子类会在虚函数表的最后插入新的函数，但没有位置可以让 extension 安全地插入函数。 消息机制派发消息机制是调用函数最动态的方式。这种运作方式的关键在于开发者可以在运行时改变函数的行为，不止可以通过 swizzling 来改变，甚至可以用 isa-swizzling 修改对象的继承关系，可以在面向对象的基础上实现自定义派发。 当一个消息被派发，运行时会顺着类的继承关系向上查找应该被调用的函数。如果你觉得这样做效率很低，它确实很低。然而，只要缓存建立了起来，这个查找过程就会通过缓存来把性能提高到和函数表派发一样快。 Swift 的派发机制那么，到底 Swift 是怎么派发的呢？有四个选择具体派发方式的因素存在： 声明的位置 引用类型 特定的行为 显式的优化(Visibilty Optimizations) 在解释这些因素之前，我有必要说清楚，Swift 没有在文档里具体写明什么时候会使用函数表什么时候使用消息机制。唯一的承诺是使用 dynamic 修饰的时候会通过 Objective-C 的运行时进行消息机制派发。 声明的位置在 Swift 里，一个函数有两个可以声明的位置： 类型声明的作用域和 extension。 根据声明类型的不同，也会有不同的派发方式。 1234567class MyClass { func mainMethod() {}}extension MyClass { func extensionMethod() {}} 上面的例子中，mainMethod 会使用函数表派发，而 extensionMethod 则会使用直接派发。 Initial Declaration Extension Value Type Static Static Protocol Table Static Class Table Static NSObject subclass Table Message 这张表格展示了默认情况下 Swift 使用的派发方式。 总结起来这么几点： 值类型总是会使用直接派发，简单易懂 而协议和类的 extension 都会使用直接派发 NSObject 的 extension 会使用消息机制进行派发 NSObject 声明作用域里的函数都会使用函数表进行派发 协议里声明的，并且带有默认实现的函数都会使用函数表进行派发 引用类型引用的类型决定了派发的方式。这很显而易见，但也是决定性的差异，一个比较常见的疑惑，发生在一个协议拓展和类型拓展同时实现了同一个函数的时候。 12345678910111213141516171819202122232425protocol MyProtocol {}struct MyStruct: MyProtocol {}extension MyStruct { func extensionMethod() { print(\"Struct\") }}extension MyProtocol { func extensionMethod() { print(\"Protocol\") }}let myStruct = MyStruct()let myProtocol: MyProtocol = myStructmyStruct.extensionMethod() // \"Struct\"myProtocol.extensionMethod() // \"Protocol\" 引用的类型决定了派发的方式，协议拓展里的函数会使用直接派发方式调用。如果把 extensionMethod 的声明移动到协议的声明位置的话，则会使用函数表派发，最终就会调用结构体里的实现。并且，如果两种声明方式都使用了直接派发的话，基于直接派发的运作方式，我们不可能实现预想的 override 行为。 指定派发方式Swift 有一些修饰符可以指定派发方式。 finalfinal 允许类里面的函数使用直接派发。这个修饰符会让函数失去动态性。任何函数都可以使用这个修饰符，就算是 extension 里本来就是直接派发的函数。这也会让 Objective-C 的运行时获取不到这个函数，不会生成相应的 selector。 dynamicdynamic 可以让类里面的函数使用消息机制派发。 dynamic可以让声明在 extension 里面的函数能够被 override。 dynamic 可以用在所有 NSObject 的子类和 Swift 的原生类。 @objc &amp; @nonobjc@objc 和 @nonobjc 显式的声明了一个函数是否能被 Objective-C 的运行时捕获到。使用 @objc 的典型例子就是给 selector 一个命名空间 @objc(methodName),让这个函数可以被 Objective-C 的运行时调用。 @nonobjc会改变派发的方式，可以用来禁止消息机制派发这个函数，不让这个函数注册到 Objective-C 的运行时里。我不确定这跟 final 有什么区别，因为从使用场景来说也几乎一样，我个人更喜欢final,因为意图更明显。 final @objc可以在标记为 final 的同时, 也使用 @objc 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 perform(selector:) 以及别的 Objective-C 特性, 但在直接调用时又可以有直接派发的性能. @inlineSwift 也支持 @inline, 告诉编译器可以使用直接派发. 有趣的是, dynamic @inline(__always) func dynamicOrDirect() {} 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做. 显式的优化Swift 会尽最大能力去优化函数派发的方式。例如，如果你有一个函数从来没有 override，Swift 就会检查并且在可能得情况下使用直接派发。这个优化大多数情况下都表现得很好，但对于使用了 target/action 模式的 Cocoa 开发者就不那么友好了。 12345678override func viewDidLoad() { super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem( title: \"Sign in\", style: .plain, target: nil, action: #selector(ViewController.signInAction) )}private func signInAction() {} 这里编译器会抛出一个错误: Argument of '#selector' refers to a method that is not exposed to Objective-C (Objective-C 无法获取 #selector 指定的函数). 你如果记得 Swift 会把这个函数优化为直接派发的话, 就能理解这件事情了. 这里修复的方式很简单: 加上 @objc 或者 dynamic 就可以保证 Objective-C 的运行时可以获取到函数了. 这种类型的错误也会发生在 UIAppearance 上, 依赖于 proxy 和 NSInvocation 的代码. 另一个需要注意的是, 如果你没有使用 dynamic 修饰的话, 这个优化会默认让 KVO 失效. 如果一个属性绑定了 KVO 的话, 而这个属性的 getter 和 setter 会被优化为直接派发, 代码依旧可以通过编译, 不过动态生成的 KVO 函数就不会被触发. 2. 如何通过减少动态派发来提高性能使用final关键字修饰肯定不会被重载的声明在上面的文章里，使用 final 可以允许类里面的函数使用直接派发。而 final 关键字可以用在 class, 方法和属性里来标识此声明不可以被 override。 这可以让编译器安全的将其优化为静态派发。 将文件中使用private关键字修饰的声明推断为final。使用 private 关键字修饰的声明只能在当前文件中进行访问。这样编译器可以找到所有潜在的重载声明。任何没有被重载的声明编译器自动的将它推断为final类型并且去除间接的方法调用和属性访问。 使用全局模块优化推断internal声明为final -&gt; whole module Optimization使用internal（如果声明没有使用关键词修饰，默认是 internal ）关键字修饰的声明的作用域仅限于它被声明的模块中。因为Swift通常的将这些文件作为一个独立的模块进行编译，所以编译器不能确定一个internal声明有没有在其他的文件中被重载。然而如果全局模块优化（Whole Module Optimization，关于全局模块优化参看下文的相关名词解释）是打开的那么所有的模块将要在同一时间被一起编译。这样以来编译器就可以为整个模块一起做出推断，将没有被重载的 internal 修饰的声明推断为 final 类型。","link":"/2019/04/06/swift-method-dispathch-mechanism/"},{"title":"Swift 标准库中的 Attributes","text":"在看标准库源码的过程中，出现过很多在平时开发时都没有接触过属性(Attribute)，如 @inline, @usableFromInline, @inlinable, @frozen 等等，今天就来看看这些属性所代表的含义以及其作用是什么。 @inline在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。 以下面的代码为例： 12345678910func calculateAndPrintSomething() { var num = 1 num *= 10 num /= 5 print(\"My number: \\(num)\")}print(\"I'm going to do print some number\")calculateAndPrintSomething()print(\"Done!\") 假设 calculateAndPrintSomething 方法并没有在其它地方被调用，它在这里的作用仅仅是为了让代码看起来更清晰，因此它没有必要出现在编译后的二进制文件中。 通过函数内联，编译器会将函数调用处直接替换为函数体： 1234567//The compiled binary version of the above exampleprint(\"I'm going to do print some number\")var num = 1num *= 10num /= 5print(\"My number: \\(num)\")print(\"Done!\") 根据设置的优化等级，Swift 编译器会自动处理： 当为了更快的编译速度时会倾向使用内联，当为了更优化的编译后二进制文件大小时，编译器会更倾向不适用内联，因为内联会在不同的调用地方造成代码的重复，增加编译后二进制文件的大小。 尽管编译器可以自己决定是否进行内联，但 @inline 可以强制编译器改变内联的行为。它的使用方法有两种： @inline(__always) : 告诉Swift 编译器如果可能，总是内联此方法 @inline(never) : 告诉编译时永远不要内联这个方法 而根据 Apple 工程师的说法，应该避免使用这个属性。尽管这个属性并不限制使用而且在 Swift 的源码中被广泛使用，但它的公共使用还没有官方正式支持。 尽管编译器会根据优化的设置来决定是否内联，但在某些情况下，你可能需要一种方法来手动决策。这时 @inline 就可以帮助到你。 例如，在优化速度时，似乎编译器会对一些内容并不是很短的方法进行内联，从而导致二进制大小增加。在这种情况下，@inline(never) 可用于防止这个，同时保证二进制文件的速度。 另一个更实际的例子是，你可能想防止黑客接触到一个包含某种敏感信息的方法，它是否会使代码变慢或包变大都无关紧要。你肯定会尝试混淆你的代码来使代码更难理解，或者可以选择混淆工具，例如 SwiftShield，但 @inline(__always) 可以轻松实现这一点而同时不会损害你的代码，我将在下面详细介绍了这个例子： 假设我们有一个音乐应用且一些操作只开放给高级用户。 isUserSubscribed(_:) 方法用来验证用户是否订阅并返回一个布尔值。 123456789101112func isUserSubscribed() -&gt; Bool { // 一些复杂的验证逻辑 return true}func play(song: Song) { if isUserSubscribed() { // 如果用户订阅，播放歌曲 } else { // 让用户订阅 }} 这种方式没有什么问题，但如果我们把这个 App 进行反编译并搜索 play(_:) 方法的程序集会发生什么： 如果我是一个黑客试图破解这个 App 的订阅，看看 play(_:) 方法我就知道 isUserSubscribed(_:) 返回的布尔值控制着 App 的订阅。 我现在可以通过查找 isUserSubscribed(_:) 并强制它返回 true 就可以解锁 App 的全部高级内容： 在这种情况下，可能因为该方法在 App 里广泛使用，所以编译器决定不内联它。这种决定就造成了一个安全漏洞，使得 App 能够很容易地被逆向工程破解。 现在看看给 isUserSubscribed(_ :) 添加了 @inline(__always) 后会发生什么： 123456789101112@inline(__always) func isUserSubscribed() -&gt; Bool { // 一些很复杂的验证逻辑 return true}func play(song: Song) { if isUserSubscribed() { // 播放歌曲 } else { // 让用户订阅 }} 同样的 play(_:) 方法里现在不包括对订阅状态的判断。这个方法调用完全被其内部的 “复杂的验证” 所取代，这样反编译后看起来变得更加复杂，订阅也更加难以破解。 好处是，由于每次调用 isUserSubscribed(_:) 都被复杂的验证取代，因此就没有一种方法可以解锁应用程序的整个订阅，黑客现在必须破解每一个进行验证的方法。当然，多处的重复的代码也意味着我们的二进制文件会变得更大。 请注意，使用 @inline(__always) 并不能保证编译器会真正内联你的方法。它的规则是未知的，例如在无法避免动态派发的情况下就无法进行内联。 inlinable给函数、方法、计算属性、下标脚本、便捷初始化器或者析构器的声明中应用这个特性，将这个声明的实现作为模块的公开接口暴露出去。这就允许编译器可以在其它模块中将具体函数调用替换为为这个函数体，即进行内联。inlinable 可以应用于 public 和 internal 类型的声明。 可内联的函数体可以引用任何模块中的 public 声明以及跟相同模块中被标记为 usableFromInline 属性的 internal 声明，但是不可以引用 private 以及 fileprivate 的声明。 这个特性不能应用在内嵌函数或者 fileprivate 和 private 声明中。定义在内联函数内的函数和闭包会隐式地允许内联，尽管它们没有被标记这个特性。 需要注意的是出现这个属性并不强制进行内联或者其它的优化，同时当只有一个模块时也不会有任何优化的效果。 usableFromInline给函数、方法、计算属性、下标脚本、初始化器或者析构器声明添加这个属性，允许其可以不用暴露为模块的接口，而用在同一个模块中声明的可内联的代码里。可以应用在拥有 internal 访问级别的修饰符上。 类似 public 访问级别修饰符，这个特性暴露声明作为模块的公开接口。但与 public 不同的是，尽管声明的符号已经暴露出来, 编译器也不能在模块外的代码中引用 usableFromInline 标记的声明。总之，模块外的代码依旧能通过运行时行为与声明的符号进行沟通。 用 inlinable 标记的声明会隐式地在行内代码可用。尽管不论是 inlinable 还是 usableFromInline 都能应用于 internal 声明，但你同时使用这两个特性是错误的。 @frozenstruct 类型的 @frozen当库作者确定以后永远不需要向结构添加字段时，他们可能会将该类型标记为 @frozen。 这将允许编译器在编译时优化一些本来需要在运行时进行的调用（例如，它可以在没有间接的情况下直接访问字段）。 在使用二进制稳定性模式进行编译时，只要满足以下所有条件，就可以将结构标记为 @frozen： 该结构是ABI-public（参见SE-0193），即 public 或标记为 @usableFromInline。 结构字段类型中提到的每个类，枚举，结构，协议或类型都是ABI-public。 没有字段有观察访问者（willSet 或 didSet）。 如果字段具有初始值，则计算初始值的表达式不引用任何不是ABI-public的类型或函数。 标记一个 struct 为 @frozen 仅保证其存储的实例属性不会更改。这允许编译器执行某些优化，例如忽略从未访问过的属性，或者从同一实例属性中消除冗余负载。但是，它没有提供 C struct 可能的一些其他保证： 它不能保证 “trivial”（在 C++ 意义上）。包含类引用或闭包的冻结结构在复制时以及超出范围时仍需要引用计数。 它不一定具有已知的大小或对齐方式。范型冻结 struct 的布局可能取决于运行时提供的泛型参数。 即使是具体的实例化也可能没有已知的大小或对齐方式。具有非冻结字段的冻结 struct 在运行时之前可能不知道具体大小。 不保证使用与 C struct 使用相同的布局。如果需要这样的 struct，则应该在 C 头中定义它并导入到 Swift 中。 这些字段不保证按声明顺序排列。编译器可以选择对字段重新排序，例如在满足对齐要求的同时最小化填充。 也就是说，允许编译器使用 struct 内容和布局的知识来导出任何这些属性。但是，基于此在语言级别并不支持，但有两个例外： 具有单个字段的结构的运行时内存布局总是与实例属性的布局相同，无论结构是否声明为 @frozen。从Swift 1开始就是如此。（但是这并没有扩展到调用约定。如果结构没有被冻结，它将被间接传递，即使它的单个字段被冻结，因此可以直接传递） 在 C / Objective-C 中 “可空” 的任何类型的 nil 表示与这些语言中 nil 或 NULL 的表示相同。这包括类引用，类绑定协议引用，类类型引用，不安全指针，@convention(c)函数，@convention(block) 函数，OpaquePointer，Selector 和 NSZone。自Swift 3（SE-0055）以来，情况确实如此。 enum 类型的 @frozen将枚举标记为 @frozen 将同样允许编译器优化运行时调用。 此外，将枚举标记为 @frozen 会恢复库的使用者在没有 @unknown 默认值的情况下彻底切换该枚举的能力，因为它保证不会添加其他 case。 一旦被冻结，对枚举 case 所做的所有更改都会影响其ABI。 @discardableResult默认情况下，如果调用一个函数，但函数的返回值并未使用，那么编译器会发出警告。你可以通过给函数使用 @discardableResult 来忽略警告。 @_transparent@_transnsparent 与 @inlinable 类似，告诉编译器在需要的时候可以将声明的函数内联。 这样做有几个后果： 任何对标记为 @_transparent 的函数的调用都必须内联，即使在 -Onone 下也是如此。 因此，@_transparent 函数是隐式可内联的，因为更改其实现很可能不会影响现有编译二进制文件中的调用者。 一个 public 的或 @usableFromInline @_transparent 函数必须只引用公共符号，并且不得根据其所在模块的认知进行优化。[前者由Sema中的检查捕获。] 调试信息当单步调试执行调用函数时，将跳过内联的操作。 这就是 @_transparent 的意思。 你什么时候应该使用 @_transparent？ 这个函数实现的功能是否需要改变？如果是的话那么你不可以允许它进行内联。 实现是否需要调用私有属性，包括 private 函数以及可能在下一个版本中消失的 internal 函数？ 那么你不能允许它内联。 如果函数不进行内联的话可以吗？如果你更希望这个函数是内联的话，那么你应该使用 @inlinable，而不是 @_transparent。（如果你真的需要这个，你也可以添加 @inline（__ always）。） 如果函数在 -Onone 模式下都可以内联的话是个问题吗？ 那么与前一种情况类似。相信编译器。 如果您无法单步执行这个被内联的函数，是否会有问题？ 如果是，那么你想要的不是 @_transparent， 你只是需要 @inline(__always)（也可能是 @inlinable，用于跨模块内联）。 如果在所有数据流诊断之后发生内联，是否可以？如果可以，那么同上，只需要 @inline(__always)即可。 如果你能做到这些，那么听起来 @_transparent 是正确的选择。 与其他注解的交互 如上所述，将 @_transparent 放在 public 或 @usableFromInline 的函数上会将其主体暴露给其他模块。没有必要另外包括 @inlinable。 但是，与 @inlinable 不同，@_transnsparent 并不意味着 @usableFromInline。可以将标记为 @_transparent 的函数仅用于当前模块，甚至是当前文件。 目前实现的限制 在非单前端模式下编译时，不会为主文件（对于每个前端调用）中的任何函数生成 SIL，包括 @inline(__always) 和 @_transparent 函数，这意味着它们不会被内联。这在语义上是一个错误。 rdar://problem/15366167 _semantics()我们使用 @_semantics 属性来标注标准库中的代码。高级 SIL 优化器可以使用这些注释来执行特定域的优化。相同的函数可能具有多个 @_semantics 属性。 这是 @_semantics 属性的一个示例： 1234@public @_semantics(\"array.count\")func getCount() -&gt; Int { return _buffer.count} 在此示例中，我们使用标记 array.count 注释 Swift 数组结构的成员。此标记通知优化器此方法读取数组的大小。 @_semantics 属性允许我们定义在 Swift 代码中实现 “内置” SIL 级操作。在 SIL 代码中，它们被编码为应用指令，但优化器可以作为原子指令对它们进行操作。语义注释不一定需要在公共API上。例如，Array下标运算符可以在语义模型中调用两个操作。一个用于检查边界，另一个用于访问元素。通过这种抽象，优化器可以删除 checkSubscript 指令并保留 getElement 指令： 12345678910111213@public subscript(index: Int) -&gt; Element { get { checkSubscript(index) return getElement(index) }@_semantics(\"array.check_subscript\") func checkSubscript(_ index: Int) { ...}@_semantics(\"array.get_element\") func getElement(_ index: Int) -&gt; Element { return _buffer[index]} Swift优化器可以访问 @_semantics 属性提供的信息以执行高级优化。在优化流水线的早期阶段，优化器不会使用特殊语义内联函数，以便允许早期的高级优化传递对它们进行操作。在优化流水线的后期阶段，优化器使用特殊语义内联函数以允许低级优化。 References The Forbidden @inline Attribute in Swift [swift-users] inline best practices? TransparentAttr Attributes Cross-module inlining and specialization Library Evolution for Stable ABIs","link":"/2019/06/19/swift-stl-attributes/"},{"title":"关于 SwiftUI 的初步认识","text":"SwiftUI 可以在任何 Apple 的平台上用新颖的方式声明用户界面，更简洁快速的创建应用。通过几天的使用，大概对 SwiftUI 有了简单的认识, 下面将简单介绍下 SwiftUI 的特点与使用实例。 Overview声明式的语法声明式编程（Declarative programming）是一种编程范式，与命令式编程相对立。 它描述目标的性质，让计算机明白目标，而非流程。 声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。 而命令式编程则需要用算法来明确的指出每一步该怎么做。 SwiftUI 使用了声明式的语法，所以开发者能够十分轻易地描述用户界面应该做什么。例如，编写需要包含文本字段的项目列表时，开发者可以用代码描述每个字段的对齐方式、字体和颜色。代码也比以前更简单，更易于阅读。而 SwiftUI 会根据状态的变化来重新渲染相匹配的视图。 123456789101112List(landmarks) { landmark in HStack { Image(landmark.thumbnail) Text(landmark.name) Spacer() if landmark.isFavorite { Image(systemName: \"star.fill\") .foregroundColor(.yellow) } }} 可重用的组件复杂的界面是由轻量的单一职责的视图构成的。你可以轻易的创建自定义视图在 Apple 的各个平台中共享使用，达到重用的目的。 12345678910struct FeatureCard: View { var landmark: Landmark var body: some View { landmark.featureImage .resizable() .aspectRatio(3/2, contentMode: .fit) .overlay(TextOverlay(landmark)) }} 简洁的动画使用只需要添加一个简单的方法调用就可以创建平滑的动画。 SwiftUI 会在需要的时候自动的计算并设置过场动画。 12345678VStack { Badge() .frame(width: 300, height: 300) .animation(.basic()) Text(name) .font(.title) .animation(Animation.basic().delay(0.2))} Xcode 中实时预览不用运行应用就可以设计，构建和测试你的应用，通过互动预览就可以测试控件以及布局。 看完了上述 SwiftUI 的特点，现在让我们深入了解下它是如何工作的。 什么是 View在 SwiftUI 中，View 跟我们之前用到的 UIView 多少有点类似，但有两个大的不同点是： View 是协议类型，代表了屏幕上元素的描述。 只能返回一个需要渲染的视图。视图可以内部包含其它多个视图，但是只能返回其父视图。 SwiftUI 使用的具体实例： 12345struct ContentView: View { var body: some View { Text(\"Hello World\") }} 也许你也注意到了例子中 body 的返回值类型 some View, 让我们具体看看 View 协议的定义来理解这么做的原因。 1234public protocol View : _View { associatedtype Body : View var body: Self.Body { get }} 这种带有 Self 或者 associatedtype 的 protocol 不能作为类型来使用，只能作为类型约束来使用。这样的话我们就不能这样写： 12345struct ContentView: View { var body: View { Text(\"Hello World\") }} 而在 Swift 5.1 新增加的特性中，Opaque Result Type 为 protocol 作为返回类型提供以下能力： 语法上隐藏具体实现 强类型，类型参数不丢失 允许带有 Self 或者 associatedtype 的 protocol 作为返回类型 在 Swift 5.1 中，将返回类型改成 some protocol 的形式, 它向编译器做出保证，每次 body 得到的一定是某一个确定的，遵守 View 协议的类型，而编译器可以自己推断出具体类型。 在协议之前加上 some 后，返回值的类型就对编译器就变成透明的了。 而且，编译器会检查返回类型是否确定单一，因此下面这种方式也是不行的： 1234567891011struct ContentView: View { var body: View { if somecondition { return Text(\"Hello World\") } else { return Button(action: {}) { Text(\"Tap me\") } } }} 视图容器VStack / HStack / ZStack当需要渲染多个视图时，我们可以将多个视图组合在 HStack, ZStack，ZStack 或者 Group 这种视图容器中。 12345678910111213struct HeaderView: View { let image: UIImage let title: String let subtitle: String var body: some View { VStack { Image(uiImage: image) Text(title) Text(subtitle) } }} 这里调用了 VStack 的初始化方法：1234567public struct VStack&lt;Content : View&gt; : View { public init( alignment: HorizontalAlignment = .center, spacing: Length? = nil, @ViewBuilder content: () -&gt; Content ) } 初始化方法接收传入的 alignment 和 spacing 参数来控制容器内视图的排列\u001b和间距，同时接收一个尾随闭包 () -&gt; Content 来控制容器视图的具体内容。 你可能也注意到闭包参数是由 @ViewBuilder 修饰的，这里就需要提下 Swift 5.1 的 function builder 特性。 function builder 允许使用闭包实现 Builder 模式，通过将此闭包中定义的表达式传递给构建器类型，提供类似 DSL 的开发体验。而如果没有 function builder 这个功能，我们必须手动创建构建器，以便构建像 VStack 这样的容器实例，为我们提供看起来像这样的代码： 12345678910111213struct HeaderView: View { let image: UIImage let title: String let subtitle: String var body: some View { var builder = VStackBuilder() builder.add(Image(uiImage: image)) builder.add(Text(title)) builder.add(Text(subtitle)) return builder.build() }} 那么 function builder 是如何工作的？这一切都始于新的 @functionBuilder 属性（或当前版本的 Xcode beta 中的 @_functionBuilder，因为此功能仍被视为私有实现） - 它将给定类型标记为构建器。 构建器声明 buildBlock 方法的不同重载，以便为包含各种表达式的闭包提供支持。例如，这里是 SwiftUI 自己的 ViewBuilder 类型的实现，其中有很多接受不同个数参数的 buildBlock 方法，它们将负责将闭包中一一列举的 Text 和其他可能的 View 转换为一个 TupleView 并返回。 1234567891011121314151617181920212223@functionBuilderstruct ViewBuilder { // Build a value from an empty closure, resulting in an // empty view in this case: func buildBlock() -&gt; EmptyView { return EmptyView() } // Build a single view from a closure that contains a single // view expression: func buildBlock&lt;V: View&gt;(_ view: V) -&gt; some View { return view } // Build a combining TupleView from a closure that contains // two view expressions: func buildBlock&lt;A: View, B: View&gt;(_ viewA: A, viewB: B) -&gt; some View { return TupleView((viewA, viewB)) } // And so on, and so forth. ...} 注意上面的构建器如何显式处理每个闭包变体，因为我们可能在同一个闭包中处理不同种类的 View 实现。如果不是这样，ViewBuilder 可能会使用一个可变参数来处理包含多个表达式的闭包: 123456@functionBuilderstruct ViewBuilder { func buildBlock(_ views: View...) -&gt; CombinedView { return CombinedView(views: views) }} 上面的代码只是一个例子，它甚至不会编译，因为 View 有一个关联类型。 使用上面的 ViewBuilder 类型，编译器现在将合成一个与其名称匹配的属性（@ViewBuilder） - 然后我们可以使用它来标记我们希望使用新构建器的所有闭包参数： 123456789struct VStack&lt;Content: View&gt;: View { init(@ViewBuilder builder: () -&gt; Content) { // A function builder closure can be called just like // any other, and the resulting expression can then be // used to, for instance, construct a container view. let content = builder() ... }} 除了按顺序接受和构建 View 的 buildBlock 以外，ViewBuilder 还实现了两个特殊的方法： buildEither 和 buildIf 。它们分别对应 block 中的 if...else... 语法和 if 的语法。 12345static func buildEither&lt;TrueContent, FalseContent&gt;(first: TrueContent) -&gt; ConditionalContent&lt;TrueContent, FalseContent&gt;static func buildEither&lt;TrueContent, FalseContent&gt;(second: FalseContent) -&gt; ConditionalContent&lt;TrueContent, FalseContent&gt; 也就是说，你可以在 VStack 中这样写：12345678910111213var someCondition: BoolVStack(alignment: .leading) { Text(\"Turtle Rock\") .font(.title) Text(\"Joshua Tree National Park\") .font(.subheadline) if someCondition { Text(\"Condition\") } else { Text(\"Not Condition\") }} 其他的命令式的代码在 VStack 的 content 闭包里是不被接受的，下面这样也不行： 123456789VStack(alignment: .leading) { // let 语句无法通过 function builder 创建合适的输出 let someCondition = model.condition if someCondition { Text(\"Condition\") } else { Text(\"Not Condition\") }} 到目前为止，只有以下三种写法能被接受： 结果为 View 的语句 if 语句 if...else... 语句 列表 List静态列表123456var body: some View { List { LandmarkRow(landmark: [landmarkData[0]]) LandmarkRow(landmark: [landmarkData[1]]) }} 这里的 List 和 HStack 或者 VStack 之类的容器类似，接受一个 view builder 并采用 View DSL 的方式列举了两个 L\u001fandmarkRow。 动态列表12345var body: some View { List(landmarkData.identified(by: \\.id)) { landmark in LandmarkRow(landmark: landmark) }} List 同样也可以接受动态方式的输入，这时使用的初始化方法和上面静态的不一样： 123456789101112public struct List&lt;Selection, Content&gt; where Selection : SelectionManager, Content : View { public init&lt;Data, RowContent&gt;( _ data: Data, action: @escaping (Data.Element.IdentifiedValue) -&gt; Void, rowContent: @escaping (Data.Element.IdentifiedValue) -&gt; RowContent) where Content == ForEach&lt;Data, Button&lt;HStack&lt;RowContent&gt;&gt;&gt;, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable //...} 初始化方法接受三个参数： data 类型要求为：Data : RandomAccessCollection，即要求参数类型为 Array action 类型为接收 IdentifiedValue 类型参数的闭包，用来指定列表项对应的点击时间。 rowContent 用来接受控制列表项内容的闭包。rowContent 其实也是被 @ViewBuilder 标记的，因此你也可以把 LandmarkRow 的内容展开写进去。不过一般我们会更希望尽可能拆小 UI 部件，而不是把东西堆在一起。 而 Data.Element : Identifiable 则是要求 Data.Element(即 Array 中的元素类型) 中存在一个可以辨别出某个实例的且满足 Hashable 的 id。这个 id 将在数据变更时快速定位到变化的数据所对应的 cell，并进行局部的 UI 刷新。 删除列表项SwiftUI 对于列表滑动删除提供了很简便的接口 onDelete(perform:), 同时需要一个具有能接受要删除多个索引参数的方法: 1func delete(at offsets: IndexSet) 在这个函数中你可以循环遍历集合中的每个索引，或者只读取第一个。由于 SwiftUI 正在观察列表的状态，因此你所做的任何更改都将自动反映在您的UI中。 以下代码将创建一个包含三个项目列表的 ContentView 结构，然后附加一个 onDelete(perform:) 用于删除列表中的任何项目： 1234567891011121314151617181920struct ContentView : View { @State var users = [\"Paul\", \"Taylor\", \"Adele\"] var body: some View { NavigationView { List { ForEach(users.identified(by: \\.self)) { user in Text(user) } .onDelete(perform: delete) } } } func delete(at offsets: IndexSet) { if let first = offsets.first { users.remove(at: first) } }} 移动列表项同样的我们也可以通过 onMove(perform:) 来处理列表项的移动。而移动的操作需要一个能接受源 IndexSet 和 目标 Int 的参数。 1func move(from source: IndexSet, to destination: Int) 移动多个项目时，最好先移动后面的项目，这样就可以避免移动其他项目且索引混淆。 我们可以创建一个 ContentView 结构来设置一个包含三个用户名字符串的数组，并要求SwiftUI 调用 move() 方法来移动它们。 1234567891011121314151617181920212223242526struct ContentView : View { @State var users = [\"Paul\", \"Taylor\", \"Adele\"] var body: some View { NavigationView { List { ForEach(users.identified(by: \\.self)) { user in Text(user) } .onMove(perform: move) } .navigationBarItems(trailing: EditButton()) } } func move(from source: IndexSet, to destination: Int) { // sort the indexes low to high let reversedSource = source.sorted() // then loop from the back to avoid reordering problems for index in reversedSource.reversed() { // for each item, remove it and insert it at the destination users.insert(users.remove(at: index), at: destination) } }} 列表分组SwiftUI 的列表视图内置了 section 和 section header 的支持，就像 UIKit 中的UITableView 一样。要在某些单元格周围添加一个 section，首先在其周围放置一个 Section，也可以添加 header 和 footer。 举个例子，这里有个用于在提醒应用中显示任务数据的 View： 12345struct TaskRow: View { var body: some View { Text(\"Task data goes here\") }} 我们要做的是创建一个包含两个部分的列表视图：一个用于重要任务，一个用于不太重要的任务。 1234567891011121314151617struct ContentView : View { var body: some View { List { Section(header: Text(\"Important tasks\")) { TaskRow() TaskRow() TaskRow() } Section(header: Text(\"Other tasks\")) { TaskRow() TaskRow() TaskRow() } } }} 我们同样也可以像这样给 section 添加 footer：12345Section(header: Text(\"Other tasks\"), footer: Text(\"End\")) { TaskRow() TaskRow() TaskRow()} Group 样式跟 UITableView 一样，SwiftUI的列表支持分组以及简单样式。默认为普通样式，但如果要更改为分组，则应在列表中使用 .listStyle(.grouped) 修饰符。 1234567891011121314151617struct ExampleRow: View { var body: some View { Text(\"Example Row\") }}struct ContentView : View { var body: some View { List { Section(header: Text(\"Examples\")) { ExampleRow() ExampleRow() ExampleRow() } }.listStyle(.grouped) }} 以上就是对 SwiftUI 简单的认识，还有些动态绑定的总结会放在下一篇中。","link":"/2019/06/24/ios-swiftui-first-look/"},{"title":"Using Collections Effectively","text":"Swift 提供了Array, Set, Dictionary 三种基本的集合类型用来存储数据。Array是有序数据的集合，Set是无序无重复数据的集合，Dictionary是无序的键值对的集合。 集合非常普遍并且共享非常多的常见特性和算法，因为在Swift中它们都遵守一个通用协议Collection。在Swift中，集合就是序列，其中的元素可以以非破坏性的方式多次遍历，并且其元素可以通过下标访问。 这可能是一个在连续内存中定义的数组，哈希表，红黑树，链表或者你可以想象的任何其他东西。作为集合它们都支持起始索引（startIndex）和结束索引（endIndex），可以用来访问集合的初始元素和用来标识集合的结束。集合支持从其startIndex到endIndex直接遍历元素，同时也支持使用下标（subscript[index]）来获取集合中的元素。 Collection 集合集合的定义1234567891011121314151617181920protocol Collection : Sequence { // 集合中元素的类型 associatedtype Element // 索引类型, 需要遵守Comparable协议 associatedtype Index : Comparable // 遍历时所用到的方法了, 即通过索引查询到对应的元素 subscript(position: Index) -&gt; Element { get } // 开始索引 var startIndex: Index { get } // 结束索引 var endIndex: Index { get } // 通过一个索引, 获取它后面的索引 func index(after i: Index) -&gt; Index } 这里用到了associatedtype关键字, 在Swift协议定义的时候, 会看到使用这个关键字, 你可以认为这是一个占位符, 具体的类型直到被用到的时候才会确定. 但是有时候我们需要规定这个占位符要有一些能力, 比如这里的Index, 他就需要遵守Comparable协议. 集合协议的扩展 通过遵守Collection协议，你可以访问集合中各种丰富的功能, 有一些我们常用的first, last，isEmpty,count等属性，以及dropFirst，dropLast,reversed，split等函数以及一些map，filter之类的高阶函数。 我们也可以通过自定义一些协议扩展来实现更加强大的功能。 如隔元素遍历的功能： 12345678910111213141516171819202122extension Collection { // 扩展集合协议 func everyOther(_ body: (Element) -&gt; Void) { // 获取首元素索引 let start = self.startIndex // 获取末尾元素索引 let end = self.endIndex var iter = start // 未走到末尾 while iter != end { // 执行外部的闭包 body(self[iter]) // 获取当前元素的下一个索引 let next = index(after: iter) // 检查索引是否走到末尾 if next == end { break } // 将当前索引指向next的下一个 iter = index(after: next) } } } (1...10).everyOther { print($0) } 集合的继承结构 除了强大的Collection本身，Swift中还有其他很多继承自Collection的协议。 BidirectionalCollection 双向集合，可以向前访问元素 RandomAccessCollection 随机访问集合，提供了复杂度O(1)的访问方法，因为继承自BidirectionalCollection,也可以向前向后访问元素 MutableCollection 可变集合，提供了修改集合元素的能力 RangeReplaceableCollection 范围替换集合，可以通过指定范围替换元素 Indces 索引集合可以通过索引的方式来访问其中的元素，其中 每个集合都有自己的索引 索引必须满足Comparable 将索引作为不透明的类型(索引可能是正数，也可能是其他类型) 如何访问第一个元素通过下标进行直接访问使用array[0]访问第一个元素, 当然没有问题, 可是如果我们扩展开来, 如果给的集合不是数组, 而是一个set, 那么, 这样的方式就行不通了. 通过索引进行访问使用set[set.startIndex]进行访问, 这样就可以了。 这个方法普遍适用于其他集合类型，如array[array.startIndex] 但是, 你同样需要注意一些潜在的问题, 如需要判空, 需要判断越界, 诸如此类 first我们可以使用set.first进行获取. 而且不用担心那些潜在的问题 如何访问集合的第二个元素我们可以通过向集合来添加一个新属性来实现 显然我们不能通过这两种方式来进行获取，因为我们之前说过，Collection的索引类型并不一定是Int，而是一个遵守Comparable协议的类型。 Slice 切片切片是仅描述集合一部分元素的类型，每个切片都有自己的起始和结束索引，并且切片与其原始集合分开存在。切片不占用额外的存储空间，只是引用原始集合，因此非常高效。当使用切片下标时，它将读出原始缓冲区中的数据，切片能这么做的原因是因为它与其原始集合共享同样的索引。 通过切片，我们可以更优雅的实现访问第二个元素的功能。 我们去掉首元素，然后再获取新得到的集合的第一个元素就可以实现了。 切片与源集合共享索引 每个类型都可以自由定义自己的切片类型 内存问题值得注意的是, 持有切片, 将使得即便将原来的集合置空, 内存也不会释放。切片是一个 原有集合 + 映射关系 的产物. 所以, 除非将切片也置空, 否则, 原有集合并不会被释放. 1234567891011121314151617extension Array { var firstHalf: ArraySlice&lt;Element&gt; { return self.dropLast(self.count / 2) }}var array = [1, 2, 3, 4, 5, 6, 7, 8]var firstHalf = array.firstHalf // [1, 2, 3, 4]// 将数组设置为空array = []print(firstHalf.first!) // 1let copy = Array(firstHalf) // [1, 2, 3, 4]// 将切片置为空firstHalf = []print(copy.first!) // 1 在这里，只有将源数组array设置为空且将切片firstHalf也设置为空之后，底层的存储才会真正消失。 过程如下 切片的工作方式有点像延迟拷贝，可以选择何时自己创建元素的副本，事实证明这种”懒”行为和延迟做某事的概念，在其他情况下也非常有用。 一种情况是函数调用。 Lazy Function默认情况下，Swift中的函数是”Eager(急切)”的，也就是说它们接收了输入并按照要求返回输出。 经过这样的一套操作, 我们计算了4004个元素, 如果我们后面还有一些其他的操作, 更糟糕的是, 如果我们最终只是取取first, 这样, 前面生成的那些元素, 都成为了浪费. 我们可以通过lazy关键字来规避这样的浪费。可以看到, 使用lazy后, 刚才的遍历过程, 变成了组织一个新集合的过程, 只有在first进行计算的时候，才进行计算。 使用lazy时如何避免重复计算的过程 lazy的目的是只根据需要进行计算，但它避免的另一件事是创建中间存储。 何时使用 Lazy 链式计算 只需要结果中的一部分 没有其他副作用 No side effects 避免跨越API边界时 MutableCollection当尝试修改集合时，使用了失效的索引： 如何避免 在持有索引和切片时, 处理要谨慎 集合发生改变时, 要更新索引后再使用 在需要索引和切片的情况下才对其进行计算 多线程访问 如何避免 隔离数据使其只能被单个线程访问 实现适当形式的互斥，如串行调度队列或锁 使用Thread Sanitizer来检查 建议首选不可变集合来避免之前提到的问题 如果可以避免，就不要使用可变集合 可以使用切片和lazy操作符来模拟想要执行的改变 当尝试修改不可变集合石，编译器会提示你 如果可以, 尽量使用带capacity的初始化函数去初始化你的集合, 因为这样节省一些不必要的内存开销, 虽然这并不能节省多少, 但是想象你的项目中有成千上万个集合对象, 他们可以省出一个相当可观的内存数量. Foundation Collection引用类型的集合： 值类型和引用类型 对于值类型来说, 这样有什么好处呢? 因为在现代CPU在设计的时候, 采用了缓存机制, 可以快速的访问连续区域的地址. 而值类型的这种操作, 各个元素之间的内存是相连的, 而引用类型的则不是. 在Swift中使用Foundation集合时，通过桥接的方式将Objective-C中的API以Swift原生的值类型。桥接使我们可以在两种不同的运行时表示之间进行转换。尽管已经对Swift和Objective-C之间的桥接进行了优化，但是两种语言之间桥接时总会产生一些开销。 当在语言之间桥接时，必须先建立新的对等的存储空间，然后需要逐个元素的在它们之间进行转换。当桥接发生在两种语言的边界时，称之为”Eager”桥接，当集合中元素也需要桥接时，集合本身将总是进行”Eager”桥接，这种情况最常出现在以字符串作为键的字典中。当集合桥接并不急切时，我们称之为’lazy’桥接。当集合元素的类型并不需要桥接时，就会发生这种情况，比如NSView，在这种情况下，桥接将会被推迟到首次使用该集合时。 发生桥接的地方和所需开销： 这里的桥接发生在 NSMutableAttributedString取string上, return bridge. 需要传入一个NSString, 参数类型桥接 param bridge 其中 “Brown” 这里也会有一个小的桥接，这里的”Brown”是一个Swift值类型的字符串，每当我们调用NSString的range(of:)时，实际上会把这个字符串桥接回NSString。 建议什么时候应该使用Foundation Collection？ 现在我们对Swift中强大的集合世界的探索已经接近尾声，希望你能够使用这种新视角来检视你现在使用集合的方式，寻找可以通过更有效地使用索引和切片来改进代码的地方，寻找可以通过惰性或者调整桥接方式而受益的地方，用ThreadSanitizer辅助审查可变状态。并通过应用今天讨论的所有概念在自己的App或者Playground中进一步锻炼你对集合的掌握.","link":"/2019/04/16/using-collections-effectively/"},{"title":"Swift 5.1 新特性","text":"跟 Swift 5.0 一样， 5.1 的一个重要特性就是模块的稳定性，这使我们可以使用第三方库的同时无需担心它们使用的 Swift 编译器版本。这听起来类似我们在 Swift 5.0 版本中获得的 ABI 稳定性，但是有一个细微的差别： ABI 稳定性解决了 Swift 的运行时差异，而模块稳定性解决了编译时的差异。 除了这个重要的里程碑之外，我们还获得了许多重要的语言的改进，在本文中，我就介绍它们并提供代码示例，以便你可以看到它们的运行情况。 PS: 如果你错过了 Swift 5.1 的所有新功能，请从这里开始： Swift 5.0 中的新功能 对成员逐一构造器的大量改进 SE-0242 对 Swift 最常用的功能之一进行了重大改进：结构体的成员构造器。 在之前版本的 Swift 中，会自动创建一个成员构造器来接受与结构属性匹配的参数，如下所示： 123456struct User { var name: String var loginCount: Int = 0}let piper = User(name: \"Piper Chapman\", loginCount: 0) 成员构造器在 Swift 5.1 中得到了增强，因此成员构造器对具有默认参数值的属性使用默认参数值。在 User 结构体中，我们给 loginCount 一个默认值 0，这意味着我们可以指定它或将它留给成员初始化器： 12let gloria = User(name: \"Gloria Mendoza\", loginCount: 0)let suzanne = User(name: \"Suzanne Warren\") 这让我们避免重复代码，这总是受欢迎的。 单表达式函数的隐式返回 SE-0255 删除了语言中一个小而重要的不一致性： 有返回值的单表达式函数现在可以删除 return 关键字， Swift 将隐式理解它。 在以前版本的 Swift 中，有返回值的单行闭包可以省略 return 关键字，因为闭包里唯一的代码行必须是返回值的代码。所以，这两段代码是相同的： 12let doubled1 = [1, 2, 3].map { $0 * 2 }let doubled2 = [1, 2, 3].map { return $0 * 2 } 在 Swift 5.1 中，这种行为现在已经扩展到函数： 如果它们包含单个表达式 - 实际上是一段值计算的代码，那么你可以省略 return 关键字，如下所示： 123func double(_ number: Int) -&gt; Int { number * 2} 这可能会让一些人一开始多看一眼，但我相信随着时间的推移会更习惯这种写法。 全局的 Self SE-0068 扩展了 Swift 对 Self 的使用，以便在类，结构体和枚举中使用时引用包含类型。这对于那些需要在运行时确定确切类型的动态类型特别有用。 例如，请考虑以下代码： 123456789class NetworkManager { class var maximumActiveRequests: Int { return 4 } func printDebugData() { print(\"Maximum network requests: \\(NetworkManager.maximumActiveRequests).\") }} NetworkManager 声明了的静态 maximumActiveRequests 属性，并添加了 printDebugData() 方法来打印静态属性。现在工作正常，但是当 NetworkManager 被子类化时，事情就变得更复杂： 12345class ThrottledNetworkManager: NetworkManager { override class var maximumActiveRequests: Int { return 1 }} 该子类更改了 maximumActiveRequests, 以便一次只允许一个请求，但如果我们调用 printDebugData()，它将从其父类打印出该值： 12let manager = ThrottledNetworkManager()manager.printDebugData() 这应该打印出1而不是4，这就是 SE-0068 带来的改变：我们现在可以使用 Self 来引用当前类型。所以，我们可以将 printDebugData() 重写为： 123456789class ImprovedNetworkManager { class var maximumActiveRequests: Int { return 4 } func printDebugData() { print(\"Maximum network requests: \\(Self.maximumActiveRequests).\") }} 这意味着 Self 的工作方式与在早期 Swift 版本中的协议相同。 不透明返回类型 SE-0244 将不透明类型的概念引入 Swift。不透明类型是指我们被告知对象的功能而不知道对象具体是什么类型。 乍一看，这听起来很像是协议，但不透明的返回类型更进一步的采用了协议的概念，因为他们能够与关联类型进行合作，它们每次都需要在内部使用相同的类型，并且允许我们隐藏实现细节。 举个例子，如果我们想从 Rebel 基地发射不同种类的战士，我们可以会编写如下代码： 12345678protocol Fighter { }struct XWing: Fighter { }func launchFighter() -&gt; Fighter { return XWing()}let red5 = launchFighter() 无论谁调用该功能都知道它将返回某种 Fighter，但不知道具体是什么。因此，我们可以添加 struct YWing: Fighter {} 或其他类型，并返回其中任何类型。 但是有一个问题：如果我们想检查一个特定的战斗机是否是 Red 5 怎么办？你可能认为解决方法是使 Fighter 符合 Equatable 协议，因此我们可以使用 ==。但是，只要你这样做，Swift 就会为 launchFighter 函数抛出一个特别可怕的错误： “Protocol Fighter can only be used as a generic constraint because it has Self or associated type requirements.”。 这里打击我们的就是这个错误的 Self 部分。Equatable 协议必须比较它自身(Self)的两个实例以查看它们是否相同，但是 Swift 不能保证两个相等的东西是远程相同的 - 比如我们可能将一个 Fighter 与一个整数数组进行比较。 不透明类型解决了这个问题，因为即使我们只看到正在使用的协议，Swift 编译器内部确切知道该协议实际解析的内容 - 它知道他是一个 XWing，一个字符串数组，或者其他什么。 要返回不透明类型，需要在协议名称前使用关键字 some: 123func launchOpaqueFighter() -&gt; some Fighter { return XWing()} 从调用者的角度来看，仍然可以获得 Fighter，这可能是 XWing，YWing 或其他符合 Fighter 协议的对象。但是从编译器的角度来看，它确切的知道返回的内容，因此它可以确保我们正确的遵循所有的规则。 例如，考虑一个返回 some Equatable 的函数 123func makeInt() -&gt; some Equatable { Int.random(in: 1...10)} 当我们调用它时，我们所知道的是它是某种 Equatable 值, 但是如果调用它两次，那么我们就可以比较这两个调用的结果，因为 Swift 肯定知道他将是相同的底层类型。 123let int1 = makeInt()let int2 = makeInt()print(int1 == int2) 如果我们有第二个返回一些 Equatable 的函数，则不是这样，如下所示：123func makeString() -&gt; some Equatable { \"Red\"} 从我们的角度来看，即使都返回了 Equatable 类型，我们可以比较两次调用 makeString() 的结果或两次调用 makeInt() 的结果，但 Swift 不会让我们将 makeString() 的返回值与 makeInt() 的返回值进行比较，因为它知道比较一个字符串和一个整数没有任何意义。 这里一个重要的条件是具有不透明返回类型的函数必须始终返回一个特定类型。 例如，如果我们尝试使用 Bool.random() 随机启动 XWing 或 YWing， 那么 Swift 将拒绝构建我们的代码，因为编译器无法再区别将要返回的类型。 你可能会认为”如果我们总是需要返回相同的类型，为什么不将函数写成 func launchFighter() -&gt; XWing?“。 虽然这可能有时可以，但它会产生新的问题，例如： 我们最终得到的类型并不想暴露出去。例如，如果我们使用 someArray.lazy.drop {...}，我们会收到一个 LazyDropWhileSequence - 一个来自 Swift 标准库的专用且特定的类型。我们真正关心的是这个东西是一个序列，我们不需要知道 Swift 的内部结构是如何工作的。 我们失去了之后改变主意的能力。使 launchFighter() 只返回 XWing 意味着我们将来不能切换到另一种类型，并且意识到迪士尼依赖星球大战玩具销售会有多大问题！通过返回不透明类型，我们今天可以返回 XWing，然后可以在短时间转移到 BWings - 我们只能在代码的任何给定构建中返回一种，但我们仍然可以灵活地改变主意。 在某些方面，所有这些听起来都类似与解决了 “Self or associated type requirements” 问题的范型。范型允许我们编写如下代码： 12345678910protocol ImperialFighter { init()}struct TIEFighter: ImperialFighter { }struct TIEAdvanced: ImperialFighter { }func launchImperialFighter&lt;T: ImperialFighter&gt;() -&gt; T { return T()} 这里定义了一个新协议以及两个满足协议的结构体，而 launchImperialFighter() 函数用来使用它们。但是，这里的区别在于，launchImperialFighter() 的调用者可以选择它们获得的战斗机类型，如下： 12let fighter1: TIEFighter = launchImperialFighter()let fighter2: TIEAdvanced = launchImperialFighter() 如果你希望调用者能够选择它们的数据类型，那么范型可以很好的解决问题，但如果你希望函数决定返回类型，那么它们就会失败。 因此，不透明的结果类型允许我们做几件事： 我们的函数决定返回什么类型的数据，而不是这些函数的调用者。 我们不需要担心 Self 或相关类型要求，因为编译器确切的知道内部类型。 无论何时我们需要，都可以改变主意。 我们不会将私有内部类型暴露给外部。 静态和类下标 SE-0254 增加了将下标标记为静态的功能，这意味着它们适用于类型而不是类型的实例。 当在该类型的所有实例之间共享一组值时，将使用静态属性和方法。例如，如果你有一个集中存储应用程序设置，则可以编写如下代码： 12345678910111213141516public enum OldSettings { private static var values = [String: String]() static func get(_ name: String) -&gt; String? { return values[name] } static func set(_ name: String, to newValue: String?) { print(\"Adjusting \\(name) to \\(newValue ?? \"nil\")\") values[name] = newValue }}OldSettings.set(\"Captain\", to: \"Gary\")OldSettings.set(\"Friend\", to: \"Mooncake\")print(OldSettings.get(\"Captain\") ?? \"Unknown\") 将字典包装在一个枚举类型中意味着我们可以更仔细的控制访问，并且没有任何 case 的枚举意味着我们不能尝试初始化类型 - 我们不能创建各种设置的实例。 使用 Swift 5.1，我们现在可以使用静态下标，允许我们将代码重写为： 1234567891011121314151617public enum NewSettings { private static var values = [String: String]() public static subscript(_ name: String) -&gt; String? { get { return values[name] } set { print(\"Adjusting \\(name) to \\(newValue ?? \"nil\")\") values[name] = newValue } }}NewSettings[\"Captain\"] = \"Gary\"NewSettings[\"Friend\"] = \"Mooncake\"print(NewSettings[\"Captain\"] ?? \"Unknown\") 像这样的自定义下标总是可以用于类型的实例，这种改进使得静态或类下标称为可能。 Warnings for ambiguous none cases Swift 的 optional 类型的实现是 some 和 none 两种 case 的枚举。如果我们创建一个没有 case 的枚举，然后将它包装在一个可选项中，就会产生混淆的可能性。 例如： 1234enum BorderStyle { case none case solid(thickness: Int)} 用作非可选项，这一直是明确的： 12let border1: BorderStyle = .noneprint(border1) 这将打印出 “none”。 但是如果我们为枚举使用一个可选类型 - 如果我们不知道使用什么边框样式，那么我们就遇到了问题： 12let border2: BorderStyle? = .noneprint(border2) 这会打印出 “nil”，因为 Swift 假定 .none 表示可选项为空，而不是可选的值为 BorderStyle.none。 在 Swift 5.1 中，这种混乱现在会打印出一个警告：“Assuming you mean Optional.none; did you mean BorderStyle.none instead? “ 这可以避免破坏源兼容性的错误，但至少告诉开发人员他们的代码可能并不完全意味着他们的想法。 Matching optional enums against non-optionals Swift 一直很聪明，可以处理 switch/case 模式匹配中的字符串与整数的可选和非可选值之间的匹配，但在 Swift 5.1 之前没有扩展到枚举中。 好吧，在 Swift 5.1 中我们现在可以使用 switch/case 模式匹配来匹配可选和非可选，如下所示： 12345678910111213141516enum BuildStatus { case starting case inProgress case complete}let status: BuildStatus? = .inProgressswitch status {case .inProgress: print(\"Build is starting…\")case .complete: print(\"Build is complete!\")default: print(\"Some other build status\")} Swift 能够直接将可选枚举与非可选枚举 case 进行比较，因此代码将打印出 “Build is starting…”。 Ordered collection diffing SE-0240 引入了在有序集合之间计算和应用差异的能力。对于在表视图中具有复杂集合的开发人员来说，这可能特别有趣，他们希望使用动画平滑地添加和删除大量项目。 基本原理很简单：Swift 5.1 为我们提供了一个新的 difference(from:) 方法，它计算两个有序集合之间的差异 - 要删除的项目和要插的项目。它可以与包含 Equatable 元素的任何有序集合一起使用。 为了证明这一点，我们可以创建一个存储分数(score)的数组，计算从一个到另一个的差异，然后循环这些差异并应用到每个分数以使我们的两个集合相同。 注意： 由于 Swift 在 Apple 的操作系统中发布，因此必须使用 #available 检查这样的新功能，以确保代码在包含新功能的操作系统上运行。对于将在未来的某个时间点，发布在未知地操作系统中的功能，特殊版本号 “9999” 用于表示“我们还不知道实际的数字是什么”。 下面是代码实例： 1234567891011121314151617var scores1 = [100, 91, 95, 98, 100]let scores2 = [100, 98, 95, 91, 100]if #available(iOS 9999, *) { let diff = scores2.difference(from: scores1) for change in diff { switch change { case .remove(let offset, _, _): scores1.remove(at: offset) case .insert(let offset, let element, _): scores1.insert(element, at: offset) } } print(scores1)} 对于更高级的动画，你可以使用更改的第三个值 associatedWith。因此，不是使用 .insert(let offset，let element，_)，而是使用 .insert(let offset，let element，let associatedWith) 来代替。 这使你可以同时跟踪成对地变化：在集合中向下移动两个项目是删除然后插入，但 associatedWith 值将这两个更改绑定在一起，因此将其视为移动。 您可以使用新的 apply() 方法应用整个集合，而不是手动应用更改，如下所示： 1234if #available(iOS 9999, *) { let diff = scores2.difference(from: scores1) let result = scores1.applying(diff) ?? []} Creating uninitialized arrays SE-0245 为数组引入了一个新的构造器，它不会使用默认值来预填充值。这是以前作为私有 API 提供的，这意味着 Xcode 不会在代码补全时将其列出，当然如果你愿意，你仍然可以使用它 - 如果你愿意为此承担将来撤销相关 API 的风险。 要使用这个构造器，需要告诉它想要的容量，然后提供一个闭包来填充你需要的值。你提供的闭包将被赋予一个不安全的可变缓冲区指针，你可以在其中赋予你的值，以及第二个 inout 的参数，可让你知道实际使用的值的数量。 例如，我们可以创建一个包含10个随机整数的数组： 1234567let randomNumbers = Array&lt;Int&gt;(unsafeUninitializedCapacity: 10) { buffer, initializedCount in for x in 0..&lt;10 { buffer[x] = Int.random(in: 0...10) } initializedCount = 10} 这里有一些规则： 你不需要使用完所有的容量，但是不可以超过容量。因此，如果要求容量为10，则可以将 initializedCount 设置为 0 到 10， 而不是 11。如果不初始化最终存在于数组中的元素 - 例如，如果将 initializedCount 设置为 5 但实际上没有为元素 0 到 4 提供值 - 那么它们很可能会填充随机数据。这是一个坏主意。 如果未设置 initializedCount. 则它将为0，因此你指定的任何数据都将丢失。 现在，我们可以使用 map() 重写上面的代码，如下所示： 1let randomNumbers2 = (0...9).map { _ in Int.random(in: 0...10) } 这虽然更易读，但效率较低：它创建一个范围，创建一个新的空数组，将其调整到正确的数量。在范围内循环，并为每个范围项调用一次闭包。 More to come!Swift 5.1 仍处于开发阶段，尽管 Swift 本身的最终分支已经过去，但仍有一些空间可以看到其他一些相关项目的变化。 同样，这里的重要特征是模块稳定性，我知道团队正在努力做到这一点。他们没有宣布发布日期，尽管他们说由于 Swift 5.0 需要“不寻常的关注和注意”而导致5.1“开发时间明显缩短” - 我猜我们会在 WWDC19 上看到测试版，但显然这不是特定日期的匆忙。 值得特别提及的一件事是，这里列出的两个变化并没有作为 Swift Evolution 的结果引入。相反，更改 - “Warnings for ambiguous none cases” 和 “Matching optional enums against non-optionals” - 被视为错误并快速纠正。 这些都是 Swift 的高品质生活改进，但我之所以特别称它们是因为它们都是由社区贡献者修改的：Suyash Srijan。很高兴看到 Swift 的发展继续超越 Apple，而 Suyash 在这两个高度可见的功能上的工作正在帮助 Swift 更轻松，更加一致。 最重要的是，这个含糊不清的枚举错误被归档为一个初学者错误，这是 Swift 团队专门挑选出来的，以便让人们更容易开始贡献。如果您想亲自探索当前的入门错误，甚至可能会尝试修复它，请访问 http://bit.ly/starterbugs。","link":"/2019/08/06/swift-what-new-in-swift5/"},{"title":"iOS 多线程的使用与总结","text":"Grand Central Dispatch(GCD) 是用来管理并发操作的底层API。 允许将一个程序切分为多个单一任务，然后提交到工作队列中并发或者串行地执行 为多核的并行运算提出了解决方案，自动合理的利用CPU内核（比如双核，四核） 自动的管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，只需要告诉它任务是什么就行 配合Block，使得使用起来更加方便灵活 相对于线程和锁来说，GCD 提供了一个更加易用的模板，从而避免发生并发问题。 在了解GCD之前，我们需要了解一些跟并发和线程的概念。 Concurrency 并发iOS应用中包含一个或者多个线程，这些线程由系统的调度器彼此独立的管理。每个线程可以被并发的执行，但是如何实现并发却是由系统决定的。 单核设备通过 时间切片(time-slicing) 的方式来实现并发，它们运行在一个线程上，当切换其它线程时就执行上下文切换。这种切换一般进行得非常快，让用户感觉像是同时在运行多个线程一样。 而在多核设备上，可以通过并行的方式同时执行多个线程。 GCD 建立在线程之上，它负责管理共享线程池。使用 GCD，我们可以添加code block或者工作项(work items)来调度队列，GCD 决定执行它们的线程。 所以，虽然你可以使用 GCD 的接口来编写并发代码，但是 GCD 才是真正决定是否使用并行实现的人。并行要求并发，但是并发并不一定能够保证并行。 更深一层地说，并发设计其实是结构的设计。如果你带着 GCD 的思维去编写代码，你就得小心地设计代码的结构，暴露的接口要考虑可以同时执行和不可以同时执行的代码。 根本上来说，并发(concurrency)是关于结构而并行(parallelism)是关于执行。 Queues 队列GCD 通过DispatchQueue类来操作调度队列。当我们提交工作项单元到队列中，GCD将以FIFO顺序执行它们，它会保证第一个任务是第一个启动的。 调度队列本身是线程安全的，因此你可以同时从多个线程访问它们。当了解调度队列如何为代码提供线程安全时，你就可以认识到GCD的好处是显而易见的。关键是要选择正确类型的调度队列和正确的调度函数，将你的工作提交到队列。 队列可以是并行(serial)或者串行(concurrent)的。DispatchQueue的默认初始化方法创建的是一个同步队列，如果要创建并行队列，需要在attributes中声明concurrent。第一个参数表示队列的标签，这个标签在调试器中是可见的。 12345// 同步队列let serialQueue = DispatchQueue(label: \"queuename\")// 并发队列let concurrentQueue = DispatchQueue(label: \"queuename\", attributes: .concurrent) 串行可以保证在任何给定时间只运行一个任务，由 GCD 来控制执行的时间点，你也无法知道一个任务结束和下一个任务开始之间的时间量。 而并发队列允许多个任务同时运行。队列保证它们以添加的顺序来执行，但是它们会以任何可能的顺序完成。 何时开始任务完全取决于 GCD。如果一个任务的执行时间与另一个任务的执行时间重叠，则由 GCD 决定是否应该在不同的核心上运行，如果是单核设备，则执行上下文切换以运行不同的任务。 下面通过代码来看下串行和并发的区别： 1234567891011121314151617181920212223242526272829let serialDispatchQueue = DispatchQueue(label: \"custom_queue\")serialDispatchQueue.async { print(\"serialDispatchQueue async 1 is begin.\") sleep(3) print(\"serialDispatchQueue async 1 is end\")}serialDispatchQueue.async { print(\"serialDispatchQueue async 2 is begin.\") sleep(3) print(\"serialDispatchQueue async 2 is end\")}serialDispatchQueue.async { print(\"serialDispatchQueue async 3 is begin.\") sleep(3) print(\"serialDispatchQueue async 3 is end\")}print(\"🤠Welcome to the main thread from serialDispatchQueue\")// output: // serialDispatchQueue async 1 is begin.// 🤠Welcome to the main thread from serialDispatchQueue// serialDispatchQueue async 1 is end// serialDispatchQueue async 2 is begin.// serialDispatchQueue async 2 is end// serialDispatchQueue async 3 is begin.// serialDispatchQueue async 3 is end 关于并发： 123456789101112131415161718192021222324let concurrentDispatchQueue = DispatchQueue(label: \"custom_queue\", attributes: .concurrent)concurrentDispatchQueue.async { print(\"concurrentDispatchQueue async 1 is begin.\") sleep(3) print(\"concurrentDispatchQueue async 1 is over.\")}concurrentDispatchQueue.async { print(\"concurrentDispatchQueue async 2 is begin.\") sleep(3) print(\"concurrentDispatchQueue async 2 is over.\")}print(\"🤠Welcome to the main thread from concurrentDispatchQueue\")// output:// concurrentDispatchQueue async 1 is begin.// concurrentDispatchQueue async 2 is begin.// concurrentDispatchQueue async 3 is begin.// 🤠Welcome to the main thread from concurrentDispatchQueue// concurrentDispatchQueue async 1 is over.// concurrentDispatchQueue async 2 is over.// concurrentDispatchQueue async 3 is over. Synchronous vs. Asynchronous 同步与异步使用GCD，我们可以同步或异步分配任务。 任务完成后，同步函数会将控制权返回给调用者。 您可以通过调用DispatchQueue.sync（execute :)来同步调度工作单元。 异步函数立即返回，命令任务开始但不等待它完成。 因此，异步函数不会阻塞当前执行线程继续执行下一个函数。 您可以通过调用DispatchQueue.async（execute :)来异步调度工作单元。 GCD 提供了三种主要类型的队列： Main queue 主队列，在主线程上运行，是一个串行队列 Global queues 全局队列，整个系统共享的并发队列。全局队列有四种不同的优先级：high,default,low和background。background优先级最低，在任何I/O活动中受到限制，以最大限度地减少对系统地负面影响。 Custom queue 自定义队列，由开发创建的队列，可以是串行或者并发的队列。而在这个队列上的请求最终会在全局队列中的一个上执行。 而将任务发送到全局并发队列时，不直接指定优先级，而是指定服务质量(QoS)属性。QoS用来标志任务的重要性，并指导GCD赋予任务优先级。 123456queue.async(qos: .background) { print(\"Maintenance work\")}queue.async(qos: .userInitiated) { print(“Button tapped”)} 下面介绍一下在创建队列时，可以设置的一些更丰富的属性。创建队列的完整方法如下：1convenience init(label: String, qos: DispatchQoS = default, attributes: DispatchQueue.Attributes = default, autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = default, target: DispatchQueue? = default) label 表示队列的标识符，在debug的时候可以通过label来分辨。 QoS队列在执行上是有优先级的，更高的优先级可以享受更多的计算资源，从高到低包括： userInteractive 用户交互，表示需要立即完成的任务，用以提供良好的用户体验。将其用于UI更新，事件处理和需要低延迟地小型工作负载。在执行您的应用程序期间，此类中完成的工作总量应该很小。这应该在主线程上运行。 userInitiated 用户活动 用户从UI启动这些异步任务。当用户等待立即结果以及继续用户交互所需地任务时使用它们。它们在高优先级全局队列中执行。 utility 表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 background 这表示用户不需要直接了解的任务。用于预取，维护和其他不需要用户交互且时间不敏感的任务。这将被映射到后台优先级全局队列。 Attributes包含两个属性： concurrent 标识队列为并发队列 initiallyInactive 标识队列中的任务需要手动触发（为添加该标识时，向队列中添加任务会自动运行），触发时通过queue.activate()方法 AutoreleaseFrequency这个属性表示 autorelease pool的自动释放频率，autorelease pool 管理着任务对象的内存周期。 包含三个属性： inherit 继承目标队列的该属性 workItem 跟随每个任务的执行周期进行自动创建和释放 never 不会自动创建 autorelease pool，需要手动管理 一般任务采用 .workItem 就够了，特殊任务如在任务内部大量重复创建对象的操作可选择 .never属性手动创建 autorelease pool。 Target这个属性设置的是一个队列的目标队列，即实际将该队列的任务放入指定队列中运行。目标队列最终约束了队列优先级等属性。 在程序中手动创建的队列，其实最后都指向系统自带的 主队列 或 全局并发队列。 你也许会问，为什么不直接将任务添加至系统队列中，而是自定义队列，因为这样的好处是可以将任务进行分组管理。如单独阻塞队列中的任务，而不是阻塞系统队列中的全部任务。如果阻塞了目标队列，所有指向它的原队列也将被阻塞。 在 Swift 3 及之后，对目标队列的设置进行了约束，只有两种情况可以显式地设置目标队列（原因参考）： 初始化方法中，指定目标队列。初始化方法中，attributes 设定为 initiallyInactive，然后在队列执行 activate() 之前可以指定目标队列。在其他地方都不能再改变目标队列。 推迟时间后执行有时候你并不需要立即将任务加入队列中运行，而是需要等待一段时间后再进入队列中，这时候可以使用 asyncAfter 方法。可以用静态方法now获得当前时间，然后再通过加上一个DispatchTimeInterval枚举来获得一个需要延迟的时间。 1234let delay = DispatchTime.now() + DispatchTimeInterval.seconds(60)DispatchQueue.main.asyncAfter(deadline: delay) { // 延迟执行} 这里也可以直接加上一个秒数。1let three = DispatchTime.now() + 3.0 因为DispatchTime中自定义了+号。1public func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime 同步锁如果一段代码所在的进程中有多个线程在同时运行，那么这些线程就有可能会同时运行这段代码。假如多个线程每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。由于可读写的全局变量及静态变量（在 Objective-C 中还包括属性和实例变量）可以在不同线程修改，所以这两者也通常是引起线程安全问题的所在。 注意，pthread_mutex_t，pthread_rwlock_t 和 OSSpinLock 是值类型，而不是引用类型。这意味着如果你用 = 进行赋值操作，实际上会复制一个副本。这会造成严重的后果，因为这些类型无法复制！如果你不小心复制了它们中的任意一个，这个副本无法使用，如果使用可能会直接崩溃。这些类型的 pthread 函数会假定它们的内存地址与初始化时一样，因此如果将它们移动到其他地方就可能会出问题。OSSpinLock 不会崩溃，但复制操作会生成一个完全独立的锁，这不是你想要的。 如果使用这些类型，就必须注意不要去复制它们，无论是显式的使用 = 操作符还是隐式地操作。例如，将它们嵌入到结构中或在闭包中捕获它们。 另外，由于锁本质上是可变对象，需要用 var 来声明它们。 其他锁都是是引用类型，它们可以随意传递，并且可以用 let 声明。 在 Swift 中可以使用 Darwin 中传统的锁的方式。但是 pthread 类型很难在 swift 中使用。它们在被定义为不透明的结构体中包含了一堆存储变量。所以，很不建议在 Swift 中使用这一类型的锁。 如果想要使用传统类型的锁，我们可以使用Foundation.Lock, 因为不同于传统的基于C语言锁的结构，它是一个类，因此不会产生之前提到的那个问题。 同时我们推荐使用调度队列来进行同步 如何使用调度队列来实现同步： 同时，可以使用预设条件来确保代码运行在特定的队列中运行。 DispatchGroup当有多个任务需要处理时，你可以异步的一个个处理这些任务， 你还可以将它们组合在一起然后等待这个组合工作的结束。 DispatchGroup相当于一系列任务的松散集合，它可以来自相同或者不同队列，扮演者组织者的角色。它可以通知外部队列，组内的任务是否都已完成。或者阻塞当前的线程，直到组内的任务都完成。所有适合组内执行的任务都可以使用任务组，且任务组更适合集合异步任务(如果都是同步任务，直接使用串行队列即可)。 通过创建的DispatchGroup对象，当你向调度器提交工作的时候，可以向异步调用增加这个group作为一个可选的参数。你可以向这个group添加更多的工作以及在不同的队列中使用同一个group将它们联系起来。 每次向group提交工作，它都会增加需要完成的项目的数量。最后当你提交了所有的工作，可以让group在所有工作被完成时在指定的队列上通知你。 有两种方式加入任务组： 添加任务时指定任务组 12345let group = DispatchGroup()let queue = DispatchQueue.global()queue.async(group: group) { // do something} 使用 group.enter(), group.leave() 配对方法，标识任务加入任务组。123456let group = DispatchGroup()group.enter()queue.async() { // do something group.leave()} 两种加入方式在对任务处理的特性上是没有区别的，只是便利之处不同。如果任务所在的队列是自己创建或系统队列，那么直接使用第一种方式直接加入即可。如果任务是由系统或第三方的API创建的，由于无法获取对应的队列，只能使用第二种方式将任务加入组内，例如将 URLSession 的 addDataTask 方法加入任务组中。 1234567891011extension URLSession { func addDataTask(to group: DispatchGroup, with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask { group.enter() // 进入任务组 return dataTask(with: request) { (data, response, error) in completionHandler(data, response, error) group.leave() // 离开任务组 } }} 我们也可以等待任务组中的任务全部完成后，可以统一对外发送通知，有两种方式： group.notify() 方法，它可以在所有任务完成后通知指定队列并执行一个指定任务，这个通知的操作是异步的（意味着通知后续的代码不需要等待任务，可以继续执行）： 12345678910111213141516171819202122let group = DispatchGroup()let queueBook = DispatchQueue(label: \"book\")queueBook.async(group: group) { // do something 1}let queueVideo = DispatchQueue(label: \"video\")queueVideo.async(group: group) { // do something 2}group.notify(queue: DispatchQueue.main) { print(\"all task done\")}print(\"do something else.\")// 执行结果// do something else.// do something 1(任务 1、2 完成顺序不固定)// do something 2// all task done group.wait() 方法， 它会在所有任务完成后再执行当前线程中后续的代码，因此这个操作是有阻塞作用。 12345678910111213141516171819let group = DispatchGroup()let queueBook = DispatchQueue(label: \"book\")queueBook.async(group: group) { // do something 1}let queueVideo = DispatchQueue(label: \"video\")queueVideo.async(group: group) { // do something 2}group.wait()print(\"do something else.\")// 执行结果// do something 1(任务 1、2 完成顺序不固定)// do something 2// do something else. wait 方法中还可以指定具体的时间，它表示将等待不超过这个时间，如果任务组在指定时间之内完成则立即恢复当前线程，否则将等到时间结束时再恢复当前线程。 方式1，使用 DispatchTime，它表示一个时间间隔，精确到纳秒（1/1000,000,000 秒）： 12let waitTime = DispatchTime.now() + 2.0 // 表示从当前时间开始后 2 秒，数字字面量也可以改为使用 TimeInterval 类型变量group.wait(timeout: waitTime) 方式2，使用 DispatchWallTime，它表示当前的绝对时间戳，精确到微秒（1/1000,000 秒），通常使用字面量即可设置延时时间，也可以使用 timespec 结构体来设置一个精确的时间戳，具体参见附录章节的《时间相关的结构体说明 - DispatchWallTime》： 12// 使用字面量设置var wallTime = DispatchWallTime.now() + 2.0 // 表示从当前时间开始后 2 秒，数字字面量也可以改为使用 TimeInterval 类型变量 SemaphoreDispatchSemaphore 是传统计数信号量的封装，用来控制资源被多任务访问的情况。简单来说就是控制访问资源的数量，比如系统有两个资源可以被利用，同时有三个线程要访问，只能允许两个线程访问，第三个应当等待资源被释放后再访问。例如，控制同一时间写文件的任务数量、控制端口访问数量、控制下载任务数量等。 信号量的使用非常的简单： 首先创建一个初始数量的信号对象 使用 wait 方法让信号量减 1，再安排任务。如果此时信号量仍大于或等于 0，则任务可执行，如果信号量小于 0，则任务需要等待其他地方释放信号。 任务完成后，使用 signal 方法增加一个信号量。 等待信号有两种方式：永久等待、可超时的等待。 123456789101112131415161718192021222324252627282930313233343536let queue = DispatchQueue( label: \"com.sinkingsoul.DispatchQueueTest.concurrentQueue\", attributes: .concurrent)let semaphore = DispatchSemaphore(value: 2) // 设置数量为 2 的信号量semaphore.wait()queue.async { print(\"Task 1 start\") sleep(2) print(\"Task 1 finish\") semaphore.signal()}semaphore.wait()queue.async { print(\"Task 2 start\") sleep(2) print(\"Task 2 finish\") semaphore.signal()}semaphore.wait()queue.async { print(\"Task 3 start\") sleep(2) print(\"Task 3 finish\") semaphore.signal()}// 运行结果：// Task 1 start// Task 2 start// Task 1 finish// Task 2 finish// Task 3 start// Task 3 finish 运行结果中可以看到任务 3 在前两个任务完成后才开始运行。 DispatchWorkItemDispatchQueue执行操作除了直接传递一个闭包外，还可以传入一个DispatchWorkItem。 DispatchWorkItem 的初始化方法可以配置 QoS 和 DispatchWorkItemFlags, 但是这两个参数都有默认参数，所以也可以只传入一个闭包。 DispatchWorkItemFlags 枚举中 assignCurrentContext 表示 QoS 根据创建时的 context 决定，这个 workItem 会从负责执行该任务的调度队列或者线程继承其QoS设置。 另外，DispatchWorkItem 也有 wait 方法，调用会等待这个 workItem 执行完。 DispatchWorkItemFlags 枚举中还有其他选项，如 barrier, detached, enforceQos, inheritQos, noQos。 .barrier: 如果DispatchWorkItem被提交到.concurrent并发队列，那么这个DispatchWorkItem中的操作会具有独占性(防止此DispatchWorkItem中的block内的操作与其他操作同时执行)。执行该任务时，它会先等待队列中已有的任务全部执行完成，然后它再执行，在它之后加入的任务也必须等栅栏任务执行完成后才能执行。 123456789101112131415161718let queue = DispatchQueue(label: \"BarrierWorkItem\", attributes: .concurrent)queue.async { sleep(4) print(\"async task 1 finish.\")}let task = DispatchWorkItem(flags: .barrier) { sleep(2) print(\"barrier task finish.\")}queue.async(execute: task)queue.async { sleep(1) print(\"async task 2 finish.\")}//async task 1 finish.//barrier task finish.//async task 2 finish. .detached 表明DispatchWorkItem会无视当前执行上下文的参数。 .noQos 不指定QoS，由调用线程或队列来指定。 .inheritQos 表明DispatchWorkItem会采用队列的QoS class，而不是当前的。 .enforceQos 表明DispatchWorkItem会采用当前的QoS class，而不是队列的。 DispatchSourceDispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。 可监听的对象的具体类型： Timer Dispatch Source：定时调度源。 Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。 Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。 Process Dispatch Source：监听进程相关状态的调度源。 Mach port Dispatch Source：监听Mach相关事件的调度源。 Custom Dispatch Source：监听自定义事件的调度源。 下面以文件监听为例看下使用方法，下面例子中监听了一个指定目录下文件的写入事件，创建监听主要有几个步骤： 通过 makeFileSystemObjectSource 方法创建 source 通过 setEventHandler 设定事件处理程序，setCancelHandler 设定取消监听的处理。 执行 resume() 方法开始接收事件 1234567891011let queue = DispatchQueue.global()let filePath = \"...\"let fileURL = URL(fileURLWithPath: filePath)let fd = open(fileURL.path, O_EVTONLY)let source = DispatchSource.makeFileSystemObjectSource(fileDescriptor: fd, eventMask: .write, queue: queue)source.setEventHandler(handler: closure)source.setCancelHandler { close(fd)}source.resume() DispatchSourceTimer 的例子：1234567891011121314151617181920212223242526func printTime(withComment comment: String){ let date = Date() let formatter = DateFormatter() formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\" print(comment + \": \" + formatter.string(from: date))}let timer = DispatchSource.makeTimerSource()timer.schedule(deadline: .now() + .seconds(10), repeating: .seconds(5), leeway: .seconds(5))timer.setEventHandler { printTime(withComment: \"hello world\")}timer.activate()printTime(withComment: \"3\")// 运行结果：// 3: 2019-04-25 16:43:53// hello world: 2019-04-25 16:44:03// hello world: 2019-04-25 16:44:08// hello world: 2019-04-25 16:44:13// hello world: 2019-04-25 16:44:18// hello world: 2019-04-25 16:44:23 表明DispatchWorkItem会采用当前的QoSDispatchIO 对象提供一个操作文件描述符的通道。简单讲就是你可以利用多线程异步高效的读写文件。 发起读写操作一般步奏如下： 创建 DispatchIO 对象，或者说创建一个通道，并设置结束处理闭包。 调用 read/write 方法。 调用 close 方法关闭通道。 在 clone 方法后系统将自动调用结束处理闭包。 初始化方法 一般使用两种方式初始化： 文件描述符，或者文件路径 文件描述符方式 文件描述符使用 open 方法创建： open(_ path: UnsafePointer&lt;CChar&gt;, _ oflag: Int32, _ mode: mode_t) -&gt; Int32, 第一个参数是 UnsafePointer 类型的路径，oflag 、mode 指文件的操作权限，一个是系统 API 级的，一个是文件系统级的，可选项如下: oflag： Flag 备注 功能 O_RDONLY 以只读方式打开文件 此三种读写类型只能有一种 O_WRONLY 以只写方式打开文件 此三种读写类型只能有一种 O_RDWR 以读和写的方式打开文件 此三种读写类型只能有一种 O_CREAT 打开文件，如果文件不存在则创建文件 创建文件时会使用Mode参数与Umask配合设置文件权限 O_EXCL 如果已经置O_CREAT且文件存在，则强制open()失败 可以用来检测多个进程之间创建文件的原子操作 O_TRUNC 将文件的长度截为0 无论打开方式是RD,WR,RDWR，只要打开就会把文件清空 O_APPEND 强制write()从文件尾开始不care当前文件偏移量所处位置，只会在文件末尾开始添加 如果不使用的话，只会在文件偏移量处开始覆盖原有内容写文件 mode：包含 User、Group、Other 三个组对应的权限掩码。 User Group Other 说明 S_IRWXU S_IRWXG S_IRWXO 可读、可写、可执行 S_IRUSR S_IRGRP S_IROTH 可读 S_IWUSR S_IWGR S_IWOTH 可写 S_IXUSR S_IXGRP S_IXOTH 可执行 创建的通道有两种类型： 连续数据流：DispatchIO.StreamType.stream，这个方式是对文件从头到尾完整操作的。随机片段数据：DispatchIO.StreamType.random，这个方式是在文件的任意一个位置（偏移量）开始操作的。 1234567let filePath: NSString = \"test.zip\"// 创建一个可读写的文件描述符let fileDescriptor = open(filePath.utf8String!, (O_RDWR | O_CREAT | O_APPEND), (S_IRWXU | S_IRWXG))let queue = DispatchQueue(label: \"com.sinkingsoul.DispatchQueueTest.serialQueue\")let cleanupHandler: (Int32) -&gt; Void = { errorNumber in}let io = DispatchIO(type: .stream, fileDescriptor: fileDescriptor, queue: queue, cleanupHandler: cleanupHandler) 文件路径方式 1let io = DispatchIO(type: .stream, path: filePath.utf8String!, oflag: (O_RDWR | O_CREAT | O_APPEND), mode: (S_IRWXU | S_IRWXG), queue: queue, cleanupHandler: cleanupHandler) 数据块大小阀值DispatchIO 支持多线程操作的原因之一就是它将文件拆分为数据块进行并行操作，你可以设置数据块大小的上下限，系统会采取合适的大小，使用这两个方法即可：setLimit(highWater: Int)、setLimit(lowWater: Int)，单位是 byte。1io.setLimit(highWater: 1024*1024) 数据块如果设置小一点（如 1M），则可以节省 App 的内存，如果内存足够则可以大一点换取更快速度。在进行读写操作时，有一个性能问题需要注意，如果同时读写的话一般分两个通道，且读到一个数据块就立即写到另一个数据块中，那么写通道的数据块上限不要小于读通道的，否则会造成内存大量积压无法及时释放。 读操作方法示例：123456789101112ioRead.read(offset: 0, length: Int.max, queue: ioReadQueue) { doneReading, data, error in if (error &gt; 0) { print(\"读取发生错误了，错误码：\\(error)\") return } if (data != nil) { // 使用数据 } if (doneReading) { ioRead.close() }} offset 指定读取的偏移量，如果通道是 stream 类型，值不起作用，写为 0 即可，将从文件开头读起；如果是 random 类型，则指相对于创建通道时文件的起始位置的偏移量。 length 指定读取的长度，如果是读取文件全部内容，设置 Int.max 即可，否则设置一个小于文件大小的值（单位是 byte）。 每读取到一个数据块都会调用你设置的处理闭包，系统会提供三个入参给你：结束标志、本次读取到的数据块、错误码： 在所有数据读取完成后，会额外再调用一个闭包，通过结束标志告诉你操作结束了，此时 data 大小是 0，错误码也是 0。如果读取中间发生了错误，则会停止读取，结束标志会被设置为 true，并返回相应的错误码，错误码表参考稍后的【关闭通道】小节：写操作方法示例： 12345678910ioWrite.write(offset: 0, data: data!, queue: ioWriteQueue) { doneWriting, data, error in if (error &gt; 0) { print(\"写入发生错误了，错误码：\\(error)\") return } if doneWriting { //... ioWrite.close() }} 写操作与读操作的唯一区别是：每当写完一个数据块时，回调闭包返回的 data 是剩余的全部数据。同时注意如果是 stream 类型，将接着文件的末尾写数据。 关闭通道当读写正常完成，或者你需要中途结束操作时，需要调用 close 方法，这个方法带一个 DispatchIO.CloseFlags 类型参数，如果不指定将默认值为 DispatchIO.CloseFlags.stop。 这个方法传入 stop 标志时将会停止所有未完成的读写操作，影响范围是所有 I/O channel，其他 DispatchIO 对象进行中的读写操作将会收到一个 ECANCELED 错误码，rawValue 值是 89，这个错误码是 POSIXError 结构的一个属性，而 POSIXError 又是 NSError 中预定义的一个错误域。 因此如果要在不同 DispatchIO 对象中并行读取操作互不影响， close 方法标志可以设置一个空值：DispatchIO.CloseFlags()。如果设置了 stop 标志，则要做好不同 IO 之间的隔离，通过任务组的enter、leave、wait 方法可以做到较好的隔离。12ioWrite.close() // 停止标志ioWrite.close(flags: DispatchIO.CloseFlags()) // 空标志","link":"/2019/04/03/ios-gcd-understanding/"},{"title":"Understanding Swift Performance","text":"理解 Swift 的性能，首先要搞清楚 Swift 的数据结构，组件关系和它们的内在实现，从而通过选择最合适的抽象机制来提升性能。 当你在创建一个抽象并选择一个抽象机制时，你应该问问自己 我的实例时分配给堆栈还是堆？ 当我传递这个实例时，我要产生多少开销？ 当我在这个实例中调用方法时，是静态还是动态发送? 当我们想快速地写Swift代码时, 就要避免为不能利用的动态和运行时间付出代价。我们需要学习何时以及如何在这些不同维度之间切换来获得更好的性能。 下面我们将从不同维度来评估不同的抽象机制选项。 Allocation 内存分配Swift 会替你自动分配和回收内存的分配。 有些内存会分配给栈(Stack)，有些则会分配到堆(Heap)上。 栈时一种非常简单的数据结构，你可以将元素压到栈底或者弹出栈底。因为你只能添加或移出栈底，所以只需要通过保存的栈底指针就可以实现栈的入栈和出栈。 这意味着当调用函数时, 只需要通过递减栈底指针数值来获取空间。当函数执行完毕后，同样只需要把栈底指针增加至调用函数之前的的数值即可达到释放内存的目的。因此栈的分配速度非常快，它其实仅仅是分配一个整数的消耗。 那么，这就与堆形成了对比。 堆更动态化，但比栈效率低。堆可以让你实现栈不能实现的功能，比如动态周期性的分配内存，但它同时也需要更高级的数据结构。如果你要在堆上分配内存，实际上要去搜索堆数据结构，寻找适当大小的闲置内存块，用完之后要释放内存，还需要把那个内存块插回到正确的位置。很显然，相比在栈中实现的，这涉及的东西更多。同时，因为涉及到多线程分配内存，堆需要使用锁或其它同步机制来保护它的完整性，这是一个很大的消耗。 下面通过一些代码来看看 Swift 都替我们做了什么 12345678910struct Point { var x, y: Double func draw() { … } }let point1 = Point(x: 0, y: 0) var point2 = point1 point2.x = 5 // use `point1` // use `point2` 上面定义了一个Point的结构体, 有x和y存储属性, 还有draw方法。用(0, 0) 构造点，把point1 赋值给point2, 并把point2.x赋一个为5的值。 在执行任何代码之前, 系统已为point1和point2实例在堆栈上分配了一个空间，因为Point是一个结构体，而x和y属性被存储在栈中。当把point1赋值给point2时，我们仅仅是复制了那个点，并初始化了point2的内存，也就是之前已经分配到栈上的内存。请注意，point1和point2是独立的实例，意思就是，当我们给point2.x赋一个为5的值时，point2.x是5，但point1.x仍然是0，这就是值语义。 然后我们继续使用point1和point2，并完成函数的执行之后，只需要通过把堆栈指针的值增至进入函数之前的值就可以释放point1和point2的内存。 同之前的代码比较，下面使用 class 来定义Point 12345678910 struct Point { var x, y: Double func draw() { … } }let point1 = Point(x: 0, y: 0) var point2 = point1 point2.x = 5 // use `point1` // use `point2` 跟之前的一样，我们给栈分配内存，但并不实际存储’Point’的属性。我们要给point1和point2分配内存引用，引用要分配到堆上的内存。当用(0, 0)进行初始化时，Swift会锁住堆并寻找堆上适当大小的闲置内存块。在得到合适的内存块后，我们要以x为0，y为0进行初始化, 并且把point1初始化为那个堆上分配的内存地址。请注意，当在堆上分配时，Swift其实是为Point类分配了四个字的存储，这跟Point是结构体时所分配的两个字形成了对比。Swift 会多出的两个字进行管理，这两个字通过图中的这些蓝色框来指示。 注： 多出的第一个字可以简单的说就是指向 Class 的指针，第二个字存放的是引用计数。 https://juejin.im/post/5a7b04c86fb9a0634b4d632a 当把point1赋值给point2时，我们并不是要复制point1的内容，相反它是复制引用。point1和point2其实指的正是堆上的同一个实例。意思是，当我们给point2.x赋一个为5的值时，point1.x和point2.x的值都为5，这就是引用的语义，可导致非计划的状态共享。 然后Swift会释放这个内存,锁住堆,再分配闲置内存块到适当的位置后就可以出栈了。 我们看到类的构造比结构的构造消耗更多。由于类是在堆上分配的并且有引用语义，所以类有一些强大的特性，如一致性和间接存储。但是如果我们的抽象不需要这些特性，最好还是用结构体，而且结构不会导致像类那样的非计划的状态共享。 Reference Counting 引用计数当我们谈堆式分配时，Swift 是如何了解何时释放在堆上分配的内存是安全的呢？ 答案是 Swift 会保持一个堆中任何实例的引用个数的总计数，并把它存储在实例本身。当你添加引用或移除引用时，就会增加或减少引用计数。当计数为零时，Swift就知道没有指向堆上的这个实例的引用，而且释放那个内存很安全。 引用计数的关键点是，这是个非常频繁的运算。实际上比只增加和减少一个整数更复杂。首先，涉及到成对出现的间接层级来执行增加和减少计数。更重要的是跟堆式分配一样，需要考虑线程的安全性，因为引用能在多线程的时候被添加或移除到任何堆实例，由于引用计数运算的频率高，这会增加消耗。 以 Point 类为例，来看看 Swift 替我们做了什么。这里有用来作为对比的一些伪代码： Point获得了一个附加属性refCount,并且 Swift 添加了一对调用 retain 和 release, retain会自动增加引用计数，release会自动减少引用计数，这样 Swift就可以追踪堆上的Point上有多少激活的引用。 在堆上构造Point之后，因为有一个实例的实时引用，那个实例就被初始化为引用计数为1。查看整个程序，并把point1赋值给point2，我们现在就有两个引用了，那么Swift添加一个retain调用，来自动增加点实例的引用计数。继续执行，一旦我们不再使用point1，因为point1不再是它所关注的一个激活的引用，Swift 会添加一个release调用来自动减少引用计数。同样地，一旦我们不再使用point2，Swift会添加另一个release调用,自动减少引用计数。在这时，没有对Point的实例引用被使用，所以Swift就知道很安全，会锁住堆并把那个内存块返回给它。 如果是结构体会怎么样呢？结构是否涉及引用计数呢？当我们构造点结构时，不会涉及任何堆式分配，当我们复制时也不会涉及任何堆式分配，每个步骤都不会涉及引用。所以Point结构体没有引用计数。 那更复杂的结构呢？ 12345678910struct Label { var text: String var font: UIFont func draw() { … } }let label1 = Label(text: \"Hi\", font: font) let label2 = label1 // use `label1` // use `label2` 在这里有个Label结构体，属性包含字符串类型的text，和类型为UIFont的font。刚才提到过字符串，实际上是把它的字符内容存储在堆上，所以需要引用计数。字体是一个类,也需要引用计数。 当我们复制它时，实际上增加了两个引用。 Swift的追踪这些堆式分配的方式是通过保留和释放的调用来实现的。 由于类是在堆上分配的，Swift得管理那个堆式分配的使用期限，这是通过引用计数实现的。 而引用计数的难点在于运算相对频繁,且具备原子性。这也是我们使用结构的另一个原因。 但是，如果结构包含引用，也会进行引用计数。事实上，结构体会进行引用计数,相应地与它们所包含的引用数量成比例的。所以 如果它们有一个以上的引用，它们会保留一个类以上的引用计数。 Method Dispatch 方法派发在运行过程中，当调用一个方法时，Swift 需要执行正确的实现。 如果能在编译时确定要执行的实现，这就是静态派发。 在运行过程中，我们能直接跳到正确的实现，这很酷。因为编译器实际上可以看到要执行哪些实现，并且也可以做一些如内联之类的优化，这跟动态调度形成了对比。 动态调度时，在编译时无法直接决定要执行哪个实现。在运行时，需要去查找实现，然后调到那个。相比静态派发，虽然动态派发增加了一个间接层级，这样做的成本并不高。但是动态派发阻碍了编译器的可见性，编译器无法对动态派发进行一些包括内联的优化操作。 我们究竟为什么要这个动态调度呢？原因之一是通过它可以使一些特性成为可能，比如多态。 我们通过一个传统的面向对象的程序来看下具体原理。有一个可绘制的抽象超类,我可以定义一个Point子类和Line子类，然后用自定义实现来覆盖draw方法。 然后我可以多态地创建Drawable实例的数组，可能包含Point实例，也可能包含Line实例，可以分别调用draw。 那么是如何实现的呢？ 因为可绘制的Point和Line都是类，我们可以创建一个包含这些实例的数组, 因为我们保存在数组里的是对它们的引用，因此它们都是相同大小的对象。但当我们查看数组中的元素并且尝试调用draw的时候，因为这个d.draw可以是Point，也可以是个Line,这是不同的代码路径。那么，如何决定调用哪个呢？ 编译器向类中添加了另一个字段，是这个类的类型信息的指针，指向存储在静态内存中的类型信息。 因此 当调用draw时，编译器实际上生成的了一个对类型信息的查询，查找一个虚拟方法表，在类型和包含指针的静态内存上找到要执行的正确的实现。 如果我们修改了这个d.draw，编译器替我们做的是查询虚拟方法表，找到要执行的正确的draw实现，然后把那个实际的实例作为隐式的self参数传过来。 类默认动态地调度它们的方法，这对于它本身并没有什么不同。但是如果形成方法链，会阻碍编译器进行内联及一些其他可添加的优化。 但是，并不是所有类都需要动态调度。如果你从未打算给一个类创建子类，你可以把它标记为final类，编译器会注意到这一点，并静态地调度这些方法。 此外 如果编译器可以推理和证明你从不打算在应用中给类建立子类，它将适时地替你把那些动态调度变成静态调度。 Summary因此无论何时，当你读和写Swift代码时你都应该观察和思考： 这个实例要在堆栈中还是在堆中分配？ 当我传递这个实例时,要引发多少引用计算？ 当我在这个实例中调用方法时是动态调度还是静态调度？ 你可能会问Struct如何实现多态呢?答案是 Protocol Oriented Programming。 以上分析了影响性能的几个标准，那么不同的算法机制Class，Protocol Types和Generic code，它们在这三方面的表现如何，Protocol Type 和 Generic code 分别是怎么实现的呢？我们带着这个问题看下去。 Protocol Types这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。 这次我们不再用Drawable地抽象基类，我们要用声明了draw方法的Drawable协议，并且我们有数值类型的Point结构体和遵循协议的Line结构体。 请注意，我们同样还可以有一个遵循协议的SharedLine类。然而，由于类所具有的引用语义会使非计划的共享出现，因此我们决定不再使用它。 我们程序仍然是多态的，仍然可以在Drawable的协议类型数组中存储Point和Line类型实例。然而 跟以前相比有一个不同点，Point数值类型结构和Line结构并不共享一个使用 v-table 调度所需要的共同的继承关系。 123456789101112131415protocol Drawable { func draw() }struct Point : Drawable { var x, y: Double func draw() { … } }struct Line : Drawable { var x1, y1, x2, y2: Double func draw() { … } }var drawables: [Drawable] for d in drawables { d.draw() } 那么 Swift是如何调度正确的方法的呢？在这个例子中，是通过被称为Protocol Witness Table的基于表的机制。每个实现协议的类型中都有这么一张表，并且表中的条目会链接到类型中的具体实现。 那么 现在我们了解了如何找到那个方法，如何把元素从数组中拿到表中仍然有个问题。 还有另一个问题，请注意，我们现在有数值类型的Point和Line，Line需要四个字，而Point需要两个字，它们的大小不一样。 但数组需要以一致的固定偏移量存储元素，那是如何实现的呢？ 这个问题的答案是，Swift使用一个特殊存储布局叫存在容器(Existential Container)。 存在容器内的前三个字是留给valueBuffer的。小类型，比如我们的Point类型只需要两个字，刚好能放进valueBuffer中。 而Line类型需要四个字，该把它放在哪呢？在这种情况下，Swift会在堆上分配内存，把值存入堆中，并将这块内存的地址指针存储在存在容器中。 现在 你看到了Point和Line之间的不同点，因此，存在容器无论如何得管理这个不同点，那么该如何实现呢？ 嗯，答案是，还是基于表的机制，在这个示例中，我们叫它 值证明表(Value Witness Table)。值证明表会管理值的有效期。 在程序中，每种类型都有一张表。现在，通过观察局部变量的有效期来看下这个表是如何运作的。 在协议类型的局部变量有效期的开始，Swift 在那个表内部调用了分配函数。在这个函数中，因为这个例子有一个Line值证明表，我们将在堆上分配内存，并给该内存存一个指针，存在容器的valueBuffer内。 下一步 Swift要将初始化局部变量的原始值复制到存在容器中，我们在这里有一个Point，所以值证明表的复制条目会做出正确的判断并把它在堆中分配的值复制到valueBuffer中。如果是Line则将值复制到valueBuffer存储的指针对应的堆内存上。 我们现在是在局部变量有效期的最后阶段，Swift会调用值证明表的 destruct 条目，这将递减可能包含在类型中的值的引用计数。 在最后，Swift会调用表中的deallocate函数，这将释放在堆上为值分配的内存。 那么，我们已经看到了 Swift 处理不同种类的值的一般性机制。但无论如何它仍需要进入这些表，对吧？ 嗯，答案很明显,在存在容器(Existential Container)中含有对值证明表(Value Witness Table)的引用。 如何进入协议证明表(Protocol Witness Table)呢？它是在存在容器中进行引用的。 我们已经了解了 Swift 管理协议类型的机制，现在我们来看个例子，看看运行中的存在容器。 1234567// Protocol Types // The Existential Container in action func drawACopy(local : Drawable) { local.draw() } let val : Drawable = Point() drawACopy(val) 在这个例子中，我们有一个函数，把协议类型参数当做局部参数，并在局部参数上执行draw方法。 程序会创建一个Drawable的局部变量，并用Point类型对其进行初始化。然后把这个局部变量作为参数传给一个drawACopy函数调用。 为了显示Swift编译器为我们生成的代码，在这个例子中，我将使用Swift作为伪代码注释。 那么，对于存在容器(Existential Container)而言，下面这个结构体存储了valueBuffer的三个字，还有一个值证明表(VWT)和协议证明表(PWT)的引用。 当drawACopy函数调用执行时，它会接收实参并把它传给函数。在生成的代码中我们看到，Swift 把存在容器作为实参传给了函数，当函数开始执行时，函数为那个形参创建了一个局部变量，并给它赋了一个实参。 在所生成的代码中，Swift将在栈上分配一个存在容器。 然后，它将从实参存在容器中读取值证明表和协议证明表，并在局部实参容器中对字段进行初始化。 下一步，它将调用值证明函数分配valueBuffer，如果必要的话还会复制值。在这个例子中，我们传了一个Point，所以就不需要任何动态堆式分配了，这个函数只是从实参中把值复制到局部存在容器的valueBuffer中。然而，如果我们传一个Line，这个函数将会分配堆内存，并在堆中复制值。 下一步执行draw方法，Swift 会从存在容器字段中查询协议证明表(PWT)，在那个表的固定偏移中查询draw方法，并跳到那个实现。这里还有另一个值证明(VWT)调用，就是projectBuffer。draw方法把值的地址当成了它的输入。如果这里正好能放进valueBuffer的小值，返回的地址为存在容器的开始，若我们有一个大值不适合放进valueBuffer，那个地址就是在堆上分配的内存的开始。 然后draw方法执行完毕。 现在，程序执行到函数的末端，也就是说为形参创建的局部变量超出了适用范围，所以Swift调用值证明函数来destruct这个局部变量，如果值还有引用的话，这将递减引用计数，并且如果分配了valueBuffer，同样会释放缓冲区。 函数执行完毕，移除了栈，同时也移除了在堆栈上创建的局部存在容器。 一个简单的调用实际做了这么多事情。这些代价都是花在需要动态判断具体struct的信息和跳转到对应的方法上的。 这项工作是使结合的值类型,如结构体Point和结构体Line还有协议获得动态行为、动态多态性，我们可以存储一条线和一个点在Drawable的协议类型的数组中。如果你需要这个多态性，一切都值得你付出。 Protocol Type Stored Properties我们知道，Swift中Class的实例和属性都存储在堆区，Struct实例在栈区，如果包含指针属性则存储在堆区，Protocol Type如何存储属性？Small Number通过Existential Container内联实现，大数存在堆区。如何处理Copy呢？ 所以当出现大数的struct值时，会将新的Exsitential Container的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道Struct值的修改和Class不同，Copy是不应该影响原实例的值的。 这里直接使用引用语义会引发非计划的状态共享问题。 这里用到了一个技术叫做Indirect Storage With Copy-On-Write，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下： 1234567891011121314151617class LineStorage { var x1, y1, x2, y2:Double }struct Line :Drawable { var storage: LineStorage init() { storage = LineStorage(Point(), Point()) } func draw() { … } mutating func move() { if !isUniquelyReferencedNonObjc(&amp;storage) { //如何存在多份引用，则开启新内存，否则直接修改 storage = LineStorage(storage) } storage.start = ... }} Protocol Type 多态总结 支持Protocol Type的动态多态（Dynamic Polymorphism）行为。 通过使用Witness Table和Existential Container来实现。 对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。 说到动态多态Dynamic Polymorphism，我们就要问了，什么是静态多态Static Polymorphism，看看下面示例： 12345678910111213// Drawing a copyprotocol Drawable { func draw()}func drawACopy(local: Drawable) { local.draw()}let line = Line()drawACopy(line)// ...let point = Point()drawACopy(point) 这种情况我们就可以用到泛型Generic code来实现，进行进一步优化。 Generic我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和Protocol Type的区别在于： 泛型支持的是静态多态。 每个调用上下文只有一种类型。查看下面的示例，foo和bar方法是同一种类型。 在调用链中会通过类型降级进行类型取代。 对于以下示例： 1234567func foo&lt;T: Drawable&gt;(local: T) { bar(local)}func bar&lt;T: Drawable&gt;(local: T) { … }let point = Point()foo(point) 分析方法foo和bar的调用过程： 12foo(point) --&gt; foo&lt;T = Point&gt;(point) //在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Pointbar(local) --&gt; bar&lt;T = Point&gt;(local) //在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代 泛型方法调用的具体实现为： 同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。 使用Protocol/Value Witness Table。 每个调用上下文只有一种类型：这里没有使用Existential Container(当会在栈上分配valueBuffer存储值)，而是将Protocol/Value Witness Table作为调用方的额外参数进行传递。 变量初始化和方法调用，都使用传入的VWT和PWT来执行。 看到这里，我们并不觉得泛型比Protocol Type有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为特定泛型优化。 泛型特化 静态多态：在调用栈中只有一种类型。 Swift使用只有一种类型的特点，来进行类型降级取代。 类型降级后，产生特定类型的方法。 为泛型的每个类型创造对应的方法。这时候你可能会问，那每一种类型都产生一个新的方法，会生成更多的代码？ 静态多态下进行特定优化 specialization 。 因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。 例如：123func min&lt;T: Comparable&gt;(x: T, y: T) -&gt; T { return y &lt; x ? y : x} 从普通的泛型展开如下，因为要支持所有类型的min方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常复杂庞大的工程。12345678func min&lt;T:Comparable&gt;(x: T, y: T, FTable: FunctionTable) -&gt; T { let xCopy = FTable.copy(x) let yCopy = FTable.copy(y) let m = FTable.lessThan(yCopy， xCopy) ? y :x FTable.release(x) FTable.release(y) return m} 在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为： 123func min&lt;Int&gt;(x: Int, y: Int) -&gt; Int { return y &lt; x ? y :x} 泛型特化specilization是何时发生的? 在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了whole module optimization。而whole module optimization是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。 泛型进一步优化特定泛型的进一步优化： 123456789101112struct Pair&lt;T: Drawable&gt; { init(_ f: T， _ s: T) { first = f second = s } var first: T var second: T}let pairOfLines = Pair(Line(), Line())// ...let pairOfPoint = Pair(Point(), Point()) 在用到多种泛型，且确定泛型类型不会在运行时修改时，就可以对成对泛型的使用进行进一步优化。 优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调此种优化只适用于在运行时不会修改泛型类型，即不能同时支持一个方法中包含Line和Point两种类型。 Summary","link":"/2019/04/06/understanding-swift-performance/"},{"title":"Swift 标准库阅读笔记 - Dictionary","text":"OverviewDictionary 使用两种存储策略： 本地存储(Native Storage) 和 Cocoa 存储方式，这次的分析主要是 native 的部分。 Dictionary 内部只有一个成员变量_variant, 类型是_Varient。 1internal var _varient: _Varient 关于 _Variant 的定义在文件 DictionaryVarient 中， 1234567891011121314151617181920212223extension Dictionary { internal struct _Variant { internal var object: _BridgeStorage&lt;__RawDictionaryStorage&gt; init(native: __owned _NativeDictionary&lt;Key, Value&gt;) { self.object = _BridgeStorage(native: native._storage) } // 存储不需要桥接的原生类型 internal var asNative: _NativeDictionary&lt;Key, Value&gt; { get { return _NativeDictionary&lt;Key, Value&gt;(object.unflaggedNativeInstance) } set { self = .init(native: newValue) } } // 存储需要桥接的类型 internal var asCocoa: __CocoaDictionary { return __CocoaDictionary(object.objCInstance) } }} 同时， _Variant 也实现了 _DictionaryBuffer 接口， 用于在检查每个缓冲类型(asNative 与 asCocoa)都实现了需要的操作。 1234567891011121314151617internal protocol _DictionaryBuffer { associatedtype Key associatedtype Value associatedtype Index var startIndex: Index { get } var endIndex: Index { get } func index(after i: Index) -&gt; Index func index(forKey key: Key) -&gt; Index? var count: Int { get } func contains(_ key: Key) -&gt; Bool func lookup(_ key: Key) -&gt; Value? func lookup(_ index: Index) -&gt; (key: Key, value: Value) func key(at index: Index) -&gt; Key func value(at index: Index) -&gt; Value} 而用于存储不需要桥接类型的 _NativeDictionary 是 __RawDictionaryStorage 的包装类, 内部只有一个 __RawDictionaryStorage 类型的变量 _storage。 它还提供了一些方法将实际上有三个连续数组组成的字典内存转换成逻辑上的bucket数组。而且，这个结构体将bucket数组中的第一个bucket和最后一个bucket在逻辑上链接起来，从而形成了一个bucket环，也就是说当你到达bucket数组的末尾并且调用next方法时，你又会回到bucket数组的开头。 123456789101112131415161718192021222324internal struct _NativeDictionary&lt;Key: Hashable, Value&gt; { internal typealias Element = (key: Key, value: Value) /// See this comments on __RawDictionaryStorage and its subclasses to /// understand why we store an untyped storage here. internal var _storage: __RawDictionaryStorage /// Constructs an instance from the empty singleton. internal init() { self._storage = __RawDictionaryStorage.empty } /// Constructs a dictionary adopting the given storage. internal init(_ storage: __owned __RawDictionaryStorage) { self._storage = storage } internal var _keys: UnsafeMutablePointer&lt;Key&gt; { return _storage._rawKeys.assumingMemoryBound(to: Key.self) } internal var _values: UnsafeMutablePointer&lt;Value&gt; { return _storage._rawValues.assumingMemoryBound(to: Value.self) } 而 _BridgeStorage 实际上区分 class 与 @objc 两种可能性，从而提供不同的存储策略，为上层调用提供不同的接口以及类型判断。 通过 BuiltIn.BridgeObject 这个中间参数实现不同的存储策略。 结构体分配在栈上，而 __RawDictionaryStorage 相关的变量分配在堆里， 包括一些关于 Dictionary 的基本的属性，如count, capacity等。 在初始化 __RawDictionaryStorage 时，会在基本属性后分配真正存储字典键值的数组,_rawKeys 和 _rawValues 指向存储这些元素的地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static internal func allocate( scale: Int8, age: Int32?, seed: Int? ) -&gt; _DictionaryStorage { // The entry count must be representable by an Int value; hence the scale's // peculiar upper bound. _internalInvariant(scale &gt;= 0 &amp;&amp; scale &lt; Int.bitWidth - 1) // 这里 &amp; 应该是溢出操作符， bucketCount 的值 2 的 scale 次方 let bucketCount = (1 as Int) &amp;&lt;&lt; scale let wordCount = _UnsafeBitset.wordCount(forCapacity: bucketCount) let storage = Builtin.allocWithTailElems_3( _DictionaryStorage&lt;Key, Value&gt;.self, wordCount._builtinWordValue, _HashTable.Word.self, bucketCount._builtinWordValue, Key.self, bucketCount._builtinWordValue, Value.self) let metadataAddr = Builtin.projectTailElems(storage, _HashTable.Word.self) let keysAddr = Builtin.getTailAddr_Word( metadataAddr, wordCount._builtinWordValue, _HashTable.Word.self, Key.self) let valuesAddr = Builtin.getTailAddr_Word( keysAddr, bucketCount._builtinWordValue, Key.self, Value.self) storage._count = 0 storage._capacity = _HashTable.capacity(forScale: scale) storage._scale = scale storage._reservedScale = 0 storage._extra = 0 if let age = age { storage._age = age } else { // The default mutation count is simply a scrambled version of the storage // address. storage._age = Int32( truncatingIfNeeded: ObjectIdentifier(storage).hashValue) } storage._seed = seed ?? _HashTable.hashSeed(for: storage, scale: scale) storage._rawKeys = UnsafeMutableRawPointer(keysAddr) storage._rawValues = UnsafeMutableRawPointer(valuesAddr) // Initialize hash table metadata. storage._hashTable.clear() return storage } 下面我们通过 Dictionary 的插入，查找以及扩容这三个方面来看看 Swift 的具体实现。 Insert先看下当我们通常为Dictionary给定的 key 赋值时，会发生什么。 123456789public subscript(key: Key) -&gt; Value? { set(newValue) { if let x = newValue { _variant.setValue(x, forKey: key) } else { removeValue(forKey: key) } }} 在下标操作的 set 方法中，判断如果 newValue 不为 nil 的话，则调用 _Variant 实例的 setValue 方法来更新对应的值。 而在 _Variant 的 setValue 方法中，当存储的类型不需要进行桥接时，则继续调用 _NativeDictionary 的 setValue 方法。 123456789internal mutating func setValue(_ value: __owned Value, forKey key: Key, isUnique: Bool) { let (bucket, found) = mutatingFind(key, isUnique: isUnique) if found { // 如果给定的 key 已经存在，这里直接设置 values 数组里的值来更新 (_values + bucket.offset).pointee = value } else { _insert(at: bucket, key: key, value: value) }} 这里通过 mutatingFind 查找到合适的 bucket 来插入数据，如果已经存在则只更新 values 数组的值， 不存在则需要同时更新 keys 和 values 数组中的值。 mutatingFind 跟 find 功能类似，具体的区别下面会有更详细的介绍。 insert 具体的实现和调用的方法如下，根据bucket记录的偏移量来更新 keys 和 values 数组中数据。1234567891011121314151617internal func _insert(at bucket: Bucket, key: __owned Key, value: __owned Value) { _internalInvariant(count &lt; capacity) hashTable.insert(bucket) uncheckedInitialize(at: bucket, toKey: key, value: value) // 存储的数量+1 _storage._count += 1}// 更新和添加新键值对最终会调用的方法// HashTable 中 bucket 相当于记录每个槽中是否有数据，而真正的数据存储在 keys 和 values 的数组中internal func uncheckedInitialize(at bucket: Bucket, toKey key: __owned Key, value: __owned Value) { defer { _fixLifetime(self) } _internalInvariant(hashTable.isValid(bucket)) // keys &amp; value 数组对应的位置分别初始化值 (_keys + bucket.offset).initialize(to: key) (_values + bucket.offset).initialize(to: value)} 而在 HashTable 中的 insert 方法其实只更新了标志位中的数据，标记这个 bucket 已经存入数据。1234internal func insert(_ bucket: Bucket) { _internalInvariant(!isOccupied(bucket)) words[bucket.word].uncheckedInsert(bucket.bit)} 下面看看查找给定 key 对应的值时，Dictionary 做了些什么。 Find当我们通过 Dictionary 的下标操作来查找给定 key 对应的数据时，会调用 _Variant 的 lookup 方法。 12345public subscript(key: Key) -&gt; Value? { get { return _variant.lookup(key) }} 而在_Variant中，如果字典中存储的是原生类型，则调用 _NativeDictionary 实例的 lookup 方法。 lookup 会调用 find 方法，查找应该插入的 bucket，之后在对应的 bucket 位置更新或者添加数据就可以。12345678910111213141516171819202122232425262728293031323334353637func lookup(_ key: Key) -&gt; Value? { if count == 0 { // Fast path that avoids computing the hash of the key. return nil } let (bucket, found) = self.find(key) // 不存在对应的 bucket，返回 nil guard found else { return nil } return self.uncheckedValue(at: bucket)}internal func find(_ key: Key) -&gt; (bucket: Bucket, found: Bool) { return find(key, hashValue: self.hashValue(for: key))}// 返回给定 key 的哈希值, Key 遵守 Hashable 协议internal func hashValue(for key: Key) -&gt; Int { return key._rawHashValue(seed: _storage._seed)}// 对于给定的 key 以及其 hashValue， 查找哈希表中对应的 bucket。 // 若不存在，则返回给定 key 应该存在的 bucket// 线性探测法internal func find(_ key: Key, hashValue: Int) -&gt; (bucket: Bucket, found: Bool) { let hashTable = self.hashTable var bucket = hashTable.idealBucket(forHashValue: hashValue) // 在哈希表中查找是否已经存在当前给定的bucket while hashTable._isOccupied(bucket) { // 当前 bucket 存在，且与给定的 key 匹配，返回当前 bucket if uncheckedKey(at: bucket) == key { return (bucket, true) } // bucket 赋值为下一个位置的 bucket bucket = hashTable.bucket(wrappedAfter: bucket) } return (bucket, false)} _HashTable 中包括了哈希冲突的处理，查找并且判断 bucket 的状态。 Swift 使用的散列函数，用与操作符代替了取模操作符，提高效率, 即 hashValue &amp; （bucketCount - 1）。 12345678910111213141516171819// 返回给定 hashValue 对应的 bucket, 这里使用与运算代替模运算，提供效率// bucketMask = bucketCount - 1internal func idealBucket(forHashValue hashValue: Int) -&gt; Bucket { return Bucket(offset: hashValue &amp; bucketMask)}// 判断给定的 bucket 是否存在，如果不存在这是一个可以插入数据的位置internal func _isOccupied(_ bucket: Bucket) -&gt; Bool { _internalInvariant(isValid(bucket)) return words[bucket.word].uncheckedContains(bucket.bit)}/// The next bucket after `bucket`, with wraparound at the end of the table.// 当存在哈希冲突时，返回给定 bucket 的下一个位置的 bucketinternal func bucket(wrappedAfter bucket: Bucket) -&gt; Bucket { // The bucket is less than bucketCount, which is power of two less than // Int.max. Therefore adding 1 does not overflow. return Bucket(offset: (bucket.offset &amp;+ 1) &amp; bucketMask)} Resize随着哈希表中元素的数量越来越多，发生碰撞的概率就越来越大，Swift 使用线性探测来处理冲突，就是一旦发生冲突，就去寻找下 一个空的散列表地址，而碰撞概率变大后，每次查找的次数也会增加，这样势必会影响哈希表的速度。 为了保证哈希表的效率，系统必须要在某个临界点进行扩容处理。该临界点在当哈希表中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知哈希表中元素的个数，那么预设元素的个数能够有效的提高性能。 下面我们来看看 Swift 是在什么时候进行扩容并且是如何进行扩容的。 上面我们看到更新或者添加新的键值对的过程中，会调用 _NativeDictionary 中的 mutatingFind 方法。 而 mutatingFind 与 find 的最大区别在于它假定我们会插入容器中不存在 key/value，或者更新已经存在的 key/value。 当 mutatingFind 返回时，会确保存储空间为唯一的持有，且插入新数据时有足够的容量。 ensureUnique 方法用来确认是否需要进行扩容, 如果需要则进行扩容和重哈希的操作。 如果当前 key/value 在 Dictionary 中不存在，我们假设需要插入这组数据，则需要的容量为当前键值对数量 + 1，即 count + 1。 如果进行了扩容及重哈希的话，返回 true。 // _NativeDictionary123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 internal mutating func mutatingFind(_ key: Key,isUnique: Bool) -&gt; (bucket: Bucket, found: Bool) { let (bucket, found) = find(key) // Prepare storage. // If `key` isn't in the dictionary yet, assume that this access will end // up inserting it. (If we guess wrong, we might needlessly expand // storage; that's fine.) Otherwise this can only be a removal or an // in-place mutation. let rehashed = ensureUnique( isUnique: isUnique, capacity: count + (found ? 0 : 1)) guard rehashed else { return (bucket, found) } let (b, f) = find(key) if f != found { KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self) } return (b, found)}/// Ensure storage of self is uniquely held and can hold at least `capacity`/// elements. Returns true if contents were rehashed.internal mutating func ensureUnique(isUnique: Bool, capacity: Int) -&gt; Bool { // 如果需要的容量仍小于当前容器的容量，则不需要扩容，返回false if _fastPath(capacity &lt;= self.capacity &amp;&amp; isUnique) { return false } // 如果Dictionary 被唯一引用，重新分配所需要的内存空间 if isUnique { resize(capacity: capacity) return true } // 所需的容量仍小于当前的容量，不需要重哈希 if capacity &lt;= self.capacity { copy() return false } // 重哈希的过程 copyAndResize(capacity: capacity) return true}internal mutating func resize(capacity: Int) { let capacity = Swift.max(capacity, self.capacity) let newStorage = _DictionaryStorage&lt;Key, Value&gt;.resize( original: _storage, capacity: capacity, move: true) let result = _NativeDictionary(newStorage) if count &gt; 0 { for bucket in hashTable { let key = (_keys + bucket.offset).move() let value = (_values + bucket.offset).move() result._unsafeInsertNew(key: key, value: value) } // Clear out old storage, ensuring that its deinit won't overrelease the // elements we've just moved out. _storage._hashTable.clear() _storage._count = 0 } _storage = result._storage}internal mutating func copyAndResize(capacity: Int) { let capacity = Swift.max(capacity, self.capacity) let newStorage = _DictionaryStorage&lt;Key, Value&gt;.resize( original: _storage, capacity: capacity, move: false) // 新扩容的空间 let result = _NativeDictionary(newStorage) if count &gt; 0 { for bucket in hashTable { // 在新的存储空间中插入原来 Dictionary 的键值对 result._unsafeInsertNew( // 这里取的是扩容前的 key 和 value key: self.uncheckedKey(at: bucket), value: self.uncheckedValue(at: bucket)) } } // 保存新扩容后的存储 _storage = result._storage}internal func _unsafeInsertNew(key: __owned Key, value: __owned Value) { _internalInvariant(count + 1 &lt;= capacity) let hashValue = self.hashValue(for: key) if _isDebugAssertConfiguration() { // In debug builds, perform a full lookup and trap if we detect duplicate // elements -- these imply that the Element type violates Hashable // requirements. This is generally more costly than a direct insertion, // because we'll need to compare elements in case of hash collisions. let (bucket, found) = find(key, hashValue: hashValue) guard !found else { KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self) } hashTable.insert(bucket) uncheckedInitialize(at: bucket, toKey: key, value: value) } else { // 在 HashTable 中插入对应的 bucket，标记为该bucket已存数据 let bucket = hashTable.insertNew(hashValue: hashValue) // 在 keys &amp; values 数组中插入键值 uncheckedInitialize(at: bucket, toKey: key, value: value) } _storage._count &amp;+= 1 } _DictionaryStorage 中 resize 方法会调用 _HashTable 的 scale 方法确定扩容后的总容量，然后重新分配空间。12345static internal func resize(original: __RawDictionaryStorage, capacity: Int, move: Bool) -&gt; _DictionaryStorage { let scale = _HashTable.scale(forCapacity: capacity) // 根据需要扩容的倍数来重新分配空间 return allocate(scale: scale, age: nil, seed: nil)} 在 _HashTable 中定义的最大装载因子和计算容量以及扩展倍数的方法。123456789101112131415161718192021222324252627282930313233343536// 返回最大装载因子0.75private static var maxLoadFactor: Double { get { return 3 / 4 }}// 返回扩容后的最大容量// scale 表示扩容的倍数，进行2倍的增长，容量 * 最大装载因子 = 最大容量internal static func capacity(forScale scale: Int8) -&gt; Int { let bucketCount = (1 as Int) &amp;&lt;&lt; scale return Int(Double(bucketCount) * maxLoadFactor)}internal static func scale(forCapacity capacity: Int) -&gt; Int8 { let capacity = Swift.max(capacity, 1) // 计算给定容量时和加载因子时所需要分配的最少空间 let minimumEntries = Swift.max( Int((Double(capacity) / maxLoadFactor).rounded(.up)), capacity + 1) // The actual number of entries we need to allocate is the lowest power of // two greater than or equal to the minimum entry count. Calculate its // exponent. // `binaryLogarithm` 即求log2 n // 这里是log2 N 求所容量需要增加的倍数 // (Swift.max(minimumEntries, 2) - 1)._binaryLogarithm() 当前增长的倍数， +1 表示扩容后的 let exponent = (Swift.max(minimumEntries, 2) - 1)._binaryLogarithm() + 1 _internalInvariant(exponent &gt;= 0 &amp;&amp; exponent &lt; Int.bitWidth) // The scale is the exponent corresponding to the bucket count. let scale = Int8(truncatingIfNeeded: exponent) _internalInvariant(self.capacity(forScale: scale) &gt;= capacity) return scale}internal func insertNew(hashValue: Int) -&gt; Bucket { let hole = nextHole(atOrAfter: idealBucket(forHashValue: hashValue)) insert(hole) return hole} 通过以上我们知道哈希表的容量必须是2的幂，那么为什么要这么设计呢？答案当然是为了性能。通过键的哈希值进行定位桶位置的时候，调用了一个 idealBucket(forHashValue hashValue: Int) 方法。 123internal func idealBucket(forHashValue hashValue: Int) -&gt; Bucket { return Bucket(offset: hashValue &amp; bucketMask)} 可以看到这里是将哈希值 hashValue 与桶数组的 length-1（实际上也是哈希表的容量-1）进行了一个与操作得出了对应的桶的位置，hash &amp; (bucketCount-1)。 但是为什么不采用 hashValue % bucketCount 这种计算方式呢？ 因为相比 %、/ 操作，采用&amp;运算会提高性能。 通过限制 bucketCount 是一个2的幂数，hashValue &amp; (bucketCount - 1)和 hashValue % bucketCount 结果是一致的。这就是为什么要限制容量必须是一个2的幂的原因。 举个简单的例子说明这两个操作的结果一致性： 假设有个 hashcode 是 311，对应的二进制是(1 0011 0111) length 为 16，对应的二进制位(1 0000) %操作：311 = 16 * 19 + 7；所以结果为7，二进制位(0111)； &amp;操作：(1 0011 0111) &amp; (0111) = 0111 = 7, 二进制位(0111) 1 0011 0111 = (1 0011 0000) + (0111) = (12^4 + 1 2^5 + 02^6 + 02^7 + 12^8 ) + 7 = 2^4(1 + 2 + 0 + 0 + 16) + 7 = 16 * 19 + 7; 和%操作一致。 如果length是一个2的幂的数，那么 length-1 就会变成一个 mask, 它会将 hashcode 低位取出来，hashcode 的低位实际就是余数，和取余操作相比，与操作会将性能提升很多。 最后看看 Dictionary 提供的一些具体的方法。 DictionaryDictionary 初始化方法： 12345678910/// Creates an empty dictionary.public init() { self.init(_native: _NativeDictionary())}// 创建一个空dict并提前指定最少的元素个数// 当你知道创建dict后要添加多少元素时，可以通过这个初始化方法来避免创建后的存储缓冲重新分配public init(minimumCapacity: Int) { _variant = _Variant(native: _NativeDictionary(capacity: minimumCapacity))} 1234567891011121314151617181920public init&lt;S: Sequence&gt;( uniqueKeysWithValues keysAndValues: __owned S ) where S.Element == (Key, Value) { if let d = keysAndValues as? Dictionary&lt;Key, Value&gt; { self = d return } var native = _NativeDictionary&lt;Key, Value&gt;( capacity: keysAndValues.underestimatedCount) // '_MergeError.keyCollision' is caught and handled with an appropriate // error message one level down, inside native.merge(_:...). We throw an // error instead of calling fatalError() directly because we want the // message to include the duplicate key, and the closure only has access to // the conflicting values. try! native.merge( keysAndValues, isUnique: true, uniquingKeysWith: { _, _ in throw _MergeError.keyCollision }) self.init(_native: native)} 通过给定的序列来创建 dict 时调用的初始化方法。 当我们想要通过给定键值对序列来创建 dict 时，可以通过指定 combine 闭包来决定在存在重复 Key 的情况下如何选择保留想要的 Value. 123456let pairsWithDuplicateKeys = [(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"b\", 4)]let firstValues = Dictionary(pairsWithDuplicateKeys, uniquingKeysWith: { (current, _) in current })// [\"b\": 2, \"a\": 1]let lastValues = Dictionary(pairsWithDuplicateKeys, uniquingKeysWith: { (_, new) in new })// [\"b\": 4, \"a\": 3] combine 闭包接收当前值与新的Value为参数，并返回在最终dict中需要保留的值。 调用的初始化方法如下： 1234567891011121314151617181920212223242526272829303132333435public init&lt;S: Sequence&gt;( _ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Element == (Key, Value) { var native = _NativeDictionary&lt;Key, Value&gt;( capacity: keysAndValues.underestimatedCount) try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine) self.init(_native: native)}// _NativeDictionary internal mutating func merge&lt;S: Sequence&gt;( _ keysAndValues: __owned S, isUnique: Bool, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Element == (Key, Value) { var isUnique = isUnique for (key, value) in keysAndValues { // let (bucket, found) = mutatingFind(key, isUnique: isUnique) isUnique = true if found { do { // 如果查找到有重复的key， newValue 设置为 combine 闭包中返回的值 let newValue = try combine(uncheckedValue(at: bucket), value) _values[bucket.offset] = newValue } catch _MergeError.keyCollision { fatalError(\"Duplicate values for key: '\\(k∏ey)'\") } } else { // 如果没有重复的key，直接将其插入到表中 _insert(at: bucket, key: key, value: value) } } } 123456public init&lt;S: Sequence&gt;( grouping values: __owned S, by keyForValue: (S.Element) throws -&gt; Key ) rethrows where Value == [S.Element] { try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))} 可以通过闭包来返回序列中元素在dict的Key。 123let students = [\"Kofi\", \"Abena\", \"Efua\", \"Kweku\", \"Akosua\"]let studentsByLetter = Dictionary(grouping: students, by: { $0.first! })// [\"E\": [\"Efua\"], \"K\": [\"Kofi\", \"Kweku\"], \"A\": [\"Abena\", \"Akosua\"]] 当需要返回满足指定条件的键值对的新dict时： 123456789101112131415public __consuming func filter( _ isIncluded: (Element) throws -&gt; Bool ) rethrows -&gt; [Key: Value] { // FIXME(performance): Try building a bitset of elements to keep, so that we // eliminate rehashings during insertion. var result = _NativeDictionary&lt;Key, Value&gt;() for element in self { if try isIncluded(element) { // 满足条件的键值对添加到result中 result.insertNew(key: element.key, value: element.value) } } return Dictionary(_native: result) }} 同时， Dictionary 满足 Collection 协议： 12345678910111213extension Dictionary: Collection { public typealias SubSequence = Slice&lt;Dictionary&gt; @inlinable public var startIndex: Index { return _variant.startIndex } @inlinable public var endIndex: Index { return _variant.endIndex }} Dictionary 的下标操作符实现, 通过 _Variant 实现的 _DictionaryBuffer 协议定义的接口方法, 根据字典中的具体类型来调用对应的 asNative 与 asCocoa 对应的方法。 12345678910111213141516public subscript(key: Key) -&gt; Value? { get { return _variant.lookup(key) } set(newValue) { if let x = newValue { _variant.setValue(x, forKey: key) } else { removeValue(forKey: key) } } _modify { defer { _fixLifetime(self) } yield &amp;_variant[key] } } 通过给定的key去访问对应的值时，如果没有给定的key，则返回默认的值。1234567891011121314151617181920public subscript( key: Key, default defaultValue: @autoclosure () -&gt; Value ) -&gt; Value { @inline(__always) get { return _variant.lookup(key) ?? defaultValue() } @inline(__always) _modify { let (bucket, found) = _variant.mutatingFind(key) let native = _variant.asNative if !found { let value = defaultValue() native._insert(at: bucket, key: key, value: value) } let address = native._values + bucket.offset defer { _fixLifetime(self) } yield &amp;address.pointee } } 用法：12345678910111213var responseMessages = [200: \"OK\", 403: \"Access forbidden\", 404: \"File not found\", 500: \"Internal server error\"]let httpResponseCodes = [200, 403, 301]for code in httpResponseCodes { let message = responseMessages[code, default: \"Unknown response\"] print(\"Response \\(code): \\(message)\")}// Prints \"Response 200: OK\"// Prints \"Response 403: Access Forbidden\"// Prints \"Response 301: Unknown response\" 返回通过给定的 transform 闭包对字典中的 Value 进行映射后的新字典。时间复杂度 O(n)。123456789101112131415161718192021222324252627282930313233343536 public func mapValues&lt;T&gt;( _ transform: (Value) throws -&gt; T ) rethrows -&gt; Dictionary&lt;Key, T&gt; { return try Dictionary&lt;Key, T&gt;(_native: _variant.mapValues(transform)) }// Dictionary._Varientinternal func mapValues&lt;T&gt;( _ transform: (Value) throws -&gt; T ) rethrows -&gt; _NativeDictionary&lt;Key, T&gt; {#if _runtime(_ObjC) guard isNative else { return try asCocoa.mapValues(transform) }#endif return try asNative.mapValues(transform) }// _NativeDictionary internal func mapValues&lt;T&gt;( _ transform: (Value) throws -&gt; T ) rethrows -&gt; _NativeDictionary&lt;Key, T&gt; { let resultStorage = _DictionaryStorage&lt;Key, T&gt;.copy(original: _storage) _internalInvariant(resultStorage._seed == _storage._seed) let result = _NativeDictionary&lt;Key, T&gt;(resultStorage) // Because the current and new buffer have the same scale and seed, we can // initialize to the same locations in the new buffer, skipping hash value // recalculations. for bucket in hashTable { let key = self.uncheckedKey(at: bucket) let value = self.uncheckedValue(at: bucket) try result._insert(at: bucket, key: key, value: transform(value)) } return result } 对应的compactMap版本，只返回非 nil 的 value。 1234567891011public func compactMapValues&lt;T&gt;( _ transform: (Value) throws -&gt; T? ) rethrows -&gt; Dictionary&lt;Key, T&gt; { let result: _NativeDictionary&lt;Key, T&gt; = try self.reduce(into: _NativeDictionary&lt;Key, T&gt;()) { (result, element) in if let value = try transform(element.value) { result.insertNew(key: element.key, value: value) } } return Dictionary&lt;Key, T&gt;(_native: result) } 使用实例： 1234567let data = [\"a\": \"1\", \"b\": \"three\", \"c\": \"///4///\"]let m: [String: Int?] = data.mapValues { str in Int(str) }// [\"a\": 1, \"b\": nil, \"c\": nil]let c: [String: Int] = data.compactMapValues { str in Int(str) }// [\"a\": 1] 同上面的初始化方法， merge方法将键值对序列/字典合并到当前字典中，并且可以通过 combine 闭包来知道想要的 value。 1234567891011121314public mutating func merge&lt;S: Sequence&gt;( _ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows where S.Element == (Key, Value) { try _variant.merge(other, uniquingKeysWith: combine) } public mutating func merge( _ other: __owned [Key: Value], uniquingKeysWith combine: (Value, Value) throws -&gt; Value ) rethrows { try _variant.merge( other.lazy.map { ($0, $1) }, uniquingKeysWith: combine) } 合并当前字典与键值对序列/字典并且返回新的字典。12345678public __consuming func merging&lt;S: Sequence&gt;( _ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value) rethrows -&gt; [Key: Value] where S.Element == (Key, Value) { var result = self try result._variant.merge(other, uniquingKeysWith: combine) return result} 示例：1234567let dictionary = [\"a\": 1, \"b\": 2]let otherDictionary = [\"a\": 3, \"b\": 4]let keepingCurrent = dictionary.merging(otherDictionary) { (current, _) in current }// [\"b\": 2, \"a\": 1]let replacingCurrent = dictionary.merging(otherDictionary) { (_, new) in new }// [\"b\": 4, \"a\": 3] 返回当前字典索引key或者value的集合 12345678910111213public var keys: Keys { // FIXME(accessors): Provide a _read get { return Keys(_dictionary: self) }}public var values: Values { // FIXME(accessors): Provide a _read get { return Values(_dictionary: self) }} 翻完 Dictionary 的源码之后，感觉对 Swift 中哈希表的具体实现有了更清楚的认识，还有一些之前并没有注意到的比较实用的方法，如 merge 和 grouping等。以后要多花点时间来多看看标准库中的具体实现。","link":"/2019/06/02/swift-stl-dictionary/"}],"tags":[],"categories":[{"name":"Swift","slug":"Swift","link":"/categories/Swift/"}]}