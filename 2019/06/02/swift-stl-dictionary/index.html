<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->

    

    
        <meta name="description" content="OverviewDictionary 使用两种存储策略： 本地存储(Native Storage) 和 Cocoa 存储方式，这次的分析主要是 native 的部分。
Dictionary 内部只有一个成员变量_variant, 类型是_Varient。
1internal var _varient: _Varient
关于 _Variant 的定义在文件 DictionaryVarient 中，
1234567891011121314151617181920212223extension Dictionary &amp;#123;    internal struct _Variant &amp;#123;        internal var object: _BridgeStorage&amp;lt;__RawDictionaryStorage&amp;gt;        init(native: __owned _NativeDictionary&amp;lt;Key, Value&amp;gt;) &amp;#123;            self.object = _BridgeStorage(native: native._storage)        &amp;#125;        // 存储不需要桥接的原生类型        internal var asNative: _NativeDictionary&amp;lt;Key, Value&amp;gt; &amp;#123;            get &amp;#123;                return _NativeDictionary&amp;lt;Key, Value&amp;gt;(object.unflaggedNativeInstance)            &amp;#125;            set &amp;#123;                self = .init(native: newValue)            &amp;#125;        &amp;#125;        // 存储需要桥接的类型        internal var asCocoa: __CocoaDictionary &amp;#123;            return __CocoaDictionary(object.objCInstance)        &amp;#125;    &amp;#125;&amp;#125;
同时， _Variant 也实现了 _DictionaryBuffer 接口， 用于在检查每个缓冲类型(asNative 与 asCocoa)都实现了需要的操作。">
    

    <!--Author-->
    
        <meta name="author" content="Phillip">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Swift 标准库阅读笔记 - Dictionary">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="OverviewDictionary 使用两种存储策略： 本地存储(Native Storage) 和 Cocoa 存储方式，这次的分析主要是 native 的部分。
Dictionary 内部只有一个成员变量_variant, 类型是_Varient。
1internal var _varient: _Varient
关于 _Variant 的定义在文件 DictionaryVarient 中，
1234567891011121314151617181920212223extension Dictionary &amp;#123;    internal struct _Variant &amp;#123;        internal var object: _BridgeStorage&amp;lt;__RawDictionaryStorage&amp;gt;        init(native: __owned _NativeDictionary&amp;lt;Key, Value&amp;gt;) &amp;#123;            self.object = _BridgeStorage(native: native._storage)        &amp;#125;        // 存储不需要桥接的原生类型        internal var asNative: _NativeDictionary&amp;lt;Key, Value&amp;gt; &amp;#123;            get &amp;#123;                return _NativeDictionary&amp;lt;Key, Value&amp;gt;(object.unflaggedNativeInstance)            &amp;#125;            set &amp;#123;                self = .init(native: newValue)            &amp;#125;        &amp;#125;        // 存储需要桥接的类型        internal var asCocoa: __CocoaDictionary &amp;#123;            return __CocoaDictionary(object.objCInstance)        &amp;#125;    &amp;#125;&amp;#125;
同时， _Variant 也实现了 _DictionaryBuffer 接口， 用于在检查每个缓冲类型(asNative 与 asCocoa)都实现了需要的操作。">
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Phillip的技术博客">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.comhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg">
    

        <meta name="twitter:card" content="summary_large_image">

    

    
        <meta name="twitter:image" content="http://yoursite.comhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg">
    

    <!-- Title -->
    
    <title>Swift 标准库阅读笔记 - Dictionary - Phillip的技术博客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Phillip的技术博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/awind">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Swift 标准库阅读笔记 - Dictionary</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2019-06-02
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/Swift/">Swift</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p><img src="/images/Dictionary-Swift.png" alt="Dictionary-Swift"></p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>Dictionary</code> 使用两种存储策略： 本地存储(Native Storage) 和 Cocoa 存储方式，这次的分析主要是 native 的部分。</p>
<p><code>Dictionary</code> 内部只有一个成员变量<code>_variant</code>, 类型是<code>_Varient</code>。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> _varient: _Varient</span><br></pre></td></tr></table></figure>
<p>关于 <code>_Variant</code> 的定义在文件 <code>DictionaryVarient</code> 中，</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">_Variant</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> object: _BridgeStorage&lt;__RawDictionaryStorage&gt;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">init</span>(native: __owned _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;) &#123;</span><br><span class="line">            <span class="hljs-keyword">self</span>.object = _BridgeStorage(native: native._storage)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 存储不需要桥接的原生类型</span></span><br><span class="line">        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> asNative: _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;(object.unflaggedNativeInstance)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">set</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">self</span> = .<span class="hljs-keyword">init</span>(native: newValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 存储需要桥接的类型</span></span><br><span class="line">        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> asCocoa: __CocoaDictionary &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> __CocoaDictionary(object.objCInstance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时， <code>_Variant</code> 也实现了 <code>_DictionaryBuffer</code> 接口， 用于在检查每个缓冲类型(<code>asNative</code> 与 <code>asCocoa</code>)都实现了需要的操作。</p>
<a id="more"></a>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">_DictionaryBuffer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Key</span></span><br><span class="line">    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Value</span></span><br><span class="line">    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> startIndex: <span class="hljs-type">Index</span> &#123; <span class="hljs-keyword">get</span> &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> endIndex: <span class="hljs-type">Index</span> &#123; <span class="hljs-keyword">get</span> &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(after i: Index)</span></span> -&gt; <span class="hljs-type">Index</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(forKey key: Key)</span></span> -&gt; <span class="hljs-type">Index?</span></span><br><span class="line">    <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-number">_</span> key: Key)</span></span> -&gt; <span class="hljs-type">Bool</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-number">_</span> key: Key)</span></span> -&gt; <span class="hljs-type">Value?</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-number">_</span> index: Index)</span></span> -&gt; (key: <span class="hljs-type">Key</span>, value: <span class="hljs-type">Value</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">key</span><span class="hljs-params">(at index: Index)</span></span> -&gt; <span class="hljs-type">Key</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(at index: Index)</span></span> -&gt; <span class="hljs-type">Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而用于存储不需要桥接类型的 <code>_NativeDictionary</code> 是 <code>__RawDictionaryStorage</code> 的包装类, 内部只有一个 <code>__RawDictionaryStorage</code> 类型的变量 <code>_storage</code>。</p>
<p>它还提供了一些方法将实际上有三个连续数组组成的字典内存转换成逻辑上的bucket数组。而且，这个结构体将bucket数组中的第一个bucket和最后一个bucket在逻辑上链接起来，从而形成了一个bucket环，也就是说当你到达bucket数组的末尾并且调用next方法时，你又会回到bucket数组的开头。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">_NativeDictionary</span>&lt;<span class="hljs-title">Key</span>: <span class="hljs-title">Hashable</span>, <span class="hljs-title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">Element</span> = (key: <span class="hljs-type">Key</span>, value: <span class="hljs-type">Value</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/// See this comments on __RawDictionaryStorage and its subclasses to</span></span><br><span class="line">    <span class="hljs-comment">/// understand why we store an untyped storage here.</span></span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> _storage: __RawDictionaryStorage</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/// Constructs an instance from the empty singleton.</span></span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">init</span>() &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>._storage = __RawDictionaryStorage.empty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/// Constructs a dictionary adopting the given storage.</span></span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> storage: __owned __RawDictionaryStorage) &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>._storage = storage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> _keys: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Key</span>&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> _storage._rawKeys.assumingMemoryBound(to: <span class="hljs-type">Key</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> _values: <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Value</span>&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> _storage._rawValues.assumingMemoryBound(to: <span class="hljs-type">Value</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>_BridgeStorage</code> 实际上区分 <code>class</code> 与 <code>@objc</code> 两种可能性，从而提供不同的存储策略，为上层调用提供不同的接口以及类型判断。 通过 <code>BuiltIn.BridgeObject</code> 这个中间参数实现不同的存储策略。</p>
<p>结构体分配在栈上，而 <code>__RawDictionaryStorage</code> 相关的变量分配在堆里， 包括一些关于 <code>Dictionary</code> 的基本的属性，如count, capacity等。 在初始化 __RawDictionaryStorage 时，会在基本属性后分配真正存储字典键值的数组,<code>_rawKeys</code> 和 <code>_rawValues</code> 指向存储这些元素的地址。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocate</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    scale: Int8,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    age: Int32?,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    seed: Int?</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  )</span></span> -&gt; _DictionaryStorage &#123;</span><br><span class="line">    <span class="hljs-comment">// The entry count must be representable by an Int value; hence the scale's</span></span><br><span class="line">    <span class="hljs-comment">// peculiar upper bound.</span></span><br><span class="line">    _internalInvariant(scale &gt;= <span class="hljs-number">0</span> &amp;&amp; scale &lt; <span class="hljs-type">Int</span>.bitWidth - <span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 这里 &amp; 应该是溢出操作符， bucketCount 的值 2 的 scale 次方</span></span><br><span class="line">    <span class="hljs-keyword">let</span> bucketCount = (<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">Int</span>) &amp;&lt;&lt; scale</span><br><span class="line">    <span class="hljs-keyword">let</span> wordCount = _UnsafeBitset.wordCount(forCapacity: bucketCount)</span><br><span class="line">    <span class="hljs-keyword">let</span> storage = <span class="hljs-type">Builtin</span>.allocWithTailElems_3(</span><br><span class="line">      _DictionaryStorage&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;.<span class="hljs-keyword">self</span>,</span><br><span class="line">      wordCount._builtinWordValue, _HashTable.<span class="hljs-type">Word</span>.<span class="hljs-keyword">self</span>,</span><br><span class="line">      bucketCount._builtinWordValue, <span class="hljs-type">Key</span>.<span class="hljs-keyword">self</span>,</span><br><span class="line">      bucketCount._builtinWordValue, <span class="hljs-type">Value</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">let</span> metadataAddr = <span class="hljs-type">Builtin</span>.projectTailElems(storage, _HashTable.<span class="hljs-type">Word</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">    <span class="hljs-keyword">let</span> keysAddr = <span class="hljs-type">Builtin</span>.getTailAddr_Word(</span><br><span class="line">      metadataAddr, wordCount._builtinWordValue, _HashTable.<span class="hljs-type">Word</span>.<span class="hljs-keyword">self</span>,</span><br><span class="line">      <span class="hljs-type">Key</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">    <span class="hljs-keyword">let</span> valuesAddr = <span class="hljs-type">Builtin</span>.getTailAddr_Word(</span><br><span class="line">      keysAddr, bucketCount._builtinWordValue, <span class="hljs-type">Key</span>.<span class="hljs-keyword">self</span>,</span><br><span class="line">      <span class="hljs-type">Value</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">    storage._count = <span class="hljs-number">0</span></span><br><span class="line">    storage._capacity = _HashTable.capacity(forScale: scale)</span><br><span class="line">    storage._scale = scale</span><br><span class="line">    storage._reservedScale = <span class="hljs-number">0</span></span><br><span class="line">    storage._extra = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> age = age &#123;</span><br><span class="line">      storage._age = age</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// The default mutation count is simply a scrambled version of the storage</span></span><br><span class="line">      <span class="hljs-comment">// address.</span></span><br><span class="line">      storage._age = <span class="hljs-type">Int32</span>(</span><br><span class="line">        truncatingIfNeeded: <span class="hljs-type">ObjectIdentifier</span>(storage).hashValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    storage._seed = seed ?? _HashTable.hashSeed(<span class="hljs-keyword">for</span>: storage, scale: scale)</span><br><span class="line">    storage._rawKeys = <span class="hljs-type">UnsafeMutableRawPointer</span>(keysAddr)</span><br><span class="line">    storage._rawValues = <span class="hljs-type">UnsafeMutableRawPointer</span>(valuesAddr)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Initialize hash table metadata.</span></span><br><span class="line">    storage._hashTable.clear()</span><br><span class="line">    <span class="hljs-keyword">return</span> storage</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们通过 Dictionary 的插入，查找以及扩容这三个方面来看看 Swift 的具体实现。</p>
<h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>先看下当我们通常为<code>Dictionary</code>给定的 key 赋值时，会发生什么。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(key: <span class="hljs-type">Key</span>) -&gt; <span class="hljs-type">Value?</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> x = newValue &#123;</span><br><span class="line">        _variant.setValue(x, forKey: key)</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        removeValue(forKey: key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下标操作的 <code>set</code> 方法中，判断如果 newValue 不为 nil 的话，则调用 <code>_Variant</code> 实例的 <code>setValue</code> 方法来更新对应的值。</p>
<p>而在 <code>_Variant</code> 的 setValue 方法中，当存储的类型不需要进行桥接时，则继续调用 <code>_NativeDictionary</code> 的 <code>setValue</code> 方法。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-number">_</span> value: __owned Value, forKey key: Key, isUnique: Bool)</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> (bucket, found) = mutatingFind(key, isUnique: isUnique)</span><br><span class="line">    <span class="hljs-keyword">if</span> found &#123;</span><br><span class="line">      <span class="hljs-comment">// 如果给定的 key 已经存在，这里直接设置 values 数组里的值来更新</span></span><br><span class="line">      (_values + bucket.offset).pointee = value</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      _insert(at: bucket, key: key, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>mutatingFind</code> 查找到合适的 <code>bucket</code> 来插入数据，如果已经存在则只更新 values 数组的值， 不存在则需要同时更新 keys 和 values 数组中的值。</p>
<p><code>mutatingFind</code> 跟 <code>find</code> 功能类似，具体的区别下面会有更详细的介绍。 </p>
<p><code>insert</code> 具体的实现和调用的方法如下，根据bucket记录的偏移量来更新 <code>keys</code> 和 <code>values</code> 数组中数据。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_insert</span><span class="hljs-params">(at bucket: Bucket, key: __owned Key, value: __owned Value)</span></span> &#123;</span><br><span class="line">    _internalInvariant(<span class="hljs-built_in">count</span> &lt; capacity)</span><br><span class="line">    hashTable.insert(bucket)</span><br><span class="line">    uncheckedInitialize(at: bucket, toKey: key, value: value)</span><br><span class="line">    <span class="hljs-comment">// 存储的数量+1</span></span><br><span class="line">    _storage._count += <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 更新和添加新键值对最终会调用的方法</span></span><br><span class="line"><span class="hljs-comment">// HashTable 中 bucket 相当于记录每个槽中是否有数据，而真正的数据存储在 keys 和 values 的数组中</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uncheckedInitialize</span><span class="hljs-params">(at bucket: Bucket, toKey key: __owned Key, value: __owned Value)</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">defer</span> &#123; _fixLifetime(<span class="hljs-keyword">self</span>) &#125;</span><br><span class="line">    _internalInvariant(hashTable.isValid(bucket))</span><br><span class="line">    <span class="hljs-comment">// keys &amp; value 数组对应的位置分别初始化值</span></span><br><span class="line">    (_keys + bucket.offset).initialize(to: key)</span><br><span class="line">    (_values + bucket.offset).initialize(to: value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在 <code>HashTable</code> 中的 <code>insert</code> 方法其实只更新了标志位中的数据，标记这个 <code>bucket</code> 已经存入数据。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-number">_</span> bucket: Bucket)</span></span> &#123;</span><br><span class="line">    _internalInvariant(!isOccupied(bucket))</span><br><span class="line">    words[bucket.word].uncheckedInsert(bucket.bit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面看看查找给定 <code>key</code> 对应的值时，<code>Dictionary</code> 做了些什么。</p>
<h2 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h2><p>当我们通过 <code>Dictionary</code> 的下标操作来查找给定 <code>key</code> 对应的数据时，会调用 <code>_Variant</code> 的 <code>lookup</code> 方法。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(key: <span class="hljs-type">Key</span>) -&gt; <span class="hljs-type">Value?</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> _variant.lookup(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在_Variant中，如果字典中存储的是原生类型，则调用 <code>_NativeDictionary</code> 实例的 <code>lookup</code> 方法。</p>
<p><code>lookup</code> 会调用 <code>find</code> 方法，查找应该插入的 <code>bucket</code>，之后在对应的 <code>bucket</code> 位置更新或者添加数据就可以。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-number">_</span> key: Key)</span></span> -&gt; <span class="hljs-type">Value?</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">count</span> == <span class="hljs-number">0</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// Fast path that avoids computing the hash of the key.</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> (bucket, found) = <span class="hljs-keyword">self</span>.<span class="hljs-built_in">find</span>(key)</span><br><span class="line">    <span class="hljs-comment">// 不存在对应的 bucket，返回 nil</span></span><br><span class="line">    <span class="hljs-keyword">guard</span> found <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.uncheckedValue(at: bucket)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-number">_</span> key: Key)</span></span> -&gt; (bucket: <span class="hljs-type">Bucket</span>, found: <span class="hljs-type">Bool</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(key, hashValue: <span class="hljs-keyword">self</span>.hashValue(<span class="hljs-keyword">for</span>: key))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 返回给定 key 的哈希值, Key 遵守 Hashable 协议</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hashValue</span><span class="hljs-params">(<span class="hljs-keyword">for</span> key: Key)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> key._rawHashValue(seed: _storage._seed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 对于给定的 key 以及其 hashValue， 查找哈希表中对应的 bucket。 </span></span><br><span class="line"><span class="hljs-comment">// 若不存在，则返回给定 key 应该存在的 bucket</span></span><br><span class="line"><span class="hljs-comment">// 线性探测法</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-number">_</span> key: Key, hashValue: Int)</span></span> -&gt; (bucket: <span class="hljs-type">Bucket</span>, found: <span class="hljs-type">Bool</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> hashTable = <span class="hljs-keyword">self</span>.hashTable</span><br><span class="line">    <span class="hljs-keyword">var</span> bucket = hashTable.idealBucket(forHashValue: hashValue)</span><br><span class="line">    <span class="hljs-comment">// 在哈希表中查找是否已经存在当前给定的bucket</span></span><br><span class="line">    <span class="hljs-keyword">while</span> hashTable._isOccupied(bucket) &#123;</span><br><span class="line">        <span class="hljs-comment">// 当前 bucket 存在，且与给定的 key 匹配，返回当前 bucket</span></span><br><span class="line">      <span class="hljs-keyword">if</span> uncheckedKey(at: bucket) == key &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (bucket, <span class="hljs-literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">// bucket 赋值为下一个位置的 bucket</span></span><br><span class="line">      bucket = hashTable.bucket(wrappedAfter: bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> (bucket, <span class="hljs-literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>_HashTable</code> 中包括了哈希冲突的处理，查找并且判断 <code>bucket</code> 的状态。</p>
<p>Swift 使用的散列函数，用与操作符代替了取模操作符，提高效率, 即 <code>hashValue &amp; （bucketCount - 1）</code>。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 返回给定 hashValue 对应的 bucket, 这里使用与运算代替模运算，提供效率</span></span><br><span class="line"><span class="hljs-comment">// bucketMask = bucketCount - 1</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">idealBucket</span><span class="hljs-params">(forHashValue hashValue: Int)</span></span> -&gt; <span class="hljs-type">Bucket</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Bucket</span>(offset: hashValue &amp; bucketMask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 判断给定的 bucket 是否存在，如果不存在这是一个可以插入数据的位置</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_isOccupied</span><span class="hljs-params">(<span class="hljs-number">_</span> bucket: Bucket)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;</span><br><span class="line">    _internalInvariant(isValid(bucket))</span><br><span class="line">    <span class="hljs-keyword">return</span> words[bucket.word].uncheckedContains(bucket.bit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// The next bucket after `bucket`, with wraparound at the end of the table.</span></span><br><span class="line"><span class="hljs-comment">// 当存在哈希冲突时，返回给定 bucket 的下一个位置的 bucket</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bucket</span><span class="hljs-params">(wrappedAfter bucket: Bucket)</span></span> -&gt; <span class="hljs-type">Bucket</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The bucket is less than bucketCount, which is power of two less than</span></span><br><span class="line">    <span class="hljs-comment">// Int.max. Therefore adding 1 does not overflow.</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Bucket</span>(offset: (bucket.offset &amp;+ <span class="hljs-number">1</span>) &amp; bucketMask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h2><p>随着哈希表中元素的数量越来越多，发生碰撞的概率就越来越大，Swift 使用线性探测来处理冲突，就是一旦发生冲突，就去寻找下 一个空的散列表地址，而碰撞概率变大后，每次查找的次数也会增加，这样势必会影响哈希表的速度。</p>
<p>为了保证哈希表的效率，系统必须要在某个临界点进行扩容处理。该临界点在当哈希表中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知哈希表中元素的个数，那么预设元素的个数能够有效的提高性能。</p>
<p>下面我们来看看 Swift 是在什么时候进行扩容并且是如何进行扩容的。</p>
<p>上面我们看到更新或者添加新的键值对的过程中，会调用 <code>_NativeDictionary</code> 中的 <code>mutatingFind</code> 方法。 而 <code>mutatingFind</code> 与 <code>find</code> 的最大区别在于它假定我们会插入容器中不存在 key/value，或者更新已经存在的 key/value。 当 <code>mutatingFind</code> 返回时，会确保存储空间为唯一的持有，且插入新数据时有足够的容量。 </p>
<p><code>ensureUnique</code> 方法用来确认是否需要进行扩容, 如果需要则进行扩容和重哈希的操作。 如果当前 <code>key/value</code> 在 <code>Dictionary</code> 中不存在，我们假设需要插入这组数据，则需要的容量为当前键值对数量 + 1，即 <code>count + 1</code>。 如果进行了扩容及重哈希的话，返回 <code>true</code>。</p>
<p>// _NativeDictionary<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutatingFind</span><span class="hljs-params">(<span class="hljs-number">_</span> key: Key,isUnique: Bool)</span></span> -&gt; (bucket: <span class="hljs-type">Bucket</span>, found: <span class="hljs-type">Bool</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> (bucket, found) = <span class="hljs-built_in">find</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Prepare storage.</span></span><br><span class="line">    <span class="hljs-comment">// If `key` isn't in the dictionary yet, assume that this access will end</span></span><br><span class="line">    <span class="hljs-comment">// up inserting it. (If we guess wrong, we might needlessly expand</span></span><br><span class="line">    <span class="hljs-comment">// storage; that's fine.) Otherwise this can only be a removal or an</span></span><br><span class="line">    <span class="hljs-comment">// in-place mutation.</span></span><br><span class="line">    <span class="hljs-keyword">let</span> rehashed = ensureUnique(</span><br><span class="line">      isUnique: isUnique,</span><br><span class="line">      capacity: <span class="hljs-built_in">count</span> + (found ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>))</span><br><span class="line">    <span class="hljs-keyword">guard</span> rehashed <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> (bucket, found) &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> (b, f) = <span class="hljs-built_in">find</span>(key)</span><br><span class="line">    <span class="hljs-keyword">if</span> f != found &#123;</span><br><span class="line">      <span class="hljs-type">KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS</span>(<span class="hljs-type">Key</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> (b, found)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// Ensure storage of self is uniquely held and can hold at least `capacity`</span></span><br><span class="line"><span class="hljs-comment">/// elements. Returns true if contents were rehashed.</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ensureUnique</span><span class="hljs-params">(isUnique: Bool, capacity: Int)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;</span><br><span class="line">  <span class="hljs-comment">// 如果需要的容量仍小于当前容器的容量，则不需要扩容，返回false</span></span><br><span class="line">  <span class="hljs-keyword">if</span> _fastPath(capacity &lt;= <span class="hljs-keyword">self</span>.capacity &amp;&amp; isUnique) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 如果Dictionary 被唯一引用，重新分配所需要的内存空间</span></span><br><span class="line">  <span class="hljs-keyword">if</span> isUnique &#123;</span><br><span class="line">    resize(capacity: capacity)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 所需的容量仍小于当前的容量，不需要重哈希</span></span><br><span class="line">  <span class="hljs-keyword">if</span> capacity &lt;= <span class="hljs-keyword">self</span>.capacity &#123;</span><br><span class="line">    copy()</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 重哈希的过程</span></span><br><span class="line">  copyAndResize(capacity: capacity)</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resize</span><span class="hljs-params">(capacity: Int)</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> capacity = <span class="hljs-type">Swift</span>.<span class="hljs-built_in">max</span>(capacity, <span class="hljs-keyword">self</span>.capacity)</span><br><span class="line">    <span class="hljs-keyword">let</span> newStorage = _DictionaryStorage&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;.resize(</span><br><span class="line">      original: _storage,</span><br><span class="line">      capacity: capacity,</span><br><span class="line">      move: <span class="hljs-literal">true</span>)</span><br><span class="line">    <span class="hljs-keyword">let</span> result = _NativeDictionary(newStorage)</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">count</span> &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> hashTable &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> key = (_keys + bucket.offset).move()</span><br><span class="line">        <span class="hljs-keyword">let</span> value = (_values + bucket.offset).move()</span><br><span class="line">        result._unsafeInsertNew(key: key, value: value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">// Clear out old storage, ensuring that its deinit won't overrelease the</span></span><br><span class="line">      <span class="hljs-comment">// elements we've just moved out.</span></span><br><span class="line">      _storage._hashTable.clear()</span><br><span class="line">      _storage._count = <span class="hljs-number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    _storage = result._storage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyAndResize</span><span class="hljs-params">(capacity: Int)</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> capacity = <span class="hljs-type">Swift</span>.<span class="hljs-built_in">max</span>(capacity, <span class="hljs-keyword">self</span>.capacity)</span><br><span class="line">    <span class="hljs-keyword">let</span> newStorage = _DictionaryStorage&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;.resize(</span><br><span class="line">      original: _storage,</span><br><span class="line">      capacity: capacity,</span><br><span class="line">      move: <span class="hljs-literal">false</span>)</span><br><span class="line">    <span class="hljs-comment">// 新扩容的空间</span></span><br><span class="line">    <span class="hljs-keyword">let</span> result = _NativeDictionary(newStorage)</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">count</span> &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> hashTable &#123;</span><br><span class="line">        <span class="hljs-comment">// 在新的存储空间中插入原来 Dictionary 的键值对</span></span><br><span class="line">        result._unsafeInsertNew(</span><br><span class="line">          <span class="hljs-comment">// 这里取的是扩容前的 key 和 value</span></span><br><span class="line">          key: <span class="hljs-keyword">self</span>.uncheckedKey(at: bucket),</span><br><span class="line">          value: <span class="hljs-keyword">self</span>.uncheckedValue(at: bucket))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 保存新扩容后的存储</span></span><br><span class="line">    _storage = result._storage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_unsafeInsertNew</span><span class="hljs-params">(key: __owned Key, value: __owned Value)</span></span> &#123;</span><br><span class="line">    _internalInvariant(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span> &lt;= capacity)</span><br><span class="line">    <span class="hljs-keyword">let</span> hashValue = <span class="hljs-keyword">self</span>.hashValue(<span class="hljs-keyword">for</span>: key)</span><br><span class="line">    <span class="hljs-keyword">if</span> _isDebugAssertConfiguration() &#123;</span><br><span class="line">      <span class="hljs-comment">// In debug builds, perform a full lookup and trap if we detect duplicate</span></span><br><span class="line">      <span class="hljs-comment">// elements -- these imply that the Element type violates Hashable</span></span><br><span class="line">      <span class="hljs-comment">// requirements. This is generally more costly than a direct insertion,</span></span><br><span class="line">      <span class="hljs-comment">// because we'll need to compare elements in case of hash collisions.</span></span><br><span class="line">      <span class="hljs-keyword">let</span> (bucket, found) = <span class="hljs-built_in">find</span>(key, hashValue: hashValue)</span><br><span class="line">      <span class="hljs-keyword">guard</span> !found <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-type">KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS</span>(<span class="hljs-type">Key</span>.<span class="hljs-keyword">self</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      hashTable.insert(bucket)</span><br><span class="line">      uncheckedInitialize(at: bucket, toKey: key, value: value)</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// 在 HashTable 中插入对应的 bucket，标记为该bucket已存数据</span></span><br><span class="line">      <span class="hljs-keyword">let</span> bucket = hashTable.insertNew(hashValue: hashValue)</span><br><span class="line">      <span class="hljs-comment">// 在 keys &amp; values 数组中插入键值</span></span><br><span class="line">      uncheckedInitialize(at: bucket, toKey: key, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">    _storage._count &amp;+= <span class="hljs-number">1</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>_DictionaryStorage</code> 中 <code>resize</code> 方法会调用 <code>_HashTable</code> 的 <code>scale</code> 方法确定扩容后的总容量，然后重新分配空间。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resize</span><span class="hljs-params">(original: __RawDictionaryStorage, capacity: Int, move: Bool)</span></span> -&gt; _DictionaryStorage &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> scale = _HashTable.scale(forCapacity: capacity)</span><br><span class="line">    <span class="hljs-comment">// 根据需要扩容的倍数来重新分配空间</span></span><br><span class="line">    <span class="hljs-keyword">return</span> allocate(scale: scale, age: <span class="hljs-literal">nil</span>, seed: <span class="hljs-literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>_HashTable</code> 中定义的最大装载因子和计算容量以及扩展倍数的方法。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 返回最大装载因子0.75</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> maxLoadFactor: <span class="hljs-type">Double</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> / <span class="hljs-number">4</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 返回扩容后的最大容量</span></span><br><span class="line"><span class="hljs-comment">// scale 表示扩容的倍数，进行2倍的增长，容量 * 最大装载因子 = 最大容量</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">capacity</span><span class="hljs-params">(forScale scale: Int8)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> bucketCount = (<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">Int</span>) &amp;&lt;&lt; scale</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(<span class="hljs-type">Double</span>(bucketCount) * maxLoadFactor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(forCapacity capacity: Int)</span></span> -&gt; <span class="hljs-type">Int8</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> capacity = <span class="hljs-type">Swift</span>.<span class="hljs-built_in">max</span>(capacity, <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-comment">// 计算给定容量时和加载因子时所需要分配的最少空间</span></span><br><span class="line">    <span class="hljs-keyword">let</span> minimumEntries = <span class="hljs-type">Swift</span>.<span class="hljs-built_in">max</span>(</span><br><span class="line">      <span class="hljs-type">Int</span>((<span class="hljs-type">Double</span>(capacity) / maxLoadFactor).rounded(.up)),</span><br><span class="line">      capacity + <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-comment">// The actual number of entries we need to allocate is the lowest power of</span></span><br><span class="line">    <span class="hljs-comment">// two greater than or equal to the minimum entry count. Calculate its</span></span><br><span class="line">    <span class="hljs-comment">// exponent.</span></span><br><span class="line">    <span class="hljs-comment">// `binaryLogarithm` 即求log2 n</span></span><br><span class="line">    <span class="hljs-comment">// 这里是log2 N 求所容量需要增加的倍数</span></span><br><span class="line">    <span class="hljs-comment">// (Swift.max(minimumEntries, 2) - 1)._binaryLogarithm() 当前增长的倍数， +1 表示扩容后的</span></span><br><span class="line">    <span class="hljs-keyword">let</span> exponent = (<span class="hljs-type">Swift</span>.<span class="hljs-built_in">max</span>(minimumEntries, <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>)._binaryLogarithm() + <span class="hljs-number">1</span></span><br><span class="line">    _internalInvariant(exponent &gt;= <span class="hljs-number">0</span> &amp;&amp; exponent &lt; <span class="hljs-type">Int</span>.bitWidth)</span><br><span class="line">    <span class="hljs-comment">// The scale is the exponent corresponding to the bucket count.</span></span><br><span class="line">    <span class="hljs-keyword">let</span> scale = <span class="hljs-type">Int8</span>(truncatingIfNeeded: exponent)</span><br><span class="line">    _internalInvariant(<span class="hljs-keyword">self</span>.capacity(forScale: scale) &gt;= capacity)</span><br><span class="line">    <span class="hljs-keyword">return</span> scale</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertNew</span><span class="hljs-params">(hashValue: Int)</span></span> -&gt; <span class="hljs-type">Bucket</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> hole = nextHole(atOrAfter: idealBucket(forHashValue: hashValue))</span><br><span class="line">    insert(hole)</span><br><span class="line">    <span class="hljs-keyword">return</span> hole</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上我们知道哈希表的容量必须是2的幂，那么为什么要这么设计呢？答案当然是为了性能。通过键的哈希值进行定位桶位置的时候，调用了一个 <code>idealBucket(forHashValue hashValue: Int)</code> 方法。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">idealBucket</span><span class="hljs-params">(forHashValue hashValue: Int)</span></span> -&gt; <span class="hljs-type">Bucket</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Bucket</span>(offset: hashValue &amp; bucketMask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里是将哈希值 <code>hashValue</code> 与桶数组的 <code>length-1</code>（实际上也是哈希表的容量-1）进行了一个与操作得出了对应的桶的位置，<code>hash &amp; (bucketCount-1)</code>。</p>
<p>但是为什么不采用 <code>hashValue % bucketCount</code> 这种计算方式呢？ 因为相比 <code>%</code>、<code>/</code> 操作，采用&amp;运算会提高性能。</p>
<p>通过限制 <code>bucketCount</code> 是一个2的幂数，hashValue &amp; (bucketCount - 1)和 hashValue % bucketCount 结果是一致的。这就是为什么要限制容量必须是一个2的幂的原因。</p>
<p>举个简单的例子说明这两个操作的结果一致性：</p>
<p>假设有个 hashcode 是 311，对应的二进制是(1 0011 0111)</p>
<p>length 为 16，对应的二进制位(1 0000)</p>
<p>%操作：311 = 16 * 19 + 7；所以结果为7，二进制位(0111)；</p>
<p>&amp;操作：(1 0011 0111) &amp; (0111) = 0111 = 7, 二进制位(0111)</p>
<p>1 0011 0111 = (1 0011 0000) + (0111) = (1<em>2^4 + 1</em> 2^5 + 0<em>2^6 + 0</em>2^7 + 1<em>2^8 ) + 7 = 2^4</em>(1 + 2 + 0 + 0 + 16) + 7 = 16 * 19 + 7; 和%操作一致。</p>
<p>如果length是一个2的幂的数，那么 length-1 就会变成一个 mask, 它会将 hashcode 低位取出来，hashcode 的低位实际就是余数，和取余操作相比，与操作会将性能提升很多。</p>
<p>最后看看 <code>Dictionary</code> 提供的一些具体的方法。</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p><code>Dictionary</code> 初始化方法：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/// Creates an empty dictionary.</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() &#123;</span><br><span class="line">  <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(_native: _NativeDictionary())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 创建一个空dict并提前指定最少的元素个数</span></span><br><span class="line"><span class="hljs-comment">// 当你知道创建dict后要添加多少元素时，可以通过这个初始化方法来避免创建后的存储缓冲重新分配</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(minimumCapacity: <span class="hljs-type">Int</span>) &#123;</span><br><span class="line">   _variant = _Variant(native: _NativeDictionary(capacity: minimumCapacity))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">S</span>: <span class="hljs-type">Sequence</span>&gt;(</span><br><span class="line">    uniqueKeysWithValues keysAndValues: __owned <span class="hljs-type">S</span></span><br><span class="line">  ) <span class="hljs-keyword">where</span> <span class="hljs-type">S</span>.<span class="hljs-type">Element</span> == (<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> d = keysAndValues <span class="hljs-keyword">as</span>? <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt; &#123;</span><br><span class="line">      <span class="hljs-keyword">self</span> = d</span><br><span class="line">      <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> native = _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;(</span><br><span class="line">      capacity: keysAndValues.underestimatedCount)</span><br><span class="line">    <span class="hljs-comment">// '_MergeError.keyCollision' is caught and handled with an appropriate</span></span><br><span class="line">    <span class="hljs-comment">// error message one level down, inside native.merge(_:...). We throw an</span></span><br><span class="line">    <span class="hljs-comment">// error instead of calling fatalError() directly because we want the</span></span><br><span class="line">    <span class="hljs-comment">// message to include the duplicate key, and the closure only has access to</span></span><br><span class="line">    <span class="hljs-comment">// the conflicting values.</span></span><br><span class="line">    <span class="hljs-keyword">try</span>! native.merge(</span><br><span class="line">      keysAndValues,</span><br><span class="line">      isUnique: <span class="hljs-literal">true</span>,</span><br><span class="line">      uniquingKeysWith: &#123; <span class="hljs-number">_</span>, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">throw</span> _MergeError.keyCollision &#125;)</span><br><span class="line">    <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(_native: native)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过给定的序列来创建 dict 时调用的初始化方法。</p>
<p>当我们想要通过给定键值对序列来创建 dict 时，可以通过指定 <code>combine</code> 闭包来决定在存在重复 <code>Key</code> 的情况下如何选择保留想要的 <code>Value</code>.</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> pairsWithDuplicateKeys = [(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">"a"</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">"b"</span>, <span class="hljs-number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> firstValues = <span class="hljs-type">Dictionary</span>(pairsWithDuplicateKeys, uniquingKeysWith: &#123; (current, <span class="hljs-number">_</span>) <span class="hljs-keyword">in</span> current &#125;)</span><br><span class="line"><span class="hljs-comment">// ["b": 2, "a": 1]</span></span><br><span class="line"><span class="hljs-keyword">let</span> lastValues = <span class="hljs-type">Dictionary</span>(pairsWithDuplicateKeys, uniquingKeysWith: &#123; (<span class="hljs-number">_</span>, new) <span class="hljs-keyword">in</span> new &#125;)</span><br><span class="line"><span class="hljs-comment">// ["b": 4, "a": 3]</span></span><br></pre></td></tr></table></figure>
<p><code>combine</code> 闭包接收当前值与新的Value为参数，并返回在最终dict中需要保留的值。</p>
<p>调用的初始化方法如下：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">S</span>: <span class="hljs-type">Sequence</span>&gt;(</span><br><span class="line">    <span class="hljs-number">_</span> keysAndValues: __owned <span class="hljs-type">S</span>,</span><br><span class="line">    uniquingKeysWith combine: (<span class="hljs-type">Value</span>, <span class="hljs-type">Value</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Value</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> <span class="hljs-keyword">where</span> <span class="hljs-type">S</span>.<span class="hljs-type">Element</span> == (<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> native = _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;(</span><br><span class="line">      capacity: keysAndValues.underestimatedCount)</span><br><span class="line">    <span class="hljs-keyword">try</span> native.merge(keysAndValues, isUnique: <span class="hljs-literal">true</span>, uniquingKeysWith: combine)</span><br><span class="line">    <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(_native: native)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// _NativeDictionary  </span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span>&lt;S: Sequence&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> keysAndValues: __owned S,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    isUnique: Bool,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    uniquingKeysWith combine: <span class="hljs-params">(Value, Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Value</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> <span class="hljs-keyword">where</span> <span class="hljs-type">S</span>.<span class="hljs-type">Element</span> == (<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> isUnique = isUnique</span><br><span class="line">    <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> keysAndValues &#123;</span><br><span class="line">      <span class="hljs-comment">//</span></span><br><span class="line">      <span class="hljs-keyword">let</span> (bucket, found) = mutatingFind(key, isUnique: isUnique)</span><br><span class="line">      isUnique = <span class="hljs-literal">true</span></span><br><span class="line">      <span class="hljs-keyword">if</span> found &#123;</span><br><span class="line">        <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 如果查找到有重复的key， newValue 设置为 combine 闭包中返回的值</span></span><br><span class="line">          <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">try</span> combine(uncheckedValue(at: bucket), value)</span><br><span class="line">          _values[bucket.offset] = newValue</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> _MergeError.keyCollision &#123;</span><br><span class="line">          <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"Duplicate values for key: '\(k∏ey)'"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">          <span class="hljs-comment">// 如果没有重复的key，直接将其插入到表中</span></span><br><span class="line">        _insert(at: bucket, key: key, value: value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">S</span>: <span class="hljs-type">Sequence</span>&gt;(</span><br><span class="line">    grouping values: __owned <span class="hljs-type">S</span>,</span><br><span class="line">    by keyForValue: (<span class="hljs-type">S</span>.<span class="hljs-type">Element</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Key</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Value</span> == [<span class="hljs-type">S</span>.<span class="hljs-type">Element</span>] &#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(_native: _NativeDictionary(grouping: values, by: keyForValue))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过闭包来返回序列中元素在dict的Key。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> students = [<span class="hljs-string">"Kofi"</span>, <span class="hljs-string">"Abena"</span>, <span class="hljs-string">"Efua"</span>, <span class="hljs-string">"Kweku"</span>, <span class="hljs-string">"Akosua"</span>]</span><br><span class="line"><span class="hljs-keyword">let</span> studentsByLetter = <span class="hljs-type">Dictionary</span>(grouping: students, by: &#123; $<span class="hljs-number">0</span>.first! &#125;)</span><br><span class="line"><span class="hljs-comment">// ["E": ["Efua"], "K": ["Kofi", "Kweku"], "A": ["Abena", "Akosua"]]</span></span><br></pre></td></tr></table></figure>
<p>当需要返回满足指定条件的键值对的新dict时：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> __consuming <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> isIncluded: <span class="hljs-params">(Element)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Bool</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> -&gt; [<span class="hljs-type">Key</span>: <span class="hljs-type">Value</span>] &#123;</span><br><span class="line">    <span class="hljs-comment">// FIXME(performance): Try building a bitset of elements to keep, so that we</span></span><br><span class="line">    <span class="hljs-comment">// eliminate rehashings during insertion.</span></span><br><span class="line">    <span class="hljs-keyword">var</span> result = _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>&gt;()</span><br><span class="line">    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> <span class="hljs-keyword">try</span> isIncluded(element) &#123;</span><br><span class="line">          <span class="hljs-comment">// 满足条件的键值对添加到result中</span></span><br><span class="line">        result.insertNew(key: element.key, value: element.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Dictionary</span>(_native: result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时， <code>Dictionary</code> 满足 <code>Collection</code> 协议：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Dictionary</span>: <span class="hljs-title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">SubSequence</span> = <span class="hljs-type">Slice</span>&lt;<span class="hljs-type">Dictionary</span>&gt;</span><br><span class="line">  </span><br><span class="line">  @inlinable</span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> startIndex: <span class="hljs-type">Index</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> _variant.startIndex</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @inlinable</span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> endIndex: <span class="hljs-type">Index</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> _variant.endIndex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dictionary</code> 的下标操作符实现, 通过 <code>_Variant</code> 实现的 <code>_DictionaryBuffer</code> 协议定义的接口方法, 根据字典中的具体类型来调用对应的 <code>asNative</code> 与 <code>asCocoa</code> 对应的方法。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(key: <span class="hljs-type">Key</span>) -&gt; <span class="hljs-type">Value?</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> _variant.lookup(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> x = newValue &#123;</span><br><span class="line">        _variant.setValue(x, forKey: key)</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        removeValue(forKey: key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _modify &#123;</span><br><span class="line">      <span class="hljs-keyword">defer</span> &#123; _fixLifetime(<span class="hljs-keyword">self</span>) &#125;</span><br><span class="line">      yield &amp;_variant[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过给定的key去访问对应的值时，如果没有给定的key，则返回默认的值。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(</span><br><span class="line">    key: <span class="hljs-type">Key</span>, <span class="hljs-keyword">default</span> defaultValue: <span class="hljs-meta">@autoclosure</span> () -&gt; <span class="hljs-type">Value</span></span><br><span class="line">  ) -&gt; <span class="hljs-type">Value</span> &#123;</span><br><span class="line">    @inline(__always)</span><br><span class="line">    <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> _variant.lookup(key) ?? defaultValue()</span><br><span class="line">    &#125;</span><br><span class="line">    @inline(__always)</span><br><span class="line">    _modify &#123;</span><br><span class="line">      <span class="hljs-keyword">let</span> (bucket, found) = _variant.mutatingFind(key)</span><br><span class="line">      <span class="hljs-keyword">let</span> native = _variant.asNative</span><br><span class="line">      <span class="hljs-keyword">if</span> !found &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> value = defaultValue()</span><br><span class="line">        native._insert(at: bucket, key: key, value: value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">let</span> address = native._values + bucket.offset</span><br><span class="line">      <span class="hljs-keyword">defer</span> &#123; _fixLifetime(<span class="hljs-keyword">self</span>) &#125;</span><br><span class="line">      yield &amp;address.pointee</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>用法：<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> responseMessages = [<span class="hljs-number">200</span>: <span class="hljs-string">"OK"</span>,</span><br><span class="line">                        <span class="hljs-number">403</span>: <span class="hljs-string">"Access forbidden"</span>,</span><br><span class="line">                        <span class="hljs-number">404</span>: <span class="hljs-string">"File not found"</span>,</span><br><span class="line">                        <span class="hljs-number">500</span>: <span class="hljs-string">"Internal server error"</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> httpResponseCodes = [<span class="hljs-number">200</span>, <span class="hljs-number">403</span>, <span class="hljs-number">301</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> code <span class="hljs-keyword">in</span> httpResponseCodes &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> message = responseMessages[code, <span class="hljs-keyword">default</span>: <span class="hljs-string">"Unknown response"</span>]</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Response \(code): \(message)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Prints "Response 200: OK"</span></span><br><span class="line"><span class="hljs-comment">// Prints "Response 403: Access Forbidden"</span></span><br><span class="line"><span class="hljs-comment">// Prints "Response 301: Unknown response"</span></span><br></pre></td></tr></table></figure></p>
<p>返回通过给定的 <code>transform</code> 闭包对字典中的 <code>Value</code> 进行映射后的新字典。时间复杂度 O(n)。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapValues</span>&lt;T&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> transform: <span class="hljs-params">(Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt;(_native: _variant.mapValues(transform))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Dictionary._Varient</span></span><br><span class="line"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapValues</span>&lt;T&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> transform: <span class="hljs-params">(Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> -&gt; _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt; &#123;</span><br><span class="line">#<span class="hljs-keyword">if</span> _runtime(_ObjC)</span><br><span class="line">    <span class="hljs-keyword">guard</span> isNative <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> asCocoa.mapValues(transform)</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> asNative.mapValues(transform)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// _NativeDictionary</span></span><br><span class="line">  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapValues</span>&lt;T&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> transform: <span class="hljs-params">(Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> -&gt; _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> resultStorage = _DictionaryStorage&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt;.copy(original: _storage)</span><br><span class="line">    _internalInvariant(resultStorage._seed == _storage._seed)</span><br><span class="line">    <span class="hljs-keyword">let</span> result = _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt;(resultStorage)</span><br><span class="line">    <span class="hljs-comment">// Because the current and new buffer have the same scale and seed, we can</span></span><br><span class="line">    <span class="hljs-comment">// initialize to the same locations in the new buffer, skipping hash value</span></span><br><span class="line">    <span class="hljs-comment">// recalculations.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> hashTable &#123;</span><br><span class="line">      <span class="hljs-keyword">let</span> key = <span class="hljs-keyword">self</span>.uncheckedKey(at: bucket)</span><br><span class="line">      <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">self</span>.uncheckedValue(at: bucket)</span><br><span class="line">      <span class="hljs-keyword">try</span> result._insert(at: bucket, key: key, value: transform(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的compactMap版本，只返回非 <code>nil</code> 的 value。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compactMapValues</span>&lt;T&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> transform: <span class="hljs-params">(Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T?</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> result: _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt; =</span><br><span class="line">      <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.<span class="hljs-built_in">reduce</span>(into: _NativeDictionary&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt;()) &#123; (result, element) <span class="hljs-keyword">in</span></span><br><span class="line">      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">try</span> transform(element.value) &#123;</span><br><span class="line">        result.insertNew(key: element.key, value: value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Dictionary</span>&lt;<span class="hljs-type">Key</span>, <span class="hljs-type">T</span>&gt;(_native: result)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用实例：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-string">"a"</span>: <span class="hljs-string">"1"</span>, <span class="hljs-string">"b"</span>: <span class="hljs-string">"three"</span>, <span class="hljs-string">"c"</span>: <span class="hljs-string">"///4///"</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> m: [<span class="hljs-type">String</span>: <span class="hljs-type">Int?</span>] = data.mapValues &#123; str <span class="hljs-keyword">in</span> <span class="hljs-type">Int</span>(str) &#125;</span><br><span class="line"><span class="hljs-comment">// ["a": 1, "b": nil, "c": nil]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> <span class="hljs-built_in">c</span>: [<span class="hljs-type">String</span>: <span class="hljs-type">Int</span>] = data.compactMapValues &#123; str <span class="hljs-keyword">in</span> <span class="hljs-type">Int</span>(str) &#125;</span><br><span class="line"><span class="hljs-comment">// ["a": 1]</span></span><br></pre></td></tr></table></figure>
<p>同上面的初始化方法， <code>merge</code>方法将键值对序列/字典合并到当前字典中，并且可以通过 <code>combine</code> 闭包来知道想要的 value。</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span>&lt;S: Sequence&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> other: __owned S,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    uniquingKeysWith combine: <span class="hljs-params">(Value, Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Value</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> <span class="hljs-keyword">where</span> <span class="hljs-type">S</span>.<span class="hljs-type">Element</span> == (<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> _variant.merge(other, uniquingKeysWith: combine)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-number">_</span> other: __owned [Key: Value],</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    uniquingKeysWith combine: <span class="hljs-params">(Value, Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Value</span></span><br><span class="line">  ) <span class="hljs-keyword">rethrows</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> _variant.merge(</span><br><span class="line">      other.<span class="hljs-built_in">lazy</span>.<span class="hljs-built_in">map</span> &#123; ($<span class="hljs-number">0</span>, $<span class="hljs-number">1</span>) &#125;, uniquingKeysWith: combine)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>合并当前字典与键值对序列/字典并且返回新的字典。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> __consuming <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merging</span>&lt;S: Sequence&gt;<span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  <span class="hljs-number">_</span> other: __owned S,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">  uniquingKeysWith combine: <span class="hljs-params">(Value, Value)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Value</span></span><br><span class="line">) <span class="hljs-keyword">rethrows</span> -&gt; [<span class="hljs-type">Key</span>: <span class="hljs-type">Value</span>] <span class="hljs-keyword">where</span> <span class="hljs-type">S</span>.<span class="hljs-type">Element</span> == (<span class="hljs-type">Key</span>, <span class="hljs-type">Value</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">self</span></span><br><span class="line">  <span class="hljs-keyword">try</span> result._variant.merge(other, uniquingKeysWith: combine)</span><br><span class="line">  <span class="hljs-keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> dictionary = [<span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"b"</span>: <span class="hljs-number">2</span>]</span><br><span class="line"><span class="hljs-keyword">let</span> otherDictionary = [<span class="hljs-string">"a"</span>: <span class="hljs-number">3</span>, <span class="hljs-string">"b"</span>: <span class="hljs-number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> keepingCurrent = dictionary.merging(otherDictionary) &#123; (current, <span class="hljs-number">_</span>) <span class="hljs-keyword">in</span> current &#125;</span><br><span class="line"><span class="hljs-comment">// ["b": 2, "a": 1]</span></span><br><span class="line"><span class="hljs-keyword">let</span> replacingCurrent = dictionary.merging(otherDictionary) &#123; (<span class="hljs-number">_</span>, new) <span class="hljs-keyword">in</span> new &#125;</span><br><span class="line"><span class="hljs-comment">// ["b": 4, "a": 3]</span></span><br></pre></td></tr></table></figure></p>
<p>返回当前字典索引key或者value的集合</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> keys: <span class="hljs-type">Keys</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// FIXME(accessors): Provide a _read</span></span><br><span class="line">    <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-type">Keys</span>(_dictionary: <span class="hljs-keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> values: <span class="hljs-type">Values</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// FIXME(accessors): Provide a _read</span></span><br><span class="line">    <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-type">Values</span>(_dictionary: <span class="hljs-keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻完 <code>Dictionary</code> 的源码之后，感觉对 Swift 中哈希表的具体实现有了更清楚的认识，还有一些之前并没有注意到的比较实用的方法，如 <code>merge</code> 和 <code>grouping</code>等。以后要多花点时间来多看看标准库中的具体实现。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr>

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/awind" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2019 Phillip<br></p>
            </div>
        </div>
    </div>
</footer>


</body>

</html>